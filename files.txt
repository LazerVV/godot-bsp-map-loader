./plugin.gd:
```
@tool
extends EditorPlugin

var bsp_loader = preload("res://addons/bsp_loader/bsp_loader.gd").new()
var importer = null
var dock = null
var file_dialog = null

func _enter_tree():
	print("BSP Loader Plugin: Entering tree")
	importer = BSPImportPlugin.new(self)
	add_import_plugin(importer)
	
	# Add dock
	dock = preload("res://addons/bsp_loader/bsp_loader_dock.tscn").instantiate()
	add_control_to_bottom_panel(dock, "BSP Loader")
	
	# Create file dialog
	file_dialog = FileDialog.new()
	file_dialog.file_mode = FileDialog.FILE_MODE_OPEN_FILE
	file_dialog.access = FileDialog.ACCESS_RESOURCES
	file_dialog.filters = PackedStringArray(["*.bsp ; BSP Files"])
	file_dialog.file_selected.connect(_on_file_selected)
	get_editor_interface().get_base_control().add_child(file_dialog)
	
	dock.connect("import_bsp", _on_import_bsp_pressed)

func _exit_tree():
	print("BSP Loader Plugin: Exiting tree")
	if importer:
		remove_import_plugin(importer)
		importer = null
	if dock:
		remove_control_from_bottom_panel(dock)
		dock.queue_free()
		dock = null
	if file_dialog:
		file_dialog.queue_free()
		file_dialog = null

func _on_import_bsp_pressed():
	file_dialog.popup_centered(Vector2i(600, 400))

func _on_file_selected(path: String):
	print("Selected BSP file: ", path)
	var filesystem = get_editor_interface().get_resource_filesystem()
	filesystem.reimport_files([path])

class BSPImportPlugin extends EditorImportPlugin:
	var plugin_ref
	
	func _init(ref):
		plugin_ref = ref
		print("BSPImportPlugin: Initialized")
	
	func _get_importer_name() -> String:
		return "bsp_importer"
	
	func _get_visible_name() -> String:
		return "Quake 3 BSP Importer"
	
	func _get_recognized_extensions() -> PackedStringArray:
		print("BSPImportPlugin: Called _get_recognized_extensions")
		return ["bsp"]
	
	func _get_save_extension() -> String:
		return "tscn"
	
	func _get_resource_type() -> String:
		return "PackedScene"
	
	func _get_preset_count() -> int:
		return 1
	
	func _get_preset_name(preset: int) -> String:
		return "Default"
	
	func _get_import_options(path: String, preset: int) -> Array[Dictionary]:
		print("BSPImportPlugin: Called _get_import_options for path: ", path)
		return []
	
	func _get_priority() -> float:
		print("BSPImportPlugin: Called _get_priority")
		return 1.0
	
	func _get_import_order() -> int:
		print("BSPImportPlugin: Called _get_import_order")
		return 0
	
	func _import(source_file: String, save_path: String, options: Dictionary, platform_variants: Array[String], gen_files: Array[String]) -> Error:
		print("BSPImportPlugin: Importing ", source_file)
		var bsp_node = plugin_ref.bsp_loader.load_bsp(source_file)
		if not bsp_node:
			push_error("Failed to load BSP file: ", source_file)
			return ERR_CANT_CREATE
		
		var scene = PackedScene.new()
		var result = scene.pack(bsp_node)
		if result != OK:
			push_error("Failed to pack scene: ", result)
			return result
		
		var save_file = save_path + "." + _get_save_extension()
		result = ResourceSaver.save(scene, save_file)
		if result != OK:
			push_error("Failed to save scene: ", result)
			return result
		
		print("BSPImportPlugin: Successfully imported ", source_file, " to ", save_file)
		return OK
```

./BezierMesh.gd:
```
class_name BezierMesh extends Node

# Constants
const APROX_ERROR: float = 0.001

# Cache arrays for mesh data
static var verts_cache: Array[Vector3] = []
static var uv_cache: Array[Vector2] = []
static var uv2_cache: Array[Vector2] = []
static var normals_cache: Array[Vector3] = []
static var verts_color: Array[Color] = []
static var indices_cache: Array[int] = []

# Local caches for collision processing
static var verts_local_cache: Array[Vector3] = []
static var p0s_cache: Array[Vector3] = []
static var p1s_cache: Array[Vector3] = []
static var p2s_cache: Array[Vector3] = []

# Enum for axis selection
enum Axis { NONE, X, Y, Z }

# Clear all caches
static func clear_caches() -> void:
	verts_cache.clear()
	uv_cache.clear()
	uv2_cache.clear()
	normals_cache.clear()
	verts_color.clear()
	indices_cache.clear()
	verts_local_cache.clear()
	p0s_cache.clear()
	p1s_cache.clear()
	p2s_cache.clear()

# Bernstein polynomial for Bezier patch interpolation
static func bernstein(t: float, i: int, n: int) -> float:
	var bin: float = 1.0
	for k in range(i):
		bin *= (n - k) / float(k + 1)
	return bin * pow(t, i) * pow(1.0 - t, n - i)

# Finalize the Bezier mesh
static func finalize_bezier_mesh(arr_mesh: ArrayMesh) -> void:
	if verts_cache.is_empty():
		push_warning("No vertices in Bezier mesh cache")
		return
	
	var surface_array: Array = []
	surface_array.resize(Mesh.ARRAY_MAX)
	
	surface_array[Mesh.ARRAY_VERTEX] = verts_cache
	surface_array[Mesh.ARRAY_TEX_UV] = uv_cache
	surface_array[Mesh.ARRAY_TEX_UV2] = uv2_cache
	surface_array[Mesh.ARRAY_COLOR] = verts_color
	surface_array[Mesh.ARRAY_NORMAL] = normals_cache
	surface_array[Mesh.ARRAY_INDEX] = indices_cache
	
	arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)
	
	# Use SurfaceTool to ensure tangents and smooth normals
	var st: SurfaceTool = SurfaceTool.new()
	st.create_from(arr_mesh, 0)
	st.generate_tangents()
	arr_mesh.clear_surfaces()
	surface_array = st.commit_to_arrays()
	arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)

# Generate collider mesh for a Bezier patch
static func bezier_collider_mesh(owner_shape_id: int, collider: CollisionObject3D, surface_id: int, patch_number: int, control: Array[Vector3]) -> void:
	if control.size() != 9:
		push_warning("BezierColliderMesh: Invalid control points count %d for surface %d patch %d" % [control.size(), surface_id, patch_number])
		return
	
	const COLLIDER_TESSELLATIONS: int = 4
	var step: float = 1.0 / COLLIDER_TESSELLATIONS
	var iter_one: int = COLLIDER_TESSELLATIONS
	var iter_two: int = COLLIDER_TESSELLATIONS
	var collinear: bool = false
	var all_collinear: bool = false
	
	# Resize local cache
	if verts_local_cache.size() < control.size():
		verts_local_cache.resize(control.size())
	
	# Check row collinearity
	p0s_cache.clear()
	p1s_cache.clear()
	p2s_cache.clear()
	for i in range(3):
		p0s_cache.append(control[i])
		p1s_cache.append(control[3 + i])
		p2s_cache.append(control[6 + i])
	
	collinear = are_points_collinear(p0s_cache) and are_points_collinear(p1s_cache) and are_points_collinear(p2s_cache)
	
	# Check column collinearity
	if not collinear:
		p0s_cache.clear()
		p1s_cache.clear()
		p2s_cache.clear()
		for i in range(3):
			p0s_cache.append(control[3 * i])
			p1s_cache.append(control[(3 * i) + 1])
			p2s_cache.append(control[(3 * i) + 2])
		
		collinear = are_points_collinear(p0s_cache) and are_points_collinear(p1s_cache) and are_points_collinear(p2s_cache)
	else:
		# Check if all points are collinear
		all_collinear = true
		for j in range(3):
			verts_local_cache.clear()
			for i in range(3):
				verts_local_cache.append(control[(3 * i) + j])
			all_collinear = all_collinear and are_points_collinear(verts_local_cache)
			if not all_collinear:
				break
		if all_collinear:
			iter_two = 1
			verts_local_cache.clear()
			verts_local_cache.append_array(control)
	
	if collinear:
		iter_one = 1
	
	for i in range(iter_one):
		if not collinear:
			var s: float = i * step
			var f: float = (i + 1) * step
			var m: float = (s + f) / 2.0
			p0s_cache.clear()
			p1s_cache.clear()
			p2s_cache.clear()
			
			# Top row
			p0s_cache.append(bez_curve(s, control[0], control[1], control[2]))
			p0s_cache.append(bez_curve(m, control[0], control[1], control[2]))
			p0s_cache.append(bez_curve(f, control[0], control[1], control[2]))
			
			# Middle row
			p1s_cache.append(bez_curve(s, control[3], control[4], control[5]))
			p1s_cache.append(bez_curve(m, control[3], control[4], control[5]))
			p1s_cache.append(bez_curve(f, control[3], control[4], control[5]))
			
			# Bottom row
			p2s_cache.append(bez_curve(s, control[6], control[7], control[8]))
			p2s_cache.append(bez_curve(m, control[6], control[7], control[8]))
			p2s_cache.append(bez_curve(f, control[6], control[7], control[8]))
		
		for j in range(iter_two):
			if not all_collinear:
				var s: float = j * step
				var f: float = (j + 1) * step
				var m: float = (s + f) / 2.0
				verts_local_cache.clear()
				
				# Top row
				verts_local_cache.append(bez_curve(s, p0s_cache[0], p1s_cache[0], p2s_cache[0]))
				verts_local_cache.append(bez_curve(m, p0s_cache[0], p1s_cache[0], p2s_cache[0]))
				verts_local_cache.append(bez_curve(f, p0s_cache[0], p1s_cache[0], p2s_cache[0]))
				
				# Middle row
				verts_local_cache.append(bez_curve(s, p0s_cache[1], p1s_cache[1], p2s_cache[1]))
				verts_local_cache.append(bez_curve(m, p0s_cache[1], p1s_cache[1], p2s_cache[1]))
				verts_local_cache.append(bez_curve(f, p0s_cache[1], p1s_cache[1], p2s_cache[1]))
				
				# Bottom row
				verts_local_cache.append(bez_curve(s, p2s_cache[2], p1s_cache[2], p2s_cache[2]))
				verts_local_cache.append(bez_curve(m, p2s_cache[2], p1s_cache[2], p2s_cache[2]))
				verts_local_cache.append(bez_curve(f, p2s_cache[2], p1s_cache[2], p2s_cache[2]))
			
			var normal: Vector3 = Vector3.ZERO
			var verts_clean_local_cache: Array[Vector3] = remove_duplicated_vectors(verts_local_cache)
			if not can_form_3d_convex_hull(verts_clean_local_cache, normal, 0.00015):
				if normal.length_squared() == 0:
					push_warning("BezierColliderMesh: Cannot Form 2D/3D ConvexHull %d_%d" % [surface_id, patch_number])
					return
				
				var axis: Axis
				var change_rotation: Basis = Basis.IDENTITY
				var vertex_2d: Array[Vector2] = []
				
				# Determine dominant axis
				if is_equal_approx(abs(normal.x), 1.0):
					axis = Axis.X
				elif is_equal_approx(abs(normal.y), 1.0):
					axis = Axis.Y
				elif is_equal_approx(abs(normal.z), 1.0):
					axis = Axis.Z
				else:
					var x: float = abs(normal.x)
					var y: float = abs(normal.y)
					var z: float = abs(normal.z)
					var normal_ref: Vector3 = Vector3.ZERO
					
					if x >= y and x >= z:
						axis = Axis.X
					elif y >= x and y >= z:
						axis = Axis.Y
					else:
						axis = Axis.Z
					
					match axis:
						Axis.X:
							normal_ref = Vector3.RIGHT if normal.x > 0 else Vector3.LEFT
						Axis.Y:
							normal_ref = Vector3.UP if normal.y > 0 else Vector3.DOWN
						Axis.Z:
							normal_ref = Vector3.BACK if normal.z > 0 else Vector3.FORWARD
					
					# Calculate rotation to align normal
					var transform: Transform3D = Transform3D.IDENTITY.looking_at(normal_ref, Vector3.UP)
					change_rotation = transform.basis.inverse() * Basis.looking_at(normal, Vector3.UP)
				
				# Project to 2D
				var offset: float = 0.0
				for k in range(verts_clean_local_cache.size()):
					var vertex: Vector3 = change_rotation * verts_clean_local_cache[k]
					match axis:
						Axis.X:
							vertex_2d.append(Vector2(vertex.y, vertex.z))
							offset += vertex.x
						Axis.Y:
							vertex_2d.append(Vector2(vertex.x, vertex.z))
							offset += vertex.y
						Axis.Z:
							vertex_2d.append(Vector2(vertex.x, vertex.y))
							offset += vertex.z
				
				offset /= verts_clean_local_cache.size()
				# Debug ConvexHull2D access
				if not is_instance_valid(ConvexHull2D):
					push_error("ConvexHull2D class not found for surface %d patch %d" % [surface_id, patch_number])
					return
				print("Calling ConvexHull2D.generate_convex_hull with %d points: %s" % [vertex_2d.size(), vertex_2d])
				vertex_2d = ConvexHull2D.generate_convex_hull(vertex_2d)
				if vertex_2d.is_empty():
					push_warning("BezierColliderMesh: Cannot Form 2D ConvexHull %d_%d" % [surface_id, patch_number])
					return
				
				# Transform back to 3D
				change_rotation = change_rotation.inverse()
				verts_clean_local_cache.clear()
				for k in range(vertex_2d.size()):
					var vertex_3d: Vector3
					match axis:
						Axis.X:
							vertex_3d = Vector3(offset, vertex_2d[k].x, vertex_2d[k].y)
						Axis.Y:
							vertex_3d = Vector3(vertex_2d[k].x, offset, vertex_2d[k].y)
						Axis.Z:
							vertex_3d = Vector3(vertex_2d[k].x, vertex_2d[k].y, offset)
					vertex_3d = change_rotation * vertex_3d
					verts_clean_local_cache.append(vertex_3d)
				
				verts_clean_local_cache = get_extruded_vertices_from_points(remove_duplicated_vectors(verts_clean_local_cache), normal)
			
			var convex_hull: ConvexPolygonShape3D = ConvexPolygonShape3D.new()
			convex_hull.points = verts_clean_local_cache
			collider.shape_owner_add_shape(owner_shape_id, convex_hull)

# Quadratic Bezier curve for Vector3 (used for collision)
static func bez_curve(t: float, p0: Vector3, p1: Vector3, p2: Vector3) -> Vector3:
	var a: float = 1.0 - t
	var tt: float = t * t
	var t_points: Array[float] = [0.0, 0.0, 0.0]
	
	for i in range(3):
		t_points[i] = a * a * p0[i] + 2.0 * a * t * p1[i] + tt * p2[i]
	
	return Vector3(t_points[0], t_points[1], t_points[2])

# Check if points are collinear
static func are_points_collinear(points: Array[Vector3]) -> bool:
	const EPSILON: float = 0.0001
	
	if points.size() < 3:
		return false
	
	var first_direction: Vector3 = points[1] - points[0]
	for i in range(2, points.size()):
		var current_direction: Vector3 = points[i] - points[0]
		if first_direction.cross(current_direction).length_squared() > EPSILON:
			return false
	return true

# Remove duplicated vectors
static func remove_duplicated_vectors(test: Array[Vector3]) -> Array[Vector3]:
	var unique_vector: Array[Vector3] = []
	var previous_point: Vector3 = Vector3.ZERO
	
	for i in range(test.size()):
		var is_unique: bool = true
		for j in range(i + 1, test.size()):
			if float_approx(test[i].x, test[j].x) and float_approx(test[i].y, test[j].y) and float_approx(test[i].z, test[j].z):
				is_unique = false
				break
		if is_unique:
			if not unique_vector.is_empty():
				unique_vector.sort_custom(func(a, b): return (a - previous_point).length_squared() < (b - previous_point).length_squared())
			var rounded: Vector3 = Vector3(round_up_4_decimals(test[i].x), round_up_4_decimals(test[i].y), round_up_4_decimals(test[i].z))
			unique_vector.append(rounded)
			previous_point = rounded
	
	return unique_vector

static func float_approx(f1: float, f2: float) -> bool:
	var d: float = f1 - f2
	return d >= -APROX_ERROR and d <= APROX_ERROR

static func round_up_4_decimals(f: float) -> float:
	return ceil(f * 10000.0) / 10000.0

# Get extruded vertices from points
static func get_extruded_vertices_from_points(points: Array[Vector3], normal: Vector3) -> Array[Vector3]:
	var vertices: Array[Vector3] = []
	var depth: float = 0.002
	
	vertices.append_array(points)
	for point in points:
		var vertice: Vector3 = point - depth * normal
		vertices.append(vertice)
	
	return vertices

# Check if points can form a 3D convex hull
static func can_form_3d_convex_hull(points: Array[Vector3], normal: Vector3, discard_limit: float = 0.00001) -> bool:
	if points.size() < 4:
		return false
	
	var retried: bool = false
	var i: int = 0
	
	while true:
		# Calculate a normal vector
		for u in range(points.size()):
			var v1: Vector3 = points[1] - points[u]
			var v2: Vector3 = points[2] - points[u]
			normal = v1.cross(v2)
			
			if normal.length_squared() > 0:
				break
			if i == 0:
				i = 2
		
		if i == points.size():
			if retried:
				return false
			retried = true
			points = remove_duplicated_vectors(points)
			continue
		
		# Check if all points lie on the plane
		for j in range(points.size()):
			var px: Vector3 = points[j] - points[0]
			var dot_product: float = px.dot(normal)
			
			if abs(dot_product) > discard_limit:
				normal = normal.normalized()
				return true
		
		normal = normal.normalized()
		return false
	return false
```

./bsp_texture_loader.gd:
```
class_name BSPTextureLoader
extends RefCounted

var texture_base_paths: Array[String] = [
	"/home/l0rd/STORE/XONOTIC_DATA"
]
var valid_extensions: Array[String] = ["tga", "png", "jpg", "jpeg", "bmp"]
var cached_texture_string: String = ""
var texture_scan_cache: Dictionary = {}
var non_solid_shaders: Array[String] = []
var shader_data: Dictionary = {} # Global shader definitions
var debug_logging: bool = false # Control verbosity of logging

func load_all_shader_files() -> void:
	var scripts_dir = "/home/l0rd/STORE/XONOTIC_DATA/scripts/"
	var dir = DirAccess.open(scripts_dir)
	if not dir:
		if debug_logging:
			print("Failed to open scripts directory: %s" % scripts_dir)
		return
	
	var shader_files: Array[String] = []
	dir.list_dir_begin()
	var file_name = dir.get_next()
	while file_name != "":
		if file_name.ends_with(".shader"):
			shader_files.append(scripts_dir.path_join(file_name))
		file_name = dir.get_next()
	dir.list_dir_end()
	
	# Sort files alphabetically
	shader_files.sort()
	
	# Parse each shader file
	for shader_file in shader_files:
		var file_data = parse_shader_file(shader_file)
		for shader_name in file_data.keys():
			shader_data[shader_name] = file_data[shader_name]
			if debug_logging:
				print("Loaded shader %s from %s" % [shader_name, shader_file])

func parse_shader_file(path: String) -> Dictionary:
	var file_data: Dictionary = {}
	if not FileAccess.file_exists(path):
		if debug_logging:
			print("Shader file not found: %s" % path)
		return file_data
	
	var file = FileAccess.open(path, FileAccess.READ)
	var current_shader: String = ""
	var current_block: Dictionary = {}
	var in_block: bool = false
	var in_texture_block: bool = false
	
	while not file.eof_reached():
		var line = file.get_line().strip_edges()
		if line.begins_with("//") or line == "":
			continue
		if line.begins_with("textures/"):
			current_shader = line.replace("textures/", "")
			current_block = {"surfaceparms": [], "stages": [], "cull": ""}
			file_data[current_shader] = current_block
			in_block = true
			continue
		if in_block:
			if line == "{":
				if in_texture_block:
					current_block.stages.append({})
				else:
					in_texture_block = true
				continue
			if line == "}":
				if in_texture_block:
					in_texture_block = false
				else:
					in_block = false
					if debug_logging:
						print("Parsed shader %s: %s" % [current_shader, current_block])
				continue
			if in_texture_block:
				var parts = line.split(" ", false)
				if parts.size() > 0:
					if parts[0] in ["map", "blendFunc", "alphaFunc"]:
						var stage = {}
						if parts[0] == "map":
							stage["map"] = parts[1].replace("textures/", "") if parts.size() > 1 else ""
						elif parts[0] == "blendFunc":
							if parts.size() == 2 and parts[1] == "blend":
								stage["blendFunc"] = ["GL_SRC_ALPHA", "GL_ONE_MINUS_SRC_ALPHA"]
							elif parts.size() > 2:
								stage["blendFunc"] = parts.slice(1)
						elif parts[0] == "alphaFunc":
							stage["alphaFunc"] = parts[1] if parts.size() > 1 else ""
						if stage:
							current_block.stages.append(stage)
			else:
				if line.begins_with("surfaceparm"):
					var parm = line.split(" ")[1] if line.split(" ").size() > 1 else ""
					current_block.surfaceparms.append(parm)
					if parm == "nonsolid":
						non_solid_shaders.append(current_shader)
				elif line == "cull none":
					current_block["cull"] = "none"
	file.close()
	return file_data

func load_textures(shaders: Array[Dictionary], faces: Array[Dictionary]) -> Dictionary:
	var texture_dir = "res://assets/textures/"
	DirAccess.make_dir_recursive_absolute(texture_dir)
	
	# Load all shader files
	load_all_shader_files()
	
	# Filter shaders used by renderable faces
	var used_shader_indices: Array[int] = []
	for face in faces:
		if face.shader_num >= 0 and face.shader_num < shaders.size():
			if not used_shader_indices.has(face.shader_num):
				used_shader_indices.append(face.shader_num)
	
	var used_shaders: Array[Dictionary] = []
	for idx in used_shader_indices:
		var shader = shaders[idx]
		if shader.name not in BSPCommon.NON_RENDER_SHADERS or shader.name == "common/invisible":
			used_shaders.append(shader)
	
	if debug_logging:
		print("Loading textures for %d used shaders: %s" % [used_shaders.size(), used_shaders.map(func(s): return s.get("name", "INVALID_SHADER"))])
	
	# Create required folders
	var required_folders: Array[String] = []
	for sh in used_shaders:
		var top_level = sh.name.get_base_dir().split("/")[0]
		if top_level and not required_folders.has(top_level):
			required_folders.append(top_level)
			var folder_path = texture_dir.path_join(top_level)
			DirAccess.make_dir_recursive_absolute(folder_path)
			if debug_logging:
				print("Created folder: %s" % folder_path)
	
	# Scan textures
	var texture_cache = {"files": [], "textures": {}}
	if debug_logging:
		print("REQUIRED FOLDERS: " + str(required_folders))
	if texture_scan_cache.is_empty():
		scan_textures(required_folders)
	
	# Match and copy textures
	var suffixes: Array[String] = ["_norm", "_glow", "_gloss", "_reflect"]
	var special_keywords: Array[String] = ["$lightmap", "$whiteimage", "$blackimage"]
	for sh in used_shaders:
		var shader_name = sh.name
		var tex_name = shader_name
		var map_texture = ""
		if shader_data.has(shader_name) and shader_data[shader_name].has("stages"):
			if debug_logging:
				print("Shader stages for %s: %s" % [shader_name, shader_data[shader_name].stages])
			for stage in shader_data[shader_name].stages:
				if stage.has("map") and stage["map"] and stage["map"] not in special_keywords:
					map_texture = stage["map"].get_basename()
					tex_name = map_texture
					break
		if not map_texture or map_texture in special_keywords:
			tex_name = shader_name
		var matched_textures = match_texture_no_one_is_allowed_to_modify_this_function(tex_name, suffixes)
		if map_texture and not matched_textures.has(""):
			matched_textures = match_texture_no_one_is_allowed_to_modify_this_function(shader_name, suffixes)
		if debug_logging:
			print("MATCHED TEXTURES for %s (tried %s): %s" % [shader_name, tex_name, matched_textures])
		for suffix in matched_textures:
			var tex_key = shader_name + suffix
			var dst = "res://assets/textures/" + shader_name + suffix + ".png"
			DirAccess.make_dir_recursive_absolute(dst.get_base_dir())
			if matched_textures[suffix].begins_with("zip:"):
				var zip = ZIPReader.new()
				var err = zip.open(matched_textures[suffix].get_base_dir())
				if err == OK:
					var bytes = zip.read_file(matched_textures[suffix].substr(4))
					var img = Image.new()
					var ext = matched_textures[suffix].get_extension().to_lower()
					var load_err = OK
					if ext == "tga":
						load_err = img.load_tga_from_buffer(bytes)
					elif ext == "png":
						load_err = img.load_png_from_buffer(bytes)
					elif ext == "jpg" or ext == "jpeg":
						load_err = img.load_jpg_from_buffer(bytes)
					elif ext == "bmp":
						load_err = img.load_bmp_from_buffer(bytes)
					else:
						if debug_logging:
							print("Unsupported texture format: %s for %s" % [ext, shader_name])
						continue
					if load_err == OK and not img.is_empty():
						img.save_png(dst)
						if suffix == "":
							texture_cache.textures[shader_name] = ImageTexture.create_from_image(img)
						texture_cache.textures[tex_key] = ImageTexture.create_from_image(img)
						if debug_logging:
							print("Extracted and saved texture: %s" % dst)
					else:
						if debug_logging:
							print("Failed to load texture: %s (Error: %d, Empty: %s)" % [matched_textures[suffix], load_err, img.is_empty()])
					zip.close()
				else:
					if debug_logging:
						print("Failed to open PK3: %s (Error: %d)" % [matched_textures[suffix], err])
			else:
				var src = matched_textures[suffix]
				if FileAccess.file_exists(src):
					var img = Image.new()
					var load_err = img.load(src)
					if load_err == OK and not img.is_empty():
						img.save_png(dst)
						if suffix == "":
							texture_cache.textures[shader_name] = ImageTexture.create_from_image(img)
						texture_cache.textures[tex_key] = ImageTexture.create_from_image(img)
						if debug_logging:
							print("Loaded and saved texture: %s" % dst)
					else:
						if debug_logging:
							print("Failed to load texture: %s (Error: %d, Empty: %s)" % [src, load_err, img.is_empty()])
				else:
					if debug_logging:
						print("Texture file not found: %s" % src)
	
	if debug_logging:
		print("TEXTURE CACHE KEYS: %s" % texture_cache.textures.keys())
	return texture_cache

func scan_textures(required_folders: Array[String]) -> void:
	cached_texture_string = ""
	
	for base_path in texture_base_paths:
		var cache_key = base_path + str(required_folders)
		if texture_scan_cache.has(cache_key):
			cached_texture_string += texture_scan_cache[cache_key] + "\n"
			continue
		var path_string = ""
		
		# Collect and sort PK3 files
		var pk3_files: Array[String] = []
		var dir = DirAccess.open(base_path)
		if dir:
			if debug_logging:
				print("Opened directory: %s" % base_path)
			dir.list_dir_begin()
			var file_name = dir.get_next()
			while file_name != "":
				if file_name.ends_with(".pk3"):
					pk3_files.append(base_path.path_join(file_name))
				file_name = dir.get_next()
			dir.list_dir_end()
		else:
			if debug_logging:
				print("Failed to open directory: %s" % base_path)
		
		# Sort PK3 files alphabetically
		pk3_files.sort()
		if debug_logging:
			print("PK3 files found: ", pk3_files)
		
		# Process PK3 files
		for pk3_path in pk3_files:
			var zip = ZIPReader.new()
			if zip.open(pk3_path) == OK:
				for file in zip.get_files():
					var ext = file.get_extension().to_lower()
					if valid_extensions.has(ext) and file.begins_with("textures/"):
						if path_string != "":
							path_string += "\n"
						path_string += "zip:" + pk3_path + "/" + file
				zip.close()
			else:
				if debug_logging:
					print("Failed to open PK3: %s" % pk3_path)
		
		# Process regular files in textures/ subdirectory
		var textures_dir = base_path.path_join("textures")
		if DirAccess.dir_exists_absolute(textures_dir):
			for file_info in scan_directory(textures_dir):
				if path_string != "":
					path_string += "\n"
				path_string += file_info.path
		else:
			if debug_logging:
				print("Textures directory not found: %s" % textures_dir)
		
		texture_scan_cache[cache_key] = path_string
		cached_texture_string += path_string + "\n"

func scan_directory(path: String) -> Array:
	var files: Array = []
	var dir = DirAccess.open(path)
	if not dir:
		var global_path = ProjectSettings.globalize_path(path)
		dir = DirAccess.open(global_path)
		if not dir:
			if debug_logging:
				print("Failed to open directory for scanning: %s" % path)
			return files
	
	dir.list_dir_begin()
	var file_name = dir.get_next()
	while file_name != "":
		var full_path = path.path_join(file_name)
		if dir.current_is_dir():
			files.append_array(scan_directory(full_path))
		else:
			var ext = file_name.get_extension().to_lower()
			if valid_extensions.has(ext):
				var rel_path = full_path.replace(path.get_base_dir(), "").trim_prefix("/")
				files.append({
					"path": full_path,
					"source": "dir",
					"rel_path": rel_path,
					"ext": "." + ext
				})
		file_name = dir.get_next()
	dir.list_dir_end()
	return files

func generate_shader_path_variants(parts: Array, no_strip_end: bool = false) -> Array:
	var result := []
	var dirs = parts.duplicate()
	if not no_strip_end:
		dirs = dirs.slice(0, max(0, dirs.size() - 1))
	var n = dirs.size()
	if no_strip_end:
		if parts.size() < 1:
			return result
		var rev = dirs.duplicate()
		rev.reverse()
		for i in range(rev.size()):
			for j in range(i + 1, rev.size() + 1):
				if j - i <= 0:
					continue
				var slice = rev.slice(i, j)
				slice.reverse()
				result.append(String("_").join(slice))
				result.append(String("-").join(slice))
	else:
		if parts.size() < 2:
			return result
		for i in range(n):
			for j in range(i + 1, n + 1):
				if j - i <= 0:
					continue
				var slice = dirs.slice(i, j)
				result.append(String("_").join(slice))
				result.append(String("-").join(slice))
				result.append(String("/").join(slice))
	return result

func dedupe_array(arr: Array) -> Array:
	var seen := {}
	var out := []
	for v in arr:
		if not seen.has(v):
			seen[v] = true
			out.append(v)
	return out

func match_texture_no_one_is_allowed_to_modify_this_function(shader_name: String, suffixes: Array[String]) -> Dictionary:
	var shader_parts = shader_name.strip_edges().get_file().replace("-", "_").split("_")
	var shader_parts2 = shader_name.strip_edges().get_file().replace("-", "_").replace("/", "_").split("_")
	var pattern_variants = generate_shader_path_variants(shader_parts).map(func(p): return p)
	var base_path_regex = "(" + String("|").join(dedupe_array(pattern_variants.filter(func(v): return v != "" and v != "/")).map(func(v): return v + "/")) + ")?" if pattern_variants.size() > 0 else ""
	var pattern_variants2 = generate_shader_path_variants(shader_parts2, true).map(func(p): return p)
	var base_path_regex2 = "(" + String("|").join(dedupe_array(pattern_variants2.filter(func(v): return v != "" and v != "/")).map(func(v): return "" + v)) + ")" if pattern_variants2.size() > 0 else ""
	var matched_textures: Dictionary = {}
	var regex = RegEx.new()
	var pattern = ""
	var do_crazy = true
	for crazy_bullshit in ["", "([-_][0-9]+)+"]:
		if do_crazy:
			pattern = "(?i).*/textures/" + shader_name.strip_edges().get_base_dir().replace("-", "[/-]").replace("_", "[/_]") + "/" + base_path_regex + base_path_regex2 + crazy_bullshit + "(" + String("|").join(suffixes) + ")?\\." + "(" + String("|").join(valid_extensions) + ")\\s*(\\n|\\z)"
			var err = regex.compile(pattern)
			if err != OK:
				if debug_logging:
					print("Regex compile error for shader: %s, suffix: %s (Pattern: %s, Error: %d)" % [shader_name, str(suffixes), pattern, err])
			var results = regex.search_all(cached_texture_string)
			if results:
				results.reverse()
				for result in results:
					var cleaned_result = result.get_string().strip_edges()
					for ext in valid_extensions:
						var ends_with_suffix = false
						for suffix in suffixes:
							if cleaned_result.ends_with(suffix + "." + ext):
								ends_with_suffix = true
								matched_textures[suffix] = cleaned_result
								do_crazy = false
						if not ends_with_suffix and cleaned_result.ends_with("." + ext):
							matched_textures[""] = cleaned_result
							do_crazy = false
	
	if matched_textures.is_empty():
		if debug_logging:
			print("SHADER NOT FOUND!!!: %s (Pattern: %s)" % [shader_name, pattern])
		
	return matched_textures

func create_materials(shaders: Array[Dictionary], texture_cache: Dictionary) -> Dictionary:
	var materials: Dictionary = {}
	if not texture_cache.has("textures"):
		texture_cache["textures"] = {}
	
	for sh in shaders:
		var sh_name = sh.name
		if sh_name in BSPCommon.NON_RENDER_SHADERS and sh_name != "common/invisible":
			if sh_name == "noshader":
				var mat = StandardMaterial3D.new()
				mat.resource_name = sh_name
				mat.albedo_color = Color(0, 0, 0, 0)
				mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
				materials[sh_name] = mat
				if debug_logging:
					print("Created transparent material for %s" % sh_name)
			continue
		var mat = StandardMaterial3D.new()
		mat.resource_name = sh_name # Set material name to shader name
		var found_base = false
		# Try shader name first
		var tex_key = sh_name
		if texture_cache.textures.has(tex_key):
			mat.albedo_texture = texture_cache.textures[tex_key]
			var img = texture_cache.textures[tex_key].get_image()
			if img and img.detect_alpha() != Image.ALPHA_NONE:
				mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
				mat.alpha_scissor_threshold = 0.5
			else:
				if debug_logging:
					print("Warning: Texture %s for material %s has no alpha channel" % [tex_key, sh_name])
			found_base = true
			if debug_logging:
				print("Applied texture %s to material %s" % [tex_key, sh_name])
		# Fallback to map directive
		if not found_base and shader_data.has(sh_name) and shader_data[sh_name].has("stages"):
			for stage in shader_data[sh_name].stages:
				if stage.has("map") and stage["map"] and not stage["map"].begins_with("$"):
					var map_name = stage["map"].get_basename()
					if texture_cache.textures.has(map_name):
						mat.albedo_texture = texture_cache.textures[map_name]
						var img = texture_cache.textures[map_name].get_image()
						if img and img.detect_alpha() != Image.ALPHA_NONE:
							mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
							mat.alpha_scissor_threshold = 0.5
						else:
							if debug_logging:
								print("Warning: Texture %s for material %s has no alpha channel" % [map_name, sh_name])
						found_base = true
						if debug_logging:
							print("Applied map texture %s to material %s (from map %s)" % [map_name, sh_name, stage["map"]])
						break
		if not found_base and sh_name == "common/invisible":
			var invisible_path = "res://assets/textures/common/invisible.tga"
			if FileAccess.file_exists(invisible_path):
				var img = Image.load_from_file(invisible_path)
				if img and not img.is_empty():
					mat.albedo_texture = ImageTexture.create_from_image(img)
					mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
					mat.alpha_scissor_threshold = 0.5
					found_base = true
				else:
					if debug_logging:
						print("Warning: Invisible texture %s not found or empty" % invisible_path)
			else:
				if debug_logging:
					print("Warning: Invisible texture %s not found" % invisible_path)
		if not found_base:
			if debug_logging:
				print("Warning: No texture found for material %s, using fallback" % sh_name)
			mat.albedo_color = Color(0.5, 0.5, 0.5, 1.0) # Gray fallback to avoid white
			mat.transparency = BaseMaterial3D.TRANSPARENCY_DISABLED
		if texture_cache.textures.has(sh_name + "_norm"):
			mat.normal_enabled = true
			mat.normal_texture = texture_cache.textures[sh_name + "_norm"]
			if debug_logging:
				print("Applied normal texture %s to material %s" % [sh_name + "_norm", sh_name])
		if texture_cache.textures.has(sh_name + "_glow"):
			mat.emission_enabled = true
			mat.emission_texture = texture_cache.textures[sh_name + "_glow"]
			mat.emission = Color(1, 1, 1)
			mat.emission_energy = 1.0
			if debug_logging:
				print("Applied emission texture %s to material %s" % [sh_name + "_glow", sh_name])
		if texture_cache.textures.has(sh_name + "_gloss"):
			mat.roughness_texture = texture_cache.textures[sh_name + "_gloss"]
			mat.roughness_texture_channel = StandardMaterial3D.TEXTURE_CHANNEL_RED
			if debug_logging:
				print("Applied gloss texture %s to material %s" % [sh_name + "_gloss", sh_name])
		if texture_cache.textures.has(sh_name + "_reflect"):
			mat.metallic = 1.0
			mat.metallic_texture = texture_cache.textures[sh_name + "_reflect"]
			mat.metallic_texture_channel = StandardMaterial3D.TEXTURE_CHANNEL_RED
			if debug_logging:
				print("Applied reflect texture %s to material %s" % [sh_name + "_reflect", sh_name])
		
		# Apply shader properties
		if shader_data.has(sh_name):
			var sh_data = shader_data[sh_name]
			if sh_data.has("stages"):
				for stage in sh_data.stages:
					if stage.has("blendFunc") and stage.blendFunc in ["GL_SRC_ALPHA", "GL_ONE_MINUS_SRC_ALPHA"]:
						mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
						mat.alpha_scissor_threshold = 0.5
						if debug_logging:
							print("Applied alpha blending for material %s" % sh_name)
					if stage.has("alphaFunc") and stage.alphaFunc == "GE128":
						mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA_SCISSOR
						mat.alpha_scissor_threshold = 0.5
						if debug_logging:
							print("Applied alpha testing (GE128) for material %s" % sh_name)
			if sh_data.has("surfaceparms") and "trans" in sh_data.surfaceparms:
				mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
				mat.alpha_scissor_threshold = 0.5
				if debug_logging:
					print("Enabled transparency for material %s due to surfaceparm trans" % sh_name)
			if sh_data.has("cull") and sh_data.cull == "none":
				mat.cull_mode = BaseMaterial3D.CULL_DISABLED
				if debug_logging:
					print("Disabled culling for material %s" % sh_name)
		
		materials[sh_name] = mat
	
	return materials

func get_non_solid_shaders() -> Array[String]:
	return non_solid_shaders

static func escape_regex(s: String) -> String:
	var special_chars = ".^$*+?()[]{}|"
	var escaped = ""
	for c in s:
		if special_chars.contains(c):
			escaped += "\\" + c
		else:
			escaped += c
	return escaped
```

./bsp_loader.gd:
```
class_name BSPLoader
extends BSPCommon

var scale_factor: float = 0.0254
var lightmap_path: String = ""
var player_model_path: String = ""
var patch_tessellation_level: int = 8
var debug_logging: bool = true
var shader_uv_scales: Dictionary = {
	"exx/base-crete01red": Vector2(0.25, 0.25),
	"exx/base-crete01": Vector2(0.25, 0.25),
	"exx/base-crete01blue": Vector2(0.25, 0.25),
	"exx/floor-clang01b": Vector2(0.5, 0.5),
	"exx/floor-crete01": Vector2(0.5, 0.5),
	"exx/panel-grate01-cull": Vector2(1.0, 1.0),
	"exx/base-metal01": Vector2(1.0, 1.0),
	"base/mgrate": Vector2(1.0, 1.0)
}

signal progress_updated(stage: String, pct: float)

func _get_import_options(path: String, preset: int) -> Array[Dictionary]:
        return [
                {
                        "name": "patch_tessellation_level",
                        "default_value": 8,
                        "type": TYPE_INT,
                        "property_hint": PROPERTY_HINT_ENUM,
                        "hint_string": "2,4,8,16"
                }
        ]

func load_bsp(path: String) -> Node3D:
	emit_signal("progress_updated", "Opening file", 0.0)
	
	var f: FileAccess = FileAccess.open(path, FileAccess.READ)
	if not f:
		push_error("Cannot open BSP: ", path)
		return null
	
	# Header
	var ident: String = f.get_buffer(4).get_string_from_ascii()
	var ver: int = f.get_32()
	if ident != "IBSP" or ver != BSP_VERSION_QUAKE3:
		push_error("Unsupported BSP (%s v%d)" % [ident, ver])
		return null
	
	# Lumps
	var lumps: Array[Dictionary] = []
	for i in range(EXPECTED_LUMP_COUNT):
		lumps.append({"offset": f.get_32(), "length": f.get_32()})
	
	# Entities
	emit_signal("progress_updated", "Entities", 10.0)
	f.seek(lumps[LUMP_ENTITIES].offset)
	var entity_data: String = read_null_terminated_string(f, lumps[LUMP_ENTITIES].length)
	var entities: Array[Dictionary] = parse_entities(entity_data)
	if entities.is_empty():
		print("Warning: No entities parsed from BSP. Raw data: ", entity_data.substr(0, 200))
	
	# Shaders
	emit_signal("progress_updated", "Shaders", 20.0)
	f.seek(lumps[LUMP_SHADERS].offset)
	var n_shaders: int = lumps[LUMP_SHADERS].length / 72
	var shaders: Array[Dictionary] = []
	for i in range(n_shaders):
		var raw_bytes = f.get_buffer(64)
		var raw = ""
		for b in raw_bytes:
			if b == 0:
				break
			if b >= 32 and b <= 126:
				raw += char(b)
		f.get_32() # sflags
		f.get_32() # cflags
		if raw.strip_edges() != "":
			var shader_name = raw.replace("textures/", "").strip_edges()
			shaders.append({
				"name": shader_name,
				"sflags": 0,
				"cflags": 0
			})
		else:
			print("Skipping empty/invalid shader at index ", i)
	
	# Planes
	emit_signal("progress_updated", "Planes", 30.0)
	f.seek(lumps[LUMP_PLANES].offset)
	var n_planes: int = lumps[LUMP_PLANES].length / 16
	var planes: Array[Dictionary] = []
	for i in range(n_planes):
		planes.append({
			"normal": transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float())),
			"dist": f.get_float() * scale_factor
		})
	
	# Vertices
	emit_signal("progress_updated", "Vertices", 40.0)
	f.seek(lumps[LUMP_VERTICES].offset)
	var n_verts: int = lumps[LUMP_VERTICES].length / 44
	var verts: Array[Dictionary] = []
	for i in range(n_verts):
		var pos = transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float()))
		var uv_x = f.get_float()
		var uv_y = f.get_float()
		# Sanitize UVs to prevent overflow
		if not is_finite(uv_x) or abs(uv_x) > 1000.0:
			if debug_logging:
				print("Invalid uv_x for vertex %d: %s, clamping to 0.0" % [i, uv_x])
			uv_x = 0.0
		if not is_finite(uv_y) or abs(uv_y) > 1000.0:
			if debug_logging:
				print("Invalid uv_y for vertex %d: %s, clamping to 0.0" % [i, uv_y])
			uv_y = 0.0
		var luv_x = f.get_float()
		var luv_y = f.get_float()
		var normal = transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float()))
		verts.append({
			"pos": pos * scale_factor,
			"uv": Vector2(uv_x, uv_y),
			"luv": Vector2(luv_x, luv_y),
			"normal": normal,
			"color": Color(f.get_8()/255.0, f.get_8()/255.0, f.get_8()/255.0, f.get_8()/255.0)
		})
	
	# Meshverts
	emit_signal("progress_updated", "MeshVerts", 50.0)
	f.seek(lumps[LUMP_MESHVERTS].offset)
	var n_mv: int = lumps[LUMP_MESHVERTS].length / 4
	var meshverts: PackedInt32Array = PackedInt32Array()
	meshverts.resize(n_mv)
	for i in range(n_mv):
		meshverts[i] = f.get_32()
	
	# Brushes
	emit_signal("progress_updated", "Brushes", 55.0)
	f.seek(lumps[LUMP_BRUSHES].offset)
	var n_brushes: int = lumps[LUMP_BRUSHES].length / 12
	var brushes: Array[Dictionary] = []
	for i in range(n_brushes):
		brushes.append({
			"first_side": f.get_32(),
			"num_sides": f.get_32(),
			"shader_num": f.get_32()
		})
	
	# Brushsides
	f.seek(lumps[LUMP_BRUSHSIDES].offset)
	var n_brushsides: int = lumps[LUMP_BRUSHSIDES].length / 8
	var brushsides: Array[Dictionary] = []
	for i in range(n_brushsides):
		brushsides.append({
			"plane_num": f.get_32(),
			"shader_num": f.get_32()
		})
	
	# Models
	f.seek(lumps[LUMP_MODELS].offset)
	var n_models: int = lumps[LUMP_MODELS].length / 40
	var models: Array[Dictionary] = []
	for i in range(n_models):
		var mins = transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float())) * scale_factor
		var maxs = transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float())) * scale_factor
		models.append({
			"mins": mins,
			"maxs": maxs,
			"first_face": f.get_32(),
			"num_faces": f.get_32(),
			"first_brush": f.get_32(),
			"num_brushes": f.get_32()
		})
	
	# Faces
	emit_signal("progress_updated", "Faces", 60.0)
	f.seek(lumps[LUMP_SURFACES].offset)
	const FACE_BYTES: int = 104
	var n_faces: int = lumps[LUMP_SURFACES].length / FACE_BYTES
	var faces: Array[Dictionary] = []
	for i in range(n_faces):
		var face: Dictionary = {
			"shader_num": f.get_32(),
			"effect_num": f.get_32(),
			"surface_type": f.get_32(),
			"first_vert": f.get_32(),
			"num_verts": f.get_32(),
			"first_mv": f.get_32(),
			"num_mv": f.get_32(),
			"lm_index": f.get_32()
		}
		f.get_32(); f.get_32(); f.get_32(); f.get_32() # lm x,y,w,h
		face.lm_origin = transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float())) * scale_factor
		f.get_float(); f.get_float(); f.get_float() # lm_vec_s
		f.get_float(); f.get_float(); f.get_float() # lm_vec_t
		face.normal = transform_vector(Vector3(f.get_float(), f.get_float(), f.get_float()))
		face.size_u = f.get_32()
		face.size_v = f.get_32()
		faces.append(face)
	
	# Build Scene
	emit_signal("progress_updated", "Build scene", 80.0)
	
	var root := Node3D.new()
	root.name = path.get_file().get_basename()
	root.set_script(load("res://addons/bsp_loader/scripts/root_gizmo.gd"))
	
	# Load textures and materials
	var texture_loader = BSPTextureLoader.new()
	var texture_cache = texture_loader.load_textures(shaders, faces)
	var materials = texture_loader.create_materials(shaders, texture_cache)
	var non_solid_shaders = texture_loader.get_non_solid_shaders()
	var lightmap_textures: Dictionary = {}
	for i in range(100):
		var lm_path = lightmap_path + "lm_%04d.jpg" % i
		if FileAccess.file_exists(lm_path):
			lightmap_textures[i] = load(lm_path)
	
	# Entity Processing
	if debug_logging:
		print("Processing %d entities..." % entities.size())
	for ent_idx in range(entities.size()):
		var ent = entities[ent_idx]
		var classname = ent.get("classname", "unknown")
		var node_name = "%d-%s" % [ent_idx, classname]
		var model_idx = ent.get("model", "").replace("*", "").to_int() if ent.has("model") else -1
		var has_geometry = (classname == "worldspawn" or (classname in COLLIDABLE_FUNC_ENTITIES and model_idx >= 0 and model_idx < models.size()))
		
		var node: Node
		if classname == "worldspawn":
			node = StaticBody3D.new()
			node.collision_layer = 1
			node.collision_mask = 0
		elif classname in TRIGGER_ENTITIES or classname in GOAL_ENTITIES:
			node = Area3D.new()
			node.collision_layer = 2
			node.collision_mask = 1
		elif classname in COLLIDABLE_FUNC_ENTITIES:
			node = StaticBody3D.new()
			node.collision_layer = 3
			node.collision_mask = 0
		elif classname in ITEM_ENTITIES or classname in WEAPON_ENTITIES:
			node = StaticBody3D.new()
			node.collision_layer = 4
			node.collision_mask = 1
		elif classname.begins_with("info_player"):
			node = StaticBody3D.new()
			node.collision_layer = 0
			node.collision_mask = 1
		elif classname == "light" or classname == "lightJunior":
			node = OmniLight3D.new()
			node.light_energy = ent.get("light", "300").to_float() / 300.0
			if ent.has("_color") or ent.has("color"):
				var col = parse_vector3(ent.get("_color", ent.get("color", "1 1 1")))
				node.light_color = Color(col.x, col.y, col.z)
		else:
			node = Node3D.new()
		
		node.name = node_name
		if ent.has("origin") and not (classname in TRIGGER_ENTITIES or classname in GOAL_ENTITIES):
			var origin = parse_vector3(ent.origin)
			node.position = transform_vector(origin) * scale_factor
		if ent.has("angles") and not (classname in TRIGGER_ENTITIES or classname in GOAL_ENTITIES):
			var angles = parse_vector3(ent.angles)
			node.rotation_degrees = transform_vector(angles)
		
		node.set_meta("bsp_properties", ent)
		root.add_child(node)
		node.owner = root
		if debug_logging:
			print("Added node: ", node_name)
		
		if classname in COLLIDABLE_FUNC_ENTITIES:
			var area = Area3D.new()
			area.name = "InteractionArea"
			area.collision_layer = 2
			area.collision_mask = 1
			node.add_child(area)
			area.owner = root
		
		# Add collision and geometry
		var is_collidable = true
		if has_geometry:
			if debug_logging:
				print("Processing geometry for entity: ", node_name)
			var model = models[model_idx] if model_idx >= 0 and model_idx < models.size() else models[0]
			if classname in COLLIDABLE_FUNC_ENTITIES:
				is_collidable = is_brush_collidable(model, brushes, brushsides, shaders)
			var ent_mesh = ArrayMesh.new()
			var ent_by_mat: Dictionary = {}
                        var col_vertices: PackedVector3Array = []
			for face_idx in range(model.first_face, model.first_face + model.num_faces):
				var face = faces[face_idx]
				if face.surface_type not in [MST_PLANAR, MST_TRIANGLE_SOUP, MST_PATCH]:
					continue
				var sh_name = shaders[face.shader_num].name if face.shader_num >= 0 and face.shader_num < shaders.size() else ""
				if sh_name in NON_RENDER_SHADERS and sh_name != "common/invisible":
					continue
				if not ent_by_mat.has(sh_name):
					ent_by_mat[sh_name] = {
						"v": PackedVector3Array(),
						"n": PackedVector3Array(),
						"uv": PackedVector2Array(),
						"luv": PackedVector2Array(),
						"color": PackedColorArray(),
						"id": PackedInt32Array(),
						"lm_index": face.lm_index
					}
				var mat_data = ent_by_mat[sh_name]
				var v_ofs = mat_data.v.size()
				if face.surface_type == MST_PATCH:
					var w: int = face.size_u
					var h: int = face.size_v
					if w < 2 or h < 2 or face.num_verts != w * h:
						if debug_logging:
							print("Invalid patch dimensions for face %d: w=%d, h=%d, num_verts=%d" % [face_idx, w, h, face.num_verts])
						continue
					# Validate control point UVs
					var valid_patch = true
					for j in range(h):
						for i in range(w):
							var idx = face.first_vert + j * w + i
							if idx >= 0 and idx < verts.size():
								var vert = verts[idx]
								if not vert.uv.is_finite() or abs(vert.uv.x) > 1000.0 or abs(vert.uv.y) > 1000.0:
									if debug_logging:
										print("Invalid UV for control point face %d [%d,%d]: uv=%s, skipping patch" % [face_idx, i, j, vert.uv])
									valid_patch = false
									break
						if not valid_patch:
							break
					if not valid_patch:
						if debug_logging:
							print("Skipping patch face %d due to invalid UVs" % face_idx)
						continue
					var tess: int = patch_tessellation_level
					# Temporary arrays for patch data
					var patch_vertices = PackedVector3Array()
					var patch_normals = PackedVector3Array()
					var patch_uvs = PackedVector2Array()
					var patch_luvs = PackedVector2Array()
					var patch_colors = PackedColorArray()
					var patch_indices = PackedInt32Array()
					# Timeout to prevent hangs
					var start_time = Time.get_ticks_msec()
					var timeout_ms = 5000
					var vertex_count = 0
					for vy in range(tess + 1):
						for vx in range(tess + 1):
							# Check for timeout
							if Time.get_ticks_msec() - start_time > timeout_ms:
								if debug_logging:
									print("Timeout processing patch face %d at vx=%d, vy=%d, aborting" % [face_idx, vx, vy])
								valid_patch = false
								break
							var u: float = vx / float(tess)
							var v: float = vy / float(tess)
							var pos := Vector3()
							var nor := Vector3()
							var uv := Vector2()
							var luv := Vector2()
							var col := Color()
							var sum: float = 0.0
							# Partial derivatives for normal
							var du_pos := Vector3()
							var dv_pos := Vector3()
							var du_sum: float = 0.0
							var dv_sum: float = 0.0
							for j in range(h):
								for i in range(w):
									var idx: int = face.first_vert + j * w + i
									if idx < 0 or idx >= verts.size():
										if debug_logging:
											push_error("Invalid vertex index %d for patch face %d (Max: %d)" % [idx, face_idx, verts.size() - 1])
										continue
									var wgt: float = BezierMesh.bernstein(u, i, w - 1) * BezierMesh.bernstein(v, j, h - 1)
									var du_wgt: float = BezierMesh.bernstein(u, i, w - 1) * BezierMesh.bernstein(v, j, h - 1)
									var dv_wgt: float = BezierMesh.bernstein(u, i, w - 1) * BezierMesh.bernstein(v, j, h - 1)
									if i < w - 1:
										du_wgt *= float(w - 1) * (BezierMesh.bernstein(u, i + 1, w - 2) - BezierMesh.bernstein(u, i, w - 2)) if w > 2 else 0.0
									else:
										du_wgt = 0.0
									if j < h - 1:
										dv_wgt *= float(h - 1) * (BezierMesh.bernstein(v, j + 1, h - 2) - BezierMesh.bernstein(v, j, h - 2)) if h > 2 else 0.0
									else:
										dv_wgt = 0.0
									var vert = verts[idx]
									pos += vert.pos * wgt
									uv += vert.uv * wgt
									luv += vert.luv * wgt
									col += vert.color * wgt
									du_pos += vert.pos * du_wgt
									dv_pos += vert.pos * dv_wgt
									sum += wgt
									du_sum += du_wgt
									dv_sum += dv_wgt
							if sum > 0.0001:
								pos /= sum
								uv /= sum
								luv /= sum
								col /= sum
								du_pos /= sum
								dv_pos /= sum
								# Apply shader-specific UV scaling
								var uv_scale = shader_uv_scales.get(sh_name, Vector2(1.0, 1.0))
								uv = Vector2(uv.x * uv_scale.x, uv.y * uv_scale.y)
								luv = luv / Vector2(128, 128)
								# Validate UVs
								if not uv.is_finite() or abs(uv.x) > 1000.0 or abs(uv.y) > 1000.0:
									if debug_logging:
										print("Invalid computed UV for face %d at vx=%d, vy=%d: uv=%s, skipping vertex" % [face_idx, vx, vy, uv])
									continue
								# Calculate normal
								nor = du_pos.cross(dv_pos).normalized()
								if nor.is_zero_approx() or not nor.is_finite():
									nor = face.normal
							else:
								nor = face.normal
								if debug_logging:
									print("Near-zero sum for face %d at vx=%d, vy=%d: sum=%f" % [face_idx, vx, vy, sum])
							# Validate data
							if not pos.is_finite() or not nor.is_finite() or not uv.is_finite() or not luv.is_finite():
								if debug_logging:
									print("Invalid data for face %d at vx=%d, vy=%d: pos=%s, nor=%s, uv=%s, luv=%s" % [face_idx, vx, vy, pos, nor, uv, luv])
								continue
							patch_vertices.append(pos)
							patch_normals.append(nor)
							patch_uvs.append(uv)
							patch_luvs.append(luv)
							patch_colors.append(col)
							vertex_count += 1
						if not valid_patch:
							break
					if not valid_patch:
						if debug_logging:
							print("Aborted patch face %d due to timeout or invalid data" % face_idx)
						continue
					# Generate CCW indices
					var triangle_count = 0
					for tess_vy in range(tess):
						for tess_vx in range(tess):
							var b: int = tess_vy * (tess + 1) + tess_vx
							var idx00 = b
							var idx10 = b + 1
							var idx01 = b + tess + 1
							var idx11 = b + tess + 2
							if idx11 >= patch_vertices.size():
								if debug_logging:
									print("Invalid index for face %d at vx=%d, vy=%d: idx11=%d, vertices=%d" % [face_idx, tess_vx, tess_vy, idx11, patch_vertices.size()])
								continue
							var v00 = patch_vertices[idx00]
							var v10 = patch_vertices[idx10]
							var v01 = patch_vertices[idx01]
							var v11 = patch_vertices[idx11]
							var area1 = (v10 - v00).cross(v01 - v00).length()
							var area2 = (v01 - v10).cross(v11 - v10).length()
							if area1 < 0.0001 or area2 < 0.0001:
								if debug_logging:
									print("Degenerate triangle for face %d at vx=%d, vy=%d: area1=%f, area2=%f" % [face_idx, tess_vx, tess_vy, area1, area2])
								continue
							# Add indices with v_ofs
							patch_indices.append_array([
								v_ofs + idx00, v_ofs + idx01, v_ofs + idx10,
								v_ofs + idx10, v_ofs + idx01, v_ofs + idx11
							])
							triangle_count += 2
					# Append to material data
					mat_data.v.append_array(patch_vertices)
					mat_data.n.append_array(patch_normals)
					mat_data.uv.append_array(patch_uvs)
					mat_data.luv.append_array(patch_luvs)
					mat_data.color.append_array(patch_colors)
					mat_data.id.append_array(patch_indices)
                                        if debug_logging:
                                                print("Processed patch face %d: w=%d, h=%d, vertices=%d, triangles=%d" % [face_idx, w, h, patch_vertices.size(), triangle_count])
                                        if sh_name not in non_solid_shaders:
                                                for idx in patch_indices:
                                                        col_vertices.append(mat_data.v[idx])
                                else:
                                        # Non-patch faces
                                        var normal = face.normal
                                        var up_vector = Vector3.UP
					if abs(normal.dot(Vector3.UP)) > 0.99:
						up_vector = Vector3.FORWARD
					var tangent = normal.cross(up_vector).normalized()
					var binormal = normal.cross(tangent).normalized()
					for i_idx in range(0, face.num_mv, 3):
						var a_idx = meshverts[face.first_mv + i_idx]
						var b_idx = meshverts[face.first_mv + i_idx + 1]
						var c_idx = meshverts[face.first_mv + i_idx + 2]
						var vertex_indices = [a_idx, b_idx, c_idx]
						for mv_idx in vertex_indices:
							if mv_idx < 0 or mv_idx >= face.num_verts:
								continue
							var v_idx = face.first_vert + mv_idx
							if v_idx >= verts.size():
								if debug_logging:
									print("Invalid vertex index %d for face %d" % [v_idx, face_idx])
								continue
							var vert = verts[v_idx]
							mat_data.id.append(mat_data.v.size())
							mat_data.v.append(vert.pos)
							mat_data.n.append(vert.normal)
							var uv_scale = shader_uv_scales.get(sh_name, Vector2(1.0, 1.0))
							var scaled_uv = Vector2(vert.uv.x * uv_scale.x, vert.uv.y * uv_scale.y)
							if not scaled_uv.is_finite() or abs(scaled_uv.x) > 1000.0 or abs(scaled_uv.y) > 1000.0:
								if debug_logging:
									print("Invalid scaled UV for face %d, vertex %d: uv=%s, using (0,0)" % [face_idx, v_idx, scaled_uv])
								scaled_uv = Vector2(0.0, 0.0)
							if sh_name in ["map_boil/frogg", "map_boil/brush", "map_boil/credit"]:
								scaled_uv = Vector2(-scaled_uv.x, scaled_uv.y) # Flip U for graffiti
							mat_data.uv.append(scaled_uv)
							mat_data.luv.append(vert.luv / Vector2(128, 128))
							mat_data.color.append(vert.color)
							if sh_name not in non_solid_shaders:
								col_vertices.append(vert.pos)
			var surface_idx = 0
			for sh_name in ent_by_mat.keys():
				var data = ent_by_mat[sh_name]
				if data.v.is_empty() or data.id.is_empty():
					continue
				var arr = []
				arr.resize(Mesh.ARRAY_MAX)
				arr[Mesh.ARRAY_VERTEX] = data.v
				arr[Mesh.ARRAY_NORMAL] = data.n
				arr[Mesh.ARRAY_TEX_UV] = data.uv
				arr[Mesh.ARRAY_TEX_UV2] = data.luv
				arr[Mesh.ARRAY_COLOR] = data.color
				arr[Mesh.ARRAY_INDEX] = data.id
				ent_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arr)
				ent_mesh.surface_set_name(surface_idx, sh_name)
				if materials.has(sh_name):
					var mat = materials[sh_name]
					if data.lm_index >= 0 and lightmap_textures.has(data.lm_index):
						var lm_mat = mat.duplicate()
						lm_mat.set_texture(BaseMaterial3D.TEXTURE_ALBEDO, lightmap_textures[data.lm_index])
						lm_mat.ao_enabled = true
						lm_mat.uv2_scale = Vector3(1.0, 1.0, 1.0)
						ent_mesh.surface_set_material(surface_idx, lm_mat)
					else:
						ent_mesh.surface_set_material(surface_idx, mat)
					if debug_logging:
						print("Applied material %s to surface %d with name %s" % [sh_name, surface_idx, sh_name])
				else:
					if debug_logging:
						print("No material found for shader %s, using fallback" % sh_name)
					var fallback_mat = StandardMaterial3D.new()
					fallback_mat.albedo_color = Color(0.5, 0.5, 0.5)
					fallback_mat.metallic = 0.0
					fallback_mat.roughness = 1.0
					fallback_mat.anisotropy_enabled = false
					fallback_mat.texture_filter = BaseMaterial3D.TEXTURE_FILTER_NEAREST
					ent_mesh.surface_set_material(surface_idx, fallback_mat)
					ent_mesh.surface_set_name(surface_idx, sh_name + "_missing")
				surface_idx += 1
			if ent_mesh.get_surface_count() > 0:
				var ent_mi = MeshInstance3D.new()
				ent_mi.mesh = ent_mesh
				ent_mi.name = "Geometry"
				node.add_child(ent_mi)
				ent_mi.owner = root
				if debug_logging:
					print("Added geometry for entity: %s with %d surfaces" % [node_name, ent_mesh.get_surface_count()])
				if not col_vertices.is_empty() and (classname == "worldspawn" or is_collidable):
					if debug_logging:
						print("Creating collision for entity: ", node_name)
					var col_shape = CollisionShape3D.new()
					var concave_shape = ConcavePolygonShape3D.new()
					var faces_array = []
					for i in range(0, col_vertices.size() - 2, 3):
						var v0 = col_vertices[i]
						var v1 = col_vertices[i + 1]
						var v2 = col_vertices[i + 2]
						if v0.distance_to(v1) > 0.001 and v1.distance_to(v2) > 0.001 and v2.distance_to(v0) > 0.001:
							faces_array.append(v0)
							faces_array.append(v1)
							faces_array.append(v2)
					if faces_array.size() > 0 and faces_array.size() % 3 == 0:
						concave_shape.set_faces(faces_array)
						col_shape.shape = concave_shape
						col_shape.name = "Collision"
						node.add_child(col_shape)
						col_shape.owner = root
						if debug_logging:
							print("Collision vertices: %d for entity: %s" % [faces_array.size(), node_name])
					else:
						if debug_logging:
							print("Invalid collision vertices (%d, mod 3 = %d) for entity: %s" % [faces_array.size(), faces_array.size() % 3, node_name])
				else:
					if debug_logging:
						print("No collision vertices or non-collidable entity: %s" % node_name)
			else:
				if debug_logging:
					print("No geometry generated for entity: %s" % node_name)
		
		if classname in ITEM_ENTITIES or classname in WEAPON_ENTITIES:
			var col_shape = CollisionShape3D.new()
			col_shape.name = "Collision"
			col_shape.shape = BoxShape3D.new()
			col_shape.shape.extents = Vector3(0.25, 0.25, 0.25)
			node.add_child(col_shape)
			col_shape.owner = root
			if debug_logging:
				print("Added collision for item/weapon: %s" % node_name)
		
		if classname.begins_with("info_player"):
			if player_model_path and FileAccess.file_exists(player_model_path):
				var model = load(player_model_path)
				var model_instance = MeshInstance3D.new()
				model_instance.mesh = model
				model_instance.scale = Vector3(scale_factor, scale_factor, scale_factor)
				node.add_child(model_instance)
				model_instance.owner = root
			var col_shape = CollisionShape3D.new()
			col_shape.name = "Collision"
			col_shape.shape = BoxShape3D.new()
			col_shape.shape.extents = Vector3(0.25, 1.0, 0.25)
			node.add_child(col_shape)
			col_shape.owner = root
			if debug_logging:
				print("Added collision for info_player: %s" % node_name)
		
		if classname in TRIGGER_ENTITIES or classname in GOAL_ENTITIES:
			var model = models[model_idx] if model_idx >= 0 and model_idx < models.size() else null
			if model:
				var center = (model.mins + model.maxs) / 2.0
				node.position = center
				var faces_array = extract_brush_vertices(model, brushes, brushsides, planes, shaders)
				if faces_array.size() > 0 and faces_array.size() % 3 == 0:
					# Make local
					var local_faces = PackedVector3Array()
					for v in faces_array:
						local_faces.append(v - center)
					# Apply rotation if present
					if ent.has("angles"):
						var angles = parse_vector3(ent.angles)
						var transform = Transform3D.IDENTITY
						transform = transform.rotated(Vector3.RIGHT, deg_to_rad(angles.x))
						transform = transform.rotated(Vector3.UP, deg_to_rad(angles.y))
						transform = transform.rotated(Vector3.FORWARD, deg_to_rad(angles.z))
						var rotated_faces = PackedVector3Array()
						for v in local_faces:
							rotated_faces.append(transform.basis * v)
						local_faces = rotated_faces
					# Create collision shape
					var col_shape = CollisionShape3D.new()
					var concave_shape = ConcavePolygonShape3D.new()
					concave_shape.set_faces(local_faces)
					col_shape.shape = concave_shape
					col_shape.name = "TriggerShape"
					col_shape.position = Vector3.ZERO
					node.add_child(col_shape)
					col_shape.owner = root
					# Create debug mesh
					var debug_mesh = MeshInstance3D.new()
					var debug_array_mesh = ArrayMesh.new()
					var arr = []
					arr.resize(Mesh.ARRAY_MAX)
					arr[Mesh.ARRAY_VERTEX] = local_faces
					debug_array_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arr)
					var debug_mat = StandardMaterial3D.new()
					debug_mat.albedo_color = Color(1, 0, 0, 0.5)
					debug_mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
					debug_array_mesh.surface_set_material(0, debug_mat)
					debug_mesh.mesh = debug_array_mesh
					debug_mesh.name = "DebugTriggerMesh"
					debug_mesh.position = Vector3.ZERO
					node.add_child(debug_mesh)
					debug_mesh.owner = root
					# Update AABB
					var aabb = AABB()
					for v in local_faces:
						aabb = aabb.expand(v)
					debug_array_mesh.custom_aabb = aabb
					if debug_logging:
						print("Added trigger shape for entity: %s with %d vertices, center: %s" % [node_name, faces_array.size(), center])
				else:
					if debug_logging:
						print("Failed to generate trigger vertices (%d, mod 3 = %d) for entity: %s, falling back to bounding box" % [faces_array.size(), faces_array.size() % 3, node_name])
					# Fallback to bounding box
					var col_shape = CollisionShape3D.new()
					var box_shape = BoxShape3D.new()
					var extents = (model.maxs - model.mins) / 2.0
					box_shape.extents = extents
					col_shape.shape = box_shape
					col_shape.name = "TriggerShape"
					col_shape.position = Vector3.ZERO
					node.add_child(col_shape)
					col_shape.owner = root
					# Debug mesh for bounding box
					var debug_mesh = MeshInstance3D.new()
					var debug_array_mesh = ArrayMesh.new()
					var cube_mesh = BoxMesh.new()
					cube_mesh.size = extents * 2.0
					debug_array_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, cube_mesh.get_mesh_arrays())
					var debug_mat = StandardMaterial3D.new()
					debug_mat.albedo_color = Color(1, 0, 0, 0.5)
					debug_mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
					debug_array_mesh.surface_set_material(0, debug_mat)
					debug_mesh.mesh = debug_array_mesh
					debug_mesh.name = "DebugTriggerMesh"
					debug_mesh.position = Vector3.ZERO
					node.add_child(debug_mesh)
					debug_mesh.owner = root
					if debug_logging:
						print("Added fallback box trigger shape for entity: %s, extents: %s" % [node_name, extents])
			else:
				if debug_logging:
					print("No model found for trigger entity: %s" % node_name)
		
		if classname in COLLIDABLE_FUNC_ENTITIES and is_collidable:
			var model = models[model_idx] if model_idx >= 0 and model_idx < models.size() else null
			if model:
				var area = node.get_node("InteractionArea")
				if area:
					var col_shape = CollisionShape3D.new()
					col_shape.name = "InteractionShape"
					var concave_shape = ConcavePolygonShape3D.new()
					var faces_array = extract_brush_vertices(model, brushes, brushsides, planes, shaders)
					if faces_array.size() > 0 and faces_array.size() % 3 == 0:
						concave_shape.set_faces(faces_array)
						col_shape.shape = concave_shape
						col_shape.position = (model.mins + model.maxs) / 2.0
						area.add_child(col_shape)
						col_shape.owner = root
						if debug_logging:
							print("Added interaction shape for func entity: %s with %d vertices" % [node_name, faces_array.size()])
			node.set_script(load("res://addons/bsp_loader/scripts/func_entity.gd"))
		
		if classname in TRIGGER_ENTITIES:
			node.set_script(load("res://addons/bsp_loader/scripts/trigger_entity.gd"))
	
	emit_signal("progress_updated", "Done", 100.0)
	if debug_logging:
		print("Faces:%d  Surfaces:%d  Entities:%d" % [faces.size(), root.get_child_count(), entities.size()])
	return root

func transform_vector(v: Vector3) -> Vector3:
	return Vector3(v.x, v.z, -v.y)

func read_null_terminated_string(file: FileAccess, max_length: int) -> String:
	var bytes: PackedByteArray = []
	var count: int = 0
	while count < max_length:
		var byte = file.get_8()
		if byte == 0:
			break
		bytes.append(byte)
		count += 1
	return bytes.get_string_from_utf8()

func parse_entities(data: String) -> Array[Dictionary]:
	var entities: Array[Dictionary] = []
	var current: Dictionary = {}
	var in_entity := false
	var key: String = ""
	var value: String = ""
	var parsing_key := true
	var in_quotes := false
	var i: int = 0
	
	while i < data.length():
		var c = data[i]
		
		if c == "{" and not in_quotes:
			current = {}
			in_entity = true
			parsing_key = true
			key = ""
			value = ""
			i += 1
			continue
		
		if c == "}" and not in_quotes:
			if in_entity:
				if key != "":
					current[key] = value.strip_edges()
				if not current.is_empty():
					entities.append(current)
			current = {}
			in_entity = false
			parsing_key = true
			key = ""
			value = ""
			i += 1
			continue
		
		if c == "\"" and in_entity:
			in_quotes = not in_quotes
			if not in_quotes and parsing_key:
				parsing_key = false
			elif not in_quotes and not parsing_key:
				current[key] = value.strip_edges()
				key = ""
				value = ""
				parsing_key = true
			i += 1
			continue
		
		if in_entity and in_quotes:
			if parsing_key:
				key += c
			else:
				value += c
			i += 1
			continue
		
		i += 1
	
	if in_entity and not current.is_empty():
		if key != "":
			current[key] = value.strip_edges()
		entities.append(current)
	
	if entities.is_empty():
		if debug_logging:
			print("Entity parsing failed. Raw data: ", data.substr(0, 200), "...")
	else:
		if debug_logging:
			print("Parsed %d entities" % entities.size())
	
	return entities

func parse_vector3(s: String) -> Vector3:
	var parts = s.split(" ", false)
	if parts.size() >= 3:
		return Vector3(float(parts[0]), float(parts[1]), float(parts[2]))
	return Vector3()

func is_brush_collidable(model: Dictionary, brushes: Array[Dictionary], brushsides: Array[Dictionary], shaders: Array[Dictionary]) -> bool:
	var solid_count = 0
	var total_sides = 0
	for brush_idx in range(model.first_brush, model.first_brush + model.num_brushes):
		var brush = brushes[brush_idx]
		for side_idx in range(brush.first_side, brush.first_side + brush.num_sides):
			var side = brushsides[side_idx]
			var shader_num = side.shader_num
			if shader_num >= 0 and shader_num < shaders.size():
				var shader_name = shaders[shader_num].name
				if shader_name in SOLID_SHADERS:
					solid_count += 1
				elif shader_name in NON_RENDER_SHADERS and shader_name != "common/invisible":
					solid_count -= 1
			total_sides += 1
	if debug_logging:
		print("Brush collidability: solid_count=%d, total_sides=%d" % [solid_count, total_sides])
	return solid_count > total_sides / 2

func extract_brush_vertices(model: Dictionary, brushes: Array[Dictionary], brushsides: Array[Dictionary], planes: Array[Dictionary], shaders: Array[Dictionary]) -> PackedVector3Array:
	var vertices: PackedVector3Array = []
	for brush_idx in range(model.first_brush, model.first_brush + model.num_brushes):
		if brush_idx < 0 or brush_idx >= brushes.size():
			if debug_logging:
				print("Invalid brush index %d for model, range %d-%d" % [brush_idx, model.first_brush, model.first_brush + model.num_brushes])
			continue
		var brush = brushes[brush_idx]
		var brush_planes: Array[Dictionary] = []
		var is_valid_brush = true
		for side_idx in range(brush.first_side, brush.first_side + brush.num_sides):
			if side_idx < 0 or side_idx >= brushsides.size():
				if debug_logging:
					print("Invalid brushside index %d for brush %d" % [side_idx, brush_idx])
				is_valid_brush = false
				break
			var side = brushsides[side_idx]
			if side.plane_num < 0 or side.plane_num >= planes.size():
				if debug_logging:
					print("Invalid plane_num %d for brush %d, side %d" % [side.plane_num, brush_idx, side_idx])
				is_valid_brush = false
				break
			brush_planes.append(planes[side.plane_num])
		if not is_valid_brush:
			if debug_logging:
				print("Skipping invalid brush %d: valid=%s, planes=%d" % [brush_idx, is_valid_brush, brush_planes.size()])
			continue
		if brush_planes.size() < 4:
			if debug_logging:
				print("Skipping brush %d with insufficient planes: %d" % [brush_idx, brush_planes.size()])
			continue
		var brush_vertices = intersect_planes(brush_planes)
		if brush_vertices.size() == 0:
			if debug_logging:
				print("No vertices for brush %d, planes: %s" % [brush_idx, brush_planes])
			continue
		var hull_vertices = convex_hull(brush_vertices, model.mins, model.maxs)
		for i in range(0, hull_vertices.size() - 2, 3):
			var v0 = hull_vertices[i]
			var v1 = hull_vertices[i + 1]
			var v2 = hull_vertices[i + 2]
			if v0.distance_to(v1) > 0.001 and v1.distance_to(v2) > 0.001 and v2.distance_to(v0) > 0.001:
				vertices.append(v0)
				vertices.append(v1)
				vertices.append(v2)
	if vertices.size() == 0:
		if debug_logging:
			print("No valid vertices for model, brushes %d-%d" % [model.first_brush, model.first_brush + model.num_brushes])
	elif vertices.size() % 3 != 0:
		if debug_logging:
			print("Invalid vertex count (%d) for brush, adjusting to multiple of 3" % vertices.size())
		var new_size = (vertices.size() / 3) * 3
		var new_vertices = PackedVector3Array()
		for i in range(new_size):
			new_vertices.append(vertices[i])
		vertices = new_vertices
	return vertices

func intersect_planes(brush_planes: Array[Dictionary]) -> PackedVector3Array:
	var vertices: PackedVector3Array = []
	var max_vertices: int = 1000
	var vertex_count: int = 0
	
	for i in range(brush_planes.size()):
		for j in range(i + 1, brush_planes.size()):
			for k in range(j + 1, brush_planes.size()):
				var p1 = brush_planes[i]
				var p2 = brush_planes[j]
				var p3 = brush_planes[k]
				var n1 = p1.normal
				var n2 = p2.normal
				var n3 = p3.normal
				var d1 = p1.dist
				var d2 = p2.dist
				var d3 = p3.dist
				
				var denom = n1.dot(n2.cross(n3))
				if abs(denom) < 0.0001:
					continue
				
				var v = (
					d1 * (n2.cross(n3)) +
					d2 * (n3.cross(n1)) +
					d3 * (n1.cross(n2))
				) / denom
				
				var valid = true
				for p in brush_planes:
					if p1 == p or p2 == p or p3 == p:
						continue
					var dist = p.normal.dot(v) - p.dist
					if dist > 0.001:
						valid = false
						break
				if valid:
					vertices.append(v)
					vertex_count += 1
					if vertex_count >= max_vertices:
						if debug_logging:
							print("Max vertices reached for brush")
						return vertices
	
	if vertices.size() == 0:
		if debug_logging:
			print("No vertices generated from plane intersections")
	return vertices

func convex_hull(points: Array[Vector3], mins: Vector3, maxs: Vector3) -> PackedVector3Array:
	# Validate input points
	if points.size() < 4:
		if debug_logging:
			print("Convex hull: too few points (%d), falling back to bounding box" % points.size())
		return create_bounding_box_vertices(mins, maxs)
	
	# Remove duplicate points
	var unique_points = PackedVector3Array()
	for p in points:
		if not unique_points.has(p):
			unique_points.append(p)
	
	if unique_points.size() < 4:
		if debug_logging:
			print("Convex hull: too few unique points (%d), falling back to bounding box" % unique_points.size())
		return create_bounding_box_vertices(mins, maxs)
	
	# Check for coplanarity
	var coplanar = true
	if unique_points.size() >= 4:
		var p0 = unique_points[0]
		var p1 = unique_points[1]
		var p2 = unique_points[2]
		var normal = (p1 - p0).cross(p2 - p0).normalized()
		for i in range(3, unique_points.size()):
			var p = unique_points[i]
			var dist = (p - p0).dot(normal)
			if abs(dist) > 0.001:
				coplanar = false
				break
	
	if coplanar:
		if debug_logging:
			print("Convex hull: points are coplanar, falling back to bounding box")
		return create_bounding_box_vertices(mins, maxs)
	
	# Set hull_points to unique_points (since brush points are already convex hull vertices)
	var hull_points = unique_points
	
	if hull_points.size() < 4:
		if debug_logging:
			print("Failed to generate convex hull, falling back to bounding box")
		return create_bounding_box_vertices(mins, maxs)
	
	# Triangulate the hull points into faces for ConcavePolygonShape3D
	var hull_vertices: PackedVector3Array = []
	# Simple triangulation: assume points form a convex polyhedron and use a fan
	for i in range(1, hull_points.size() - 1):
		hull_vertices.append(hull_points[0])
		hull_vertices.append(hull_points[i])
		hull_vertices.append(hull_points[i + 1])
	
	if hull_vertices.size() > 0:
		if debug_logging:
			print("Convex hull generated %d triangles from %d points" % [hull_vertices.size() / 3, hull_points.size()])
		return hull_vertices
	
	# Fallback if triangulation fails
	if debug_logging:
		print("Failed to triangulate convex hull, falling back to bounding box")
	return create_bounding_box_vertices(mins, maxs)

func create_bounding_box_vertices(mins: Vector3, maxs: Vector3) -> PackedVector3Array:
	var vertices = PackedVector3Array()
	# Define the 8 corners of the bounding box
	var corners = [
		Vector3(mins.x, mins.y, mins.z),
		Vector3(maxs.x, mins.y, mins.z),
		Vector3(maxs.x, maxs.y, mins.z),
		Vector3(mins.x, maxs.y, mins.z),
		Vector3(mins.x, mins.y, maxs.z),
		Vector3(maxs.x, mins.y, maxs.z),
		Vector3(maxs.x, maxs.y, maxs.z),
		Vector3(mins.x, maxs.y, maxs.z)
	]
	# Define the 12 triangles (2 per face) of the box
	var indices = [
		0, 1, 2,  0, 2, 3,  # Front
		1, 5, 6,  1, 6, 2,  # Right
		5, 4, 7,  5, 7, 6,  # Back
		4, 0, 3,  4, 3, 7,  # Left
		3, 2, 6,  3, 6, 7,  # Top
		4, 5, 1,  4, 1, 0   # Bottom
	]
	for i in indices:
		vertices.append(corners[i])
	return vertices

```

./bsp_loader_dock.gd:
```
@tool
extends Control

signal import_bsp

func _ready():
	$Button.pressed.connect(_on_button_pressed)

func _on_button_pressed():
	emit_signal("import_bsp")
```

./bsp_common.gd:
```
class_name BSPCommon
extends RefCounted

const BSP_VERSION_QUAKE3: int = 46
const LUMP_ENTITIES: int = 0
const LUMP_SHADERS: int = 1
const LUMP_PLANES: int = 2
const LUMP_NODES: int = 3
const LUMP_LEAFS: int = 4
const LUMP_LEAFSURFACES: int = 5
const LUMP_LEAFBRUSHES: int = 6
const LUMP_MODELS: int = 7
const LUMP_BRUSHES: int = 8
const LUMP_BRUSHSIDES: int = 9
const LUMP_VERTICES: int = 10
const LUMP_MESHVERTS: int = 11
const LUMP_EFFECTS: int = 12
const LUMP_SURFACES: int = 13
const EXPECTED_LUMP_COUNT: int = 17

const MST_PLANAR: int = 1
const MST_PATCH: int = 2
const MST_TRIANGLE_SOUP: int = 3

const NON_RENDER_SHADERS: PackedStringArray = [
	"common/antiportal", "common/botclip", "common/caulk", "common/forcecaulk",
	"common/clip", "common/donotenter", "common/full_clip", "common/hint",
	"common/hintskip", "common/monsterclip", "common/nodraw", "common/nodrawnonsolid",
	"common/nodrop", "common/noimpact", "common/origin", "common/skip",
	"common/trigger", "common/lightgrid", "common/waternodraw", "common/slimenodraw",
	"common/lavanodraw"
]

const SOLID_SHADERS: PackedStringArray = [
	"common/clip", "common/weapclip", "common/full_clip", "common/invisible"
]

const TRIGGER_ENTITIES: Array[String] = [
	"trigger_push", "trigger_hurt", "trigger_teleport", "trigger_multiple",
	"trigger_once", "trigger_secret", "trigger_swamp", "trigger_heal",
	"trigger_gravity", "trigger_impulse", "trigger_keylock", "trigger_race_checkpoint",
	"trigger_race_penalty", "trigger_viewlocation", "trigger_warpzone",
	"trigger_music"
]

const GOAL_ENTITIES: Array[String] = [
	"nexball_redgoal", "nexball_bluegoal", "nexball_yellowgoal",
	"nexball_pinkgoal", "nexball_fault", "nexball_out"
]

const COLLIDABLE_FUNC_ENTITIES: Array[String] = [
	"func_door", "func_door_rotating", "func_rotating", "func_wall",
	"func_breakable", "func_ladder", "func_plat", "func_train"
]

const ITEM_ENTITIES: Array[String] = [
	"item_armor_mega", "item_armor_big", "item_armor_medium", "item_armor_small",
	"item_bullets", "item_cells", "item_flag_team1", "item_flag_team2",
	"item_flag_team3", "item_flag_team4", "item_health_big", "item_health_medium",
	"item_health_mega", "item_health_small", "item_shield", "item_speed",
	"item_invisibility", "item_key", "item_key1", "item_key2", "item_vaporizer_cells",
	"item_rockets", "item_shells", "item_strength", "item_fuel", "item_fuel_regen",
	"item_jetpack"
]

const WEAPON_ENTITIES: Array[String] = [
	"weapon_crylink", "weapon_electro", "weapon_mortar", "weapon_hagar",
	"weapon_blaster", "weapon_vortex", "weapon_devastator", "weapon_shotgun",
	"weapon_machinegun", "weapon_arc", "weapon_vaporizer", "weapon_porto",
	"weapon_hlac", "weapon_minelayer", "weapon_seeker", "weapon_hook",
	"weapon_fireball", "weapon_rifle"
]

const NON_COLLIDABLE_ENTITIES: Array[String] = [
	"light", "lightJunior", "target_position", "misc_teleporter_dest",
	"func_pointparticles", "info_autoscreenshot"
]
```

./ConvexHull2D.gd:
```
class_name ConvexHull2D extends Node

# Generate 2D convex hull using Graham's scan, translated from ConvexHull2D.cs
static func generate_convex_hull(points: Array[Vector2]) -> Array[Vector2]:
	if points.size() < 3:
		return []
	
	# Find the starting point (lowest y, leftmost if tied)
	var start_pos: Vector2 = points[0]
	var start_idx: int = 0
	for i in range(1, points.size()):
		if points[i].y < start_pos.y or (is_equal_approx(points[i].y, start_pos.y) and points[i].x < start_pos.x):
			start_pos = points[i]
			start_idx = i
	
	# Initialize hull with the starting point
	var points_on_convex_hull: Array[Vector2] = [start_pos]
	var points_to_check: Array[Vector2] = points.duplicate()
	points_to_check.remove_at(start_idx) # Remove start_pos from points to check
	
	var previous_point: Vector2 = points_on_convex_hull[0]
	
	while points_to_check.size() > 0:
		var points_to_add_to_the_hull: Array[Vector2] = []
		var next_point: Vector2 = points_to_check[0]
		var next_idx: int = 0
		
		# Find the next point with the smallest polar angle
		for i in range(1, points_to_check.size()):
			var current_point: Vector2 = points_to_check[i]
			var angle_current: float = atan2(current_point.y - previous_point.y, current_point.x - previous_point.x)
			var angle_next: float = atan2(next_point.y - previous_point.y, next_point.x - previous_point.x)
			
			if angle_current < angle_next or (is_equal_approx(angle_current, angle_next) and (current_point - previous_point).length_squared() < (next_point - previous_point).length_squared()):
				next_point = current_point
				next_idx = i
		
		# Check if we've completed the hull
		if previous_point == points_on_convex_hull[0] and next_point == points_on_convex_hull[0]:
			break
		
		points_to_add_to_the_hull.append(next_point)
		points_to_check.remove_at(next_idx)
		
		# Add points to the hull and remove collinear points
		points_on_convex_hull.append_array(points_to_add_to_the_hull)
		previous_point = points_on_convex_hull[points_on_convex_hull.size() - 1]
		
		# Remove last point if it matches the first (closing the hull)
		if previous_point == points_on_convex_hull[0] and points_on_convex_hull.size() > 1:
			points_on_convex_hull.remove_at(points_on_convex_hull.size() - 1)
	
	return points_on_convex_hull
```

./map_loader.gd:
```
@tool
extends Node

func load_map(file_path: String) -> Node3D:
	var file = FileAccess.open(file_path, FileAccess.READ)
	if not file:
		push_error("Failed to open MAP file: ", file_path)
		return null
	
	var root = Node3D.new()
	root.name = file_path.get_file().get_basename()
	
	var current_entity = null
	var current_brush = null
	var brushes = []
	var line = ""
	
	while not file.eof_reached():
		line = file.get_line().strip_edges()
		if line.begins_with("//") or line.empty():
			continue
		
		if line == "{":
			if not current_entity:
				current_entity = {}
				current_entity.brushes = []
			elif not current_brush:
				current_brush = []
		elif line == "}":
			if current_brush:
				current_entity.brushes.append(current_brush)
				current_brush = null
			elif current_entity:
				if current_entity.brushes.size() > 0:
					brushes.append_array(current_entity.brushes)
				current_entity = null
		elif current_entity and not current_brush:
			var parts = line.split(" ", false)
			if parts.size() >= 2:
				var key = parts[0].strip_edges().replace("\"", "")
				var value = parts[1].strip_edges().replace("\"", "")
				current_entity[key] = value
		elif current_brush:
			if line.begins_with("("):
				var parts = line.split(" ", false)
				var plane = {}
				plane.points = [
					Vector3(float(parts[1]), float(parts[2]), float(parts[3])),
					Vector3(float(parts[6]), float(parts[7]), float(parts[8])),
					Vector3(float(parts[11]), float(parts[12]), float(parts[13]))
				]
				plane.shader = parts[15].strip_edges()
				current_brush.append(plane)
	
	file.close()
	
	# Create meshes for brushes
	for brush in brushes:
		if brush.size() < 4:
			continue
		
		# Skip non-rendering brushes
		var shader = brush[0].shader
		if shader in ["common/caulk", "common/clip", "common/weapclip", "common/nodrop"]:
			continue
		
		var mesh = ArrayMesh.new()
		var arrays = []
		arrays.resize(Mesh.ARRAY_MAX)
		var vertex_array = []
		var normal_array = []
		var texcoord_array = []
		var index_array = []
		
		# Simple triangulation (needs improvement for complex brushes)
		for plane in brush:
			var normal = (plane.points[1] - plane.points[0]).cross(plane.points[2] - plane.points[0]).normalized()
			var index_offset = vertex_array.size()
			for point in plane.points:
				vertex_array.append(point)
				normal_array.append(normal)
				texcoord_array.append(Vector2(0, 0))  # Placeholder UVs
			index_array.append_array([index_offset, index_offset + 1, index_offset + 2])
		
		arrays[Mesh.ARRAY_VERTEX] = vertex_array
		arrays[Mesh.ARRAY_NORMAL] = normal_array
		arrays[Mesh.ARRAY_TEX_UV] = texcoord_array
		arrays[Mesh.ARRAY_INDEX] = index_array
		
		if vertex_array.size() == 0:
			continue
		
		mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
		var mesh_instance = MeshInstance3D.new()
		mesh_instance.name = "Brush_" + shader.replace("/", "_")
		mesh_instance.mesh = mesh
		
		# Create material
		var material = StandardMaterial3D.new()
		var texture_base_path = "/home/l0rd/.xonotic/data/textures/"
		var texture_path = texture_base_path + shader + ".tga"
		if FileAccess.file_exists(texture_path):
			material.albedo_texture = load(texture_path)
		else:
			print("Warning: Texture not found: ", texture_path)
			material.albedo_color = Color(0.5, 0.5, 0.5)
		mesh_instance.set_surface_override_material(0, material)
		
		root.add_child(mesh_instance)
		mesh_instance.owner = root
	
	if root.get_child_count() == 0:
		push_error("No valid geometry found in MAP file")
		root.queue_free()
		return null
	
	return root
```

./scripts/root_gizmo.gd:
```
@tool
extends Node3D

func _draw_line(start: Vector3, end: Vector3, color: Color):
	var mesh := ImmediateMesh.new()
	mesh.surface_begin(Mesh.PRIMITIVE_LINES)
	mesh.surface_set_color(color)
	mesh.surface_add_vertex(start)
	mesh.surface_set_color(color)
	mesh.surface_add_vertex(end)
	mesh.surface_end()

	var mi := MeshInstance3D.new()
	mi.mesh = mesh
	mi.name = "debug_line"
	add_child(mi)
	mi.owner = get_tree().edited_scene_root if Engine.is_editor_hint() else self

func _clear_debug_lines():
	for child in get_children():
		if child.name == "debug_line":
			remove_child(child)
			child.queue_free()
			
func _process(_delta):
	if Engine.is_editor_hint():
		_clear_debug_lines()

		for child in get_children():
			var props = child.get_meta("bsp_property_", {})
			if props.has("target"):
				var target_name = props.target
				var target_node = find_node_by_name(target_name)
				if target_node:
					var start = child.global_position
					var end = target_node.global_position
					_draw_line(start, end, Color.RED)

					var dir = (end - start).normalized()
					var perp = dir.cross(Vector3.UP).normalized() * 0.1
					_draw_line(end, end - dir * 0.2 + perp, Color.RED)
					_draw_line(end, end - dir * 0.2 - perp, Color.RED)
			if props.has("angle"):
				var angle = float(props.angle)
				var dir = Vector3.FORWARD.rotated(Vector3.UP, deg_to_rad(angle))
				_draw_line(child.global_position, child.global_position + dir * 0.5, Color.BLUE)

func find_node_by_name(name: String) -> Node:
	for child in get_children():
		if child.name == name:
			return child
		var found = find_node_by_name_recursive(child, name)
		if found:
			return found
	return null

func find_node_by_name_recursive(node: Node, name: String) -> Node:
	for child in node.get_children():
		if child.name == name:
			return child
		var found = find_node_by_name_recursive(child, name)
		if found:
			return found
	return null
```

./scripts/func_entity.gd:
```
extends Node3D

func _ready():
	if not Engine.is_editor_hint():
		var props = get_meta("bsp_property_", {})
		if props.get("classname") == "func_door":
			var angle = props.get("angle", "0").to_float()
			var speed = props.get("speed", "100").to_float()
			var dir = Vector3.FORWARD.rotated(Vector3.UP, deg_to_rad(angle)) * 100 * 0.015625
			# Placeholder: Move door
		elif props.get("classname") == "func_button":
			var target = props.get("target", "")
			# Placeholder: Activate target
		elif props.get("classname") == "func_rotating":
			var speed = props.get("speed", "100").to_float()
			# Placeholder: Rotate
```

./scripts/entity.gd:
```
@tool
extends Node3D
class_name Entity3D

@export var properties: Dictionary = {}:
	set(value):
		properties = value
		notify_property_list_changed()

func _get_property_list() -> Array[Dictionary]:
	var props: Array[Dictionary] = []
	for key in properties.keys():
		props.append({
			"name": "properties/" + key,
			"type": TYPE_STRING,
			"usage": PROPERTY_USAGE_DEFAULT,
			"hint": PROPERTY_HINT_NONE
		})
	return props

func _get(property: StringName) -> Variant:
	if property.begins_with("properties/"):
		var key = property.trim_prefix("properties/")
		return properties.get(key, "")
	return null

func _set(property: StringName, value: Variant) -> bool:
	if property.begins_with("properties/"):
		var key = property.trim_prefix("properties/")
		properties[key] = str(value)
		return true
	return false

func _ready():
	if not Engine.is_editor_hint():
		# Initialize runtime behavior if needed
		pass

func _draw_gizmo():
	if Engine.is_editor_hint():
		var gizmo = EditorInterface.get_selection().get_selected_nodes()[0] if EditorInterface.get_selection().get_selected_nodes().size() > 0 else null
		if gizmo == self:
			# Draw target arrow
			if properties.has("target"):
				var target_name = properties.target
				var target_node = find_node_by_name(get_tree().get_edited_scene_root(), target_name)
				if target_node:
					var start = global_position
					var end = target_node.global_position
					var arrow = ImmediateMesh.new()
					arrow.surface_begin(Mesh.PRIMITIVE_LINES)
					arrow.surface_set_color(Color.RED)
					arrow.surface_add_vertex(start)
					arrow.surface_add_vertex(end)
					# Arrowhead
					var dir = (end - start).normalized()
					var perp = dir.cross(Vector3.UP).normalized() * 0.1
					arrow.surface_add_vertex(end)
					arrow.surface_add_vertex(end - dir * 0.2 + perp)
					arrow.surface_add_vertex(end)
					arrow.surface_add_vertex(end - dir * 0.2 - perp)
					arrow.surface_end()
					EditorInterface.get_editor_viewport_3d(0).add_child(arrow)
					arrow.queue_free()
			
			# Draw directional arrow (e.g., angle)
			if properties.has("angle"):
				var angle = float(properties.angle)
				var dir = Vector3.FORWARD.rotated(Vector3.UP, deg_to_rad(angle))
				var arrow = ImmediateMesh.new()
				arrow.surface_begin(Mesh.PRIMITIVE_LINES)
				arrow.surface_set_color(Color.BLUE)
				arrow.surface_add_vertex(global_position)
				arrow.surface_add_vertex(global_position + dir * 0.5)
				arrow.surface_end()
				EditorInterface.get_editor_viewport_3d(0).add_child(arrow)
				arrow.queue_free()

func find_node_by_name(node: Node, name: String) -> Node:
	if node.name == name:
		return node
	for child in node.get_children():
		var found = find_node_by_name(child, name)
		if found:
			return found
	return null
```

./scripts/trigger_entity.gd:
```
extends StaticBody3D

var properties: Dictionary = {}

func _ready():
	properties = get_meta("bsp_properties", {})
	var classname = properties.get("classname", "")
	
	if classname == "trigger_push":
		# Handle push trigger (e.g., push player toward target)
		var target = properties.get("target", "")
		if target:
			# Find target_position node
			var target_node = get_tree().get_root().find_node(target, true, false)
			if target_node:
				# Example: Apply impulse when player enters
				pass
	elif classname == "trigger_teleport":
		# Handle teleport trigger
		var target = properties.get("target", "")
		if target:
			var target_node = get_tree().get_root().find_node(target, true, false)
			if target_node:
				# Example: Teleport player to target
				pass
	elif classname == "trigger_hurt":
		# Handle hurt trigger
		var damage = properties.get("damage", "100").to_int()
		# Example: Apply damage to player
		pass
	else:
		print("Unsupported trigger type: ", classname)

func _on_area_entered(area: Area3D):
	var parent = area.get_parent()
	if parent.is_in_group("player"):
		var classname = properties.get("classname", "")
		if classname == "trigger_push":
			# Implement push logic
			pass
		elif classname == "trigger_teleport":
			# Implement teleport logic
			pass
		elif classname == "trigger_hurt":
			# Implement hurt logic
			pass
```

