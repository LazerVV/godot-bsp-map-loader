./Assets/Scripts/GameManager.cs:
```
using Godot;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text.Json;
using System.Text.Json.Serialization;
public partial class GameManager : Node
{
	[Export]
	WorldEnvironment worldEnvironment;
	[Export]
	public Node3D Sun;
	[Export]
	public Node3D Root;
	[Export]
	public ConsoleManager console;
	[Export]
	public BasePak gameSelect = BasePak.QuakeLive;
	[Export]
	public string[] mapRotation;
	private List<string> _mapRotation = new List<string>();
	[Export]
	public int timeLimit = 7;
	[Export]
	public int fragLimit = 15;
	[Export]
	public int tessellations = 5;
	[Export]
	public float colorLightning = 1f;
	[Export]
	public float mixBrightness = 0.25f;             // Range from 0 to 1, .25f Is the nicest
	[Export]
	public float shadowIntensity = 1f;
	[Export]
	public Container[] SplitScreen;
	[Export]
	public Container IntermissionContainer;
	[Export]
	public SubViewport IntermissionViewPort;
	[Export]
	public SubViewport AdvertisementViewPort;
	[Export]
	public VideoStreamPlayer AdvertisementVideo;

	[Export]
	public PackedScene viewPortPrefab;
	[Export]
	public PackedScene scoreBoard;

	public static GameManager Instance;

	public Color ambientLightColor;
	// Quake3 also uses Doom and Wolf3d scaling down
	public const float sizeDividor = 1f / 32f;
	public const float modelScale = 1f / 64f;

	//Physic Layers
	public const short DefaultLayer = 0;
	public const short PhysicCollisionLayer = 1;

	public const short ColliderLayer = 2;
	public const short InvisibleBlockerLayer = 3;
	public const short WalkTriggerLayer = 4;

	public const short ThingsLayer = 5;
	public const short DamageablesLayer = 6;
	public const short Player1Layer = 7;
	public const short Player2Layer = 8;
	public const short Player3Layer = 9;
	public const short Player4Layer = 10;
	public const short Player5Layer = 11;
	public const short Player6Layer = 12;
	public const short Player7Layer = 13;
	public const short Player8Layer = 14;
	public const short RagdollLayer = 15;
	public const short FogLayer = 16;
	public const short WaterLayer = 17;
	
	//3DRender Layer
	public const short Player1ViewLayer = 0;
	public const short Player2ViewLayer = 1;
	public const short Player3ViewLayer = 2;
	public const short Player4ViewLayer = 3;
	public const short Player5ViewLayer = 4;
	public const short Player6ViewLayer = 5;
	public const short Player7ViewLayer = 6;
	public const short Player8ViewLayer = 7;

	public const short Player1UIViewLayer = 8;
	public const short Player2UIViewLayer = 9;
	public const short Player3UIViewLayer = 10;
	public const short Player4UIViewLayer = 11;
	public const short Player5UIViewLayer = 12;
	public const short Player6UIViewLayer = 13;
	public const short Player7UIViewLayer = 14;
	public const short Player8UIViewLayer = 15;
	public const short PlayerNormalDepthLayer = 16;
	public const short NotVisibleLayer = 17;
	public const short UINotVisibleLayer = 17;

	//Physic Masks
	public const uint TakeDamageMask = ((1 << DamageablesLayer) | 
										(1 << Player1Layer) | 
										(1 << Player2Layer) | 
										(1 << Player3Layer) | 
										(1 << Player4Layer) | 
										(1 << Player5Layer) | 
										(1 << Player6Layer) | 
										(1 << Player7Layer) | 
										(1 << Player8Layer));

	public const uint NoHitMask = ((1 << PhysicCollisionLayer) |
									(1 << InvisibleBlockerLayer) |
									(1 << WalkTriggerLayer) |
									(1 << ThingsLayer));

	//Rendering Masks
	public const int InvisibleMask = 0;
	public const uint AllPlayerViewMask = ((1 << Player1ViewLayer) | (1 << Player2ViewLayer) | (1 << Player3ViewLayer) | (1 << Player4ViewLayer) | (1 << Player5ViewLayer) | (1 << Player6ViewLayer) | (1 << Player7ViewLayer) | (1 << Player8ViewLayer));

	//FX Mask
	public const short QuadFX = 1;
	public const short BattleSuitFX = 2;
	public const short BattleSuitAndQuadFX = 3;
	public const short RegenFX = 4;
	public const short InvisFX = 8;


	//SplitScreen Players
	public const int MaxLocalPlayers = 8;

	private bool paused = true;
	public static bool Paused { get { return Instance.paused; } }

	private float timeMs = 0.0f;
	public static float CurrentTimeMsec { get { return Instance.timeMs; } }

	public static FuncState CurrentState { get { return Instance.currentState; } }
	public static MusicType currentMusic = MusicType.None;

	private bool timeToSync = false;
	public static bool NewTickSeconds { get { return Instance.timeToSync; } }
	public static int NumLocalPlayers { get { return Instance.Players.Count; } }

	public static ConsoleManager Console { get { return Instance.console; } }

	public float gravity = 25f;					//default 800 * sizeDividor
	public float friction = 6f;
	public float flightAccel = 12;
	public float waterFriction = 12f;
	public float waterDeadFall = 4.5f;
	public float terminalLimit = 256f;
	public float terminalVelocity = 16f;
	public float barrierVelocity = 1024f;
	public float playerHeight = 1.2f;
	public int playerMass = 80;
	public int gibHealth = -40;

	public float PlayerDamageReceive = 1f;
	public int PlayerAmmoReceive = 1;
	private Godot.Environment environment;
	private float syncTime = 1;

	//skip frames are used to easen up deltaTime after loading
	public int skipFrames = 5;
	public Node3D TemporaryObjectsHolder;
	[Export]
	public PackedScene playerPrefab;
	[Export]
	public MusicType musicType = MusicType.None;
	[Export]
	public GameType gameType = GameType.FreeForAll;
	[Export]
	public SoundData[] OverrideSounds;

	public List<int> playerController = new List<int>();
	public List<PlayerThing> Players = new List<PlayerThing>();
	public string[] defaultModels = { "Doom", "Crash", "Ranger", "Visor", "Sarge", "Major", "Anarki", "Grunt" };
	public string[] defaultSkins = { "default", "default", "default", "default", "default", "default", "default", "default" };

	public Camera3D interMissionCamera = null;
	public List<int> controllerWantToJoin = new List<int>();
	public Vector2I viewPortSize = new Vector2I(1280 , 720);
	public int QuadMul = 3;

	private int mapNum = 0;
	private float mapLeftTime = 0;
	public float currentDeathRatio = 0;

	public AudioStreamPlayer AnnouncerStream;
	public AudioStreamPlayer StaticMusicPlayer = null;
	public string announcer = Announcer.Quake;

	private static readonly string FiveMinutes = "feedback/5_minute";
	private static readonly string OneMinute = "feedback/1_minute";
	private static readonly string[] Seconds = { "feedback/three", "feedback/two", "feedback/one" };
	private static readonly string[] FragsLeft = { "feedback/1_frag", "feedback/2_frags", "feedback/3_frags" };

	private int second = 0;
	private int currentDeathCount = 0;

	private bool useCustomMap = false;
	private bool useCheats = false;
	private string nextMapName;
	public static class Announcer
	{
		public const string Male = "vo/";
		public const string Quake = "vo_evil/";
		public const string Female = "vo_female/";
	}

	[JsonConverter(typeof(JsonStringEnumConverter<BasePak>))]
	public enum BasePak
	{
		All = 0,
		QuakeLive = 4,
		TeamArena = 3,
		Quake3 = 2,
		Demo = 1
	}
	public enum FuncState
	{
		None,
		Ready,
		Start,
		End
	}
	public enum PrintType
	{
		Log,
		Info,
		Warning,
		Error,
		Success
	}

	[JsonConverter(typeof(JsonStringEnumConverter<MusicType>))]
	public enum MusicType
	{
		None,
		Static,
		Dynamic,
		Random
	}

	[JsonConverter(typeof(JsonStringEnumConverter<GameType>))]
	public enum GameType
	{
		SinglePlayer,
		FreeForAll,
		QuadHog,
		Tournament,
		TeamDeathmatch,
		CaptureTheFlag,
		OneFlagCTF,
		Overload,
		Harvester
	}
	public enum LimitReach
	{
		None,
		Time,
		Frag
	}
	public static class ControllerType
	{
		public const int MouseKeyboard = 0;
		public const int Joy_0 = 1;
		public const int Joy_1 = 2;
		public const int Joy_2 = 3;
		public const int Joy_3 = 4;
		public const int Joy_4 = 5;
		public const int Joy_5 = 6;
		public const int Joy_6 = 7;
		public const int Joy_7 = 8;
	}

	private FuncState currentState = FuncState.None;

	private LimitReach limitReach = LimitReach.None;

	private static PrintType printType = PrintType.Log;
	private static int printLine = 0;
	private bool loading = false;

	public class GameConfigData
	{
		public BasePak GameSelect { get; set; } = BasePak.QuakeLive;
		public GameType GameType  { get; set; } = GameType.QuadHog;
		public MusicType MusicType { get; set; } = MusicType.Random;
		public int TimeLimit { get; set; } = 7;
		public int FragLimit { get; set; } = 15;
		public string[] Players { get; set; } = new string[8] { "Doom", "Crash", "Ranger", "Visor", "Sarge", "Major", "Anarki", "Grunt" };
	}

	public GameConfigData gameConfig = new GameConfigData();
	public override void _Ready()
	{
		//Disable Resizeable
		DisplayServer.WindowSetFlag(DisplayServer.WindowFlags.ResizeDisabled, true);

		//Disable Physics Jitter Fix
		Engine.PhysicsJitterFix = 0;

		AnnouncerStream = new AudioStreamPlayer();
		AddChild(AnnouncerStream);
		AnnouncerStream.VolumeDb = 7;
		AnnouncerStream.Name = "AnnouncerStream";
		AnnouncerStream.Bus = "FXBus";

		GD.Randomize();
		//Used in order to parse float with "." as decimal separator
		CultureInfo CurrentCultureInfo = new CultureInfo("en", false);
		CurrentCultureInfo.NumberFormat.NumberDecimalSeparator = ".";
		CurrentCultureInfo.NumberFormat.CurrencyDecimalSeparator = ".";
		CultureInfo.DefaultThreadCurrentCulture = CurrentCultureInfo;

		Input.MouseMode = Input.MouseModeEnum.Captured;
		environment = worldEnvironment.Environment;
		ambientLightColor = environment.AmbientLightColor;
		Instance = this;

		//Init Console
		console.Init();

		//Load Config
		LoadGameConfigData();

		//Load Sounds
		SoundManager.AddSounds(OverrideSounds);

		if ((gameConfig.MusicType == MusicType.Static) || (gameConfig.MusicType == MusicType.Random))
		{
			StaticMusicPlayer = new AudioStreamPlayer();
			AddChild(StaticMusicPlayer);
			StaticMusicPlayer.VolumeDb = 7;
			StaticMusicPlayer.Name = "Music";
			StaticMusicPlayer.Bus = "BKGBus";
		}

		PakManager.LoadPK3Files();
		//Process extra shaders
		MaterialManager.Instance.AddExtraShaders();
		MaterialManager.LoadFXShaders();
		MaterialManager.SetAmbient();

		//SetGameType
		switch (gameConfig.GameType)
		{
			default:
			break;
			case GameType.QuadHog:
				ThingsManager.uniqueGamePlayThings.Add("item_quad");
			break;
		}

		if (gameConfig.GameSelect != BasePak.Demo)
		{
			PakManager.OrderLists();
			_mapRotation = PakManager.LoadMapRotation();
		}

		if (_mapRotation.Count == 0)
		{
			for (int i = 0; i < mapRotation.Length; i++)
			{
				string mapName = mapRotation[i].ToUpper();
				if (PakManager.mapList.Contains(mapName))
					_mapRotation.Add(mapName);
			}
		}
		if (_mapRotation.Count == 0)
			_mapRotation.Add(PakManager.mapList[0]);

		if (gameConfig.GameSelect == BasePak.Demo)
			PakManager.KeepDemoList(_mapRotation);

		mapLeftTime = gameConfig.TimeLimit * 60;
		nextMapName = _mapRotation[0];

		SaveGameData();
	}

	public void LoadGameConfigData()
	{
		bool loaded = false;
		string configFile = Directory.GetCurrentDirectory() + "/qa_game.cfg";
		if (File.Exists(configFile))
		{
			string jsonString = File.ReadAllText(configFile);
			try
			{
				gameConfig = JsonSerializer.Deserialize(jsonString, SourceGenerationContext.Default.GameConfigData);
				loaded = true;
			}
			catch (JsonException)
			{
				gameConfig = new GameConfigData();
			}
		}
		if (loaded)
		{
			if (gameConfig.GameSelect > BasePak.QuakeLive)
				gameConfig.GameSelect = gameSelect;

			if (gameConfig.GameType > GameType.Harvester)
				gameConfig.GameType = gameType;

			if (gameConfig.MusicType > MusicType.Random)
				gameConfig.MusicType = musicType;

			if (gameConfig.TimeLimit < 1)
				gameConfig.TimeLimit = timeLimit;

			if (gameConfig.FragLimit < 1)
				gameConfig.FragLimit = fragLimit;

			if (gameConfig.Players.Length < 8)
			{
				gameConfig.Players = new string[8];
				for (int i = 0; i < gameConfig.Players.Length; i++)
					gameConfig.Players[i] = defaultModels[i];
			}

			return;
		}

		gameConfig.GameSelect = gameSelect;
		gameConfig.GameType = gameType;
		gameConfig.MusicType = musicType;
		gameConfig.TimeLimit = timeLimit;
		gameConfig.FragLimit = fragLimit;
		for (int i = 0; i < gameConfig.Players.Length; i++)
			gameConfig.Players[i] = defaultModels[i];
	}
	public void SaveGameData()
	{
		string configFilName = Directory.GetCurrentDirectory() + "/qa_game.cfg";
		FileStream configFile = File.Open(configFilName, FileMode.Create, System.IO.FileAccess.ReadWrite);
		if (File.Exists(configFilName))
		{
			configFile.Seek(0, SeekOrigin.Begin);
			string commentData = "//Quadot-Arena Game Config File\n";
			commentData += "//\"GameSelect\" posible values are: \"All\" , \"QuakeLive\" , \"TeamArena\" , \"Quake3\" , \"Demo\"\n";
			commentData += "//\"GameType\" posible values are: \"FreeForAll\" , \"QuadHog\"\n";
			commentData += "//\"MusicType\" posible values are: \"None\" , \"Static\", \"Dynamic\" , \"Random\"\n";
			commentData += "//If any value is invalid, the whole file will be discarded and regenerated with default values\n";
			configFile.Write(commentData.ToAsciiBuffer());
			byte[] writeData = JsonSerializer.SerializeToUtf8Bytes(gameConfig, SourceGenerationContext.Default.GameConfigData);
			configFile.Write(writeData);
			configFile.Close();
		}
	}

	public override void _Input(InputEvent @event)
	{
		if (@event is InputEventJoypadButton)
		{
			for (int i = 1; i < 8; i++) 
			{
				if (Input.IsActionJustPressed("Start_"+i))
					controllerWantToJoin.Add(i);
			}
		}

		if (@event is InputEventKey)
		{
			if (Input.IsActionJustPressed("Console"))
				console.ChangeConsole();

			if (console.visible == false)
			{
				if (Input.IsActionJustPressed("Start_0"))
					controllerWantToJoin.Add(0);
			}

			if (Input.IsActionJustPressed("Escape"))
			{
				if (!paused)
				{
					paused = true;
					Input.MouseMode = Input.MouseModeEnum.Visible;
				}
				else
				{
					paused = false;
					Input.MouseMode = Input.MouseModeEnum.Captured;
					if (console.visible)
						console.commandLine.GrabFocus();
				}
				AdvertisementVideo.Paused = paused;
			}
		}
		else if (paused)
		{
			if (@event is InputEventMouseButton)
			{
				if (Input.IsActionJustPressed("Action_Fire_0"))
				{
					paused = false;
					AdvertisementVideo.Paused = paused;
					Input.MouseMode = Input.MouseModeEnum.Captured;
					if (console.visible)
						console.commandLine.GrabFocus();
				}
			}
		}
	}
	public override void _Process(double delta)
	{
		float deltaTime = (float)delta;

		if (!paused)
		{
			timeMs += deltaTime;
			timeToSync = CheckIfSyncTime(deltaTime);
			RenderingServer.GlobalShaderParameterSet("MsTime", CurrentTimeMsec);
		}

		if (mapLeftTime > 0)
		{
			mapLeftTime -= deltaTime;
			if (timeToSync)
			{
				if ((mapLeftTime > 299) && (mapLeftTime < 300))
					PlayAnnouncer(FiveMinutes);
				else if ((mapLeftTime > 59) && (mapLeftTime < 60))
					PlayAnnouncer(OneMinute);
				else if (mapLeftTime < 4)
				{
					if (mapLeftTime < 1)
					{
						IntermissionContainer.Show();
						if (limitReach == LimitReach.None)
							limitReach = LimitReach.Time;
						if (console.visible)
							console.ChangeConsole(true);
					}
					else if (limitReach == LimitReach.None)
						PlayAnnouncer(Seconds[second++]);
				}
			}
		}
		else if (mapLeftTime < 0)
		{
			if (!useCustomMap)
			{
				mapNum++;
				if (mapNum >= _mapRotation.Count)
					mapNum = 0;
				nextMapName = _mapRotation[mapNum];
			}
			mapLeftTime = gameConfig.TimeLimit * 60;
			second = 0;
			paused = true;
			CallDeferred("ChangeMap");
		}
	}

	public override void _PhysicsProcess(double delta)
	{
		switch (currentState)
		{
			default:
			break;
			case FuncState.None:
				if (skipFrames > 0)
				{
					skipFrames--;
					if (skipFrames == 0)
					{
						LoadMap();
						currentState = FuncState.Ready;
					}
				}
			break;
			case FuncState.Ready:
				if (skipFrames > 0)
				{
					skipFrames--;
					if (skipFrames == 0)
					{
						if (loading)
						{
							if (Players.Count > 0)
								AddAllPlayer();
							loading = false;
						}
						else
							IntermissionViewPort.Size = DisplayServer.WindowGetSize();
						paused = false;
						currentState = FuncState.Start;
					}
				}
			break;
			case FuncState.Start:
				for(int i = 0; i < controllerWantToJoin.Count; i++)
				{
					int controller = controllerWantToJoin[i];
					if (playerController.Contains(controller))
						continue;
					int playerNum = Players.Count;
					SetupNewPlayer(playerNum, controller);
					CheckNumPlayerAdded(playerNum);
					controllerWantToJoin.Remove(controller);
				}
			break;
		}
	}
	public void PlayAnnouncer(string sound)
	{
		AudioStream audio = SoundManager.LoadSound(sound);
		if (audio == null)
			audio = SoundManager.LoadSound(sound.Replace("feedback/", announcer));

		if (audio == null)
			return;

		AnnouncerStream.Stream = audio;
		AnnouncerStream.Play();
	}

	public void CheckDeathCount(int frags)
	{
		int left = gameConfig.FragLimit - frags;
		if (left > 0)
		{
			left--;
			if (left < 3)
				PlayAnnouncer(FragsLeft[left]);
		}
		else
		{
			limitReach = LimitReach.Frag;
			mapLeftTime = 1f;
		}
		currentDeathCount++;
	}

	public float GetDeathRatioAndReset(bool reset = true)
	{
		currentDeathRatio = (currentDeathCount / Players.Count);
		if (reset)
			currentDeathCount = 0;
		return currentDeathRatio;
	}

	public void AddAllPlayer()
	{
		foreach (PlayerThing player in Players)
		{
			if (player.playerControls.playerWeapon != null)
			{
				player.playerControls.playerWeapon.QueueFree();
				player.playerControls.playerWeapon = null;
			}
			if (player.interpolatedTransform != null)
				player.interpolatedTransform.QueueFree();
			player.playerInfo.playerPostProcessing.playerHUD.HideAmmo();
			player.playerInfo.playerPostProcessing.playerHUD.RemoveAllItems();
			player.playerInfo.Reset();
			player.deaths = 0;
			player.playerInfo.playerPostProcessing.playerHUD.deathsText.Text = "0";
			player.frags = 0;
			player.playerInfo.playerPostProcessing.playerHUD.fragsText.Text = "0";
			player.InitPlayer();
			if (ScoreBoard.Instance != null)
				ScoreBoard.Instance.AddPlayer(player);
		}
		IntermissionContainer.Hide();
		switch (gameConfig.MusicType)
		{
			default:
				currentMusic = MusicType.None;
			break;
			case MusicType.Static:
				StaticMusicPlayer.Stop();
				StaticMusicPlayer.Play();
				currentMusic = MusicType.Static;
			break;
			case MusicType.Dynamic:
				AdaptativeMusicManager.Instance.StopMusic();
				AdaptativeMusicManager.Instance.StartMusic();
				currentMusic = MusicType.Dynamic;
			break;
			case MusicType.Random:
				AdaptativeMusicManager.Instance.StopMusic();
				if (StaticMusicPlayer.Stream != null)
				{
					StaticMusicPlayer.Stop();
					if (GD.RandRange(0, 1) > 0)
					{
						StaticMusicPlayer.Play();
						currentMusic = MusicType.Static;
					}
					else
					{
						AdaptativeMusicManager.Instance.StartMusic();
						currentMusic = MusicType.Dynamic;
					}
				}
				else
				{
					AdaptativeMusicManager.Instance.StartMusic();
					currentMusic = MusicType.Dynamic;
				}
			break;
		}
	}

	public void LoadMap()
	{
		TemporaryObjectsHolder = new Node3D();
		TemporaryObjectsHolder.Name = "TemporaryObjectsHolder";
		AddChild(TemporaryObjectsHolder);
		if (MapLoader.Load(nextMapName))
		{
			interMissionCamera = null;
			ClusterPVSManager.Instance.ResetClusterList(MapLoader.surfaces.Count);
			MapLoader.GenerateMapCollider();
			MapLoader.GenerateMapFog();
			MapLoader.GenerateSurfaces();
			MapLoader.SetLightVolData();
			ThingsManager.AddThingsToMap();
		}
		PakManager.ClosePK3Files();
		limitReach = LimitReach.None;
		skipFrames = 5;
		loading = true;
	}

	public void ChangeMap(string nextMap, bool cheats = false)
	{
		if (!string.IsNullOrEmpty(nextMap))
		{
			useCustomMap = true;
			nextMapName = nextMap;
			useCheats = cheats;
		}
		console.ChangeConsole(true);
		limitReach = LimitReach.Time;
		mapLeftTime = 1;		
	}

	public void ChangeMap()
	{
		useCustomMap = false;
		MapLoader.UnloadMap(useCheats);
		useCheats = false;
		skipFrames = 5;
		currentState = FuncState.None;
	}

	public void CheckNumPlayerAdded(int playerNum)
	{
		if (playerNum > 0)
		{
			ThingsManager.NewLocalPlayerAdded();
			return;
		}

		switch (gameConfig.MusicType)
		{
			default:
			break;
			case MusicType.Static:
				StaticMusicPlayer.Play();
			break;
			case MusicType.Dynamic:
				AdaptativeMusicManager.Instance.StartMusic();
			break;
			case MusicType.Random:
				if (GD.RandRange(0, 1) > 0)
					StaticMusicPlayer.Play();
				else
					AdaptativeMusicManager.Instance.StartMusic();
			break;
		}
	}

	public void SetupNewPlayer(int playerNum, int controllerNum)
	{
		PlayerThing player = (PlayerThing)playerPrefab.Instantiate();
		player.Name = "Player "+ playerNum;
		player.playerViewPort = (PlayerViewPort)viewPortPrefab.Instantiate();
		AddChild(player);
		if (playerNum == 0)
		{
			player.playerInfo.playerPostProcessing.ViewPortCamera.Current = true;
			IntermissionContainer.Hide();
		}

		player.playerName = gameConfig.Players[playerNum];
		player.modelName = defaultModels[playerNum];
		player.skinName = defaultSkins[playerNum];

		player.playerInfo.SetPlayer(playerNum);
		player.playerControls.Init(controllerNum);
		player.InitPlayer();
		Players.Add(player);
		playerController.Add(controllerNum);
		switch (Players.Count)
		{
			default:
			break;
			case 1:
				SplitScreen[0].AddChild(player.playerViewPort);
			break;
			case 2:
				SplitScreen[1].AddChild(player.playerViewPort);
			break;
			case 3:
				SplitScreen[1].AddChild(player.playerViewPort);
			break;
			case 4:
				SplitScreen[0].AddChild(player.playerViewPort);
			break;
			case 5:
				SplitScreen[1].AddChild(player.playerViewPort);
			break;
			case 6:
				SplitScreen[0].AddChild(player.playerViewPort);
			break;
			case 7:
				Players[2].playerViewPort.Reparent(SplitScreen[2]);
				SplitScreen[2].AddChild(player.playerViewPort);
				IntermissionContainer.Reparent(SplitScreen[1]);
				SplitScreen[1].MoveChild(IntermissionContainer, 1);
				IntermissionContainer.Show();
			break;
			case 8:
				SplitScreen[2].AddChild(player.playerViewPort);
			break;
		}
		ArrangeSplitScreen();
		if (ScoreBoard.Instance != null)
			ScoreBoard.Instance.AddPlayer(player);
	}

	public void RemovePlayer(int playerNum)
	{
		if (playerNum >= Players.Count)
			return;

		if (Players.Count == 7)
		{
			IntermissionContainer.Reparent(this);
			IntermissionContainer.Hide();
		}
			
		Players[playerNum].Damage(1000, DamageType.Telefrag);
		Players[playerNum].playerViewPort.QueueFree();
		Players[playerNum].QueueFree();
		Players.RemoveAt(playerNum);
		playerController.RemoveAt(playerNum);
		ScoreBoard.Instance.RemovePlayer(playerNum);
		for(int i = 0; i < Players.Count; i++)
		{
			PlayerThing player = Players[i];
			player.playerInfo.UpdatePlayer(i);
			switch (Players.Count)
			{
				default:
					break;
				case 1:
					player.playerViewPort.Reparent(SplitScreen[0]);
					break;
				case 2:
				{
					switch (i)
					{
						default:
							player.playerViewPort.Reparent(SplitScreen[0]);
						break;
						case 1:
							player.playerViewPort.Reparent(SplitScreen[1]);
						break;
					}
				}
				break;
				case 3:
				{
					switch (i)
					{
						case 0:
							player.playerViewPort.Reparent(SplitScreen[0]);
						break;
						default:
							player.playerViewPort.Reparent(SplitScreen[1]);
						break;
					}
				}
				break;
				case 4:
				{
					switch (i)
					{
						case 0:
						case 3:
							player.playerViewPort.Reparent(SplitScreen[0]);
						break;
						default:
							player.playerViewPort.Reparent(SplitScreen[1]);
						break;
					}
				}
				break;
				case 5:
				{
					switch (i)
					{
						case 0:
						case 3:
							player.playerViewPort.Reparent(SplitScreen[0]);
						break;
						default:
							player.playerViewPort.Reparent(SplitScreen[1]);
						break;
					}
				}
				break;
				case 6:
				{
					switch (i)
					{
						case 0:
						case 3:
						case 5:
							player.playerViewPort.Reparent(SplitScreen[0]);
						break;
						default:
							player.playerViewPort.Reparent(SplitScreen[1]);
						break;
					}
				}
				break;
				case 7:
				{
					switch (i)
					{
						case 0:
						case 3:
						case 5:
							player.playerViewPort.Reparent(SplitScreen[0]);
						break;
						case 2:
							player.playerViewPort.Reparent(SplitScreen[2]);
						break;
						case 6:
							player.playerViewPort.Reparent(SplitScreen[2]);
							IntermissionContainer.Reparent(SplitScreen[1]);
							SplitScreen[1].MoveChild(IntermissionContainer, 1);
							IntermissionContainer.Show();
						break;
						default:
							player.playerViewPort.Reparent(SplitScreen[1]);
						break;
					}
				}
				break;
			}
		}
		ArrangeSplitScreen();
	}

	public void ArrangeSplitScreen()
	{
		Vector2I Size = DisplayServer.WindowGetSize();
		int i = 0;
		foreach (PlayerThing player in Players) 
		{
			Vector2I size = Size;
			switch (Players.Count)
			{
				default:
				case 1:
				break;
				case 2:
					size.Y /= 2;
				break;
				case 3:
					size.Y /= 2;
					if (i > 0)
						size.X /= 2;
				break;
				case 4:
					size.Y /= 2;
					size.X /= 2;
				break;
				case 5:
					size.Y /= 2;
					if ((i == 0) || (i == 3))
						size.X /= 2;
					else
						size.X /= 3;
				break;
				case 6:
					size.Y /= 2;
					size.X /= 3;
				break;
				case 7:
					size.Y /= 3;
					if ((i == 2) || (i == 6))
						size.X /= 2;
					else
						size.X /= 3;
					if (i == 0)
						IntermissionViewPort.Size = size;
				break;
				case 8:
					size.Y /= 3;
					size.X /= 3;
					if (i == 0)
						IntermissionViewPort.Size = size;
				break;
			}
			player.playerViewPort.viewPort.Size = size;
			player.playerInfo.playerPostProcessing.ViewPort.Size = size;
			SetViewPortToCamera(player.playerInfo.playerPostProcessing.ViewPortCamera, player.playerViewPort.viewPort);
			i++;
		}
	}

	public void SetViewPortToCamera(Camera3D camera, SubViewport viewPort)
	{
		var CamRID = camera.GetCameraRid();
		var viewPortRID = viewPort.GetViewportRid();
		RenderingServer.ViewportAttachCamera(viewPortRID, CamRID);
	}

	public static List<T> GetAllChildrensByType<T>(Node parent)
	{
		List<T> list = new List<T>();

		var Childrens = parent.GetChildren();
		foreach (var child in Childrens)
		{
			if (child.IsQueuedForDeletion())
				continue;

			if (child is T childT)
				list.Add(childT);

			list.AddRange(GetAllChildrensByType<T>(child));
		}
		return list;
	}

	public static List<MeshInstance3D> GetModulateMeshes(Node parent, List<MeshInstance3D> ignoreList = null)
	{
		var Childrens = GetAllChildrensByType<MeshInstance3D>(parent);
		List<MeshInstance3D> currentMeshes = new List<MeshInstance3D>();

		if (ignoreList == null)
			ignoreList = new List<MeshInstance3D>();

		foreach (var mesh in Childrens)
		{
			if (mesh.Mesh == null)
				continue;

			if (ignoreList.Contains(mesh))
				continue;
			ShaderMaterial shaderMaterial = (ShaderMaterial)mesh.GetActiveMaterial(0);
			var Results = RenderingServer.GetShaderParameterList(shaderMaterial.Shader.GetRid());
			foreach (var result in Results)
			{
				Variant nameVar;
				if (result.TryGetValue("name", out nameVar))
				{
					string name = (string)nameVar;
					if (name == "UseModulation")
					{
						currentMeshes.Add(mesh);
						break;
					}
				}
			}
		}
		return currentMeshes;
	}
	public static List<MeshInstance3D> CreateFXMeshInstance3D(Node parent)
	{
		var Childrens = GetAllChildrensByType<MeshInstance3D>(parent);
		List<MeshInstance3D> fxMeshes = new List<MeshInstance3D>();
		foreach (var mesh in Childrens)
		{
			if (mesh.Mesh == null)
				continue;

			MeshInstance3D fxMesh = new MeshInstance3D();
			fxMesh.Mesh = mesh.Mesh;
			fxMesh.Layers = mesh.Layers;
			fxMesh.Visible = false;
			mesh.AddChild(fxMesh);
			fxMeshes.Add(fxMesh);
		}
		return fxMeshes;
	}
	public static void ChangeFx(List<MeshInstance3D> fxMeshes, int currentFx, bool viewModel = false, bool FXMesh = true)
	{
		for (int i = 0; i < fxMeshes.Count; i++)
		{
			MeshInstance3D mesh = fxMeshes[i];
			if (currentFx != 0)
			{
				mesh.MaterialOverlay = null;
				if ((currentFx & InvisFX) != 0)
				{
					if (FXMesh)
						mesh.Visible = false;
					else
					{
						if (viewModel)
							mesh.SetSurfaceOverrideMaterial(0, MaterialManager.invisWeaponFxMaterial);
						else
							mesh.SetSurfaceOverrideMaterial(0, MaterialManager.invisFxMaterial);
					}
					continue;
				}

				mesh.Visible = true;
				if ((currentFx & BattleSuitAndQuadFX) == BattleSuitAndQuadFX)
				{
					if (viewModel)
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.battleSuitAndQuadWeaponFxMaterial);
					else
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.battleSuitAndQuadFxMaterial);
				}
				else if ((currentFx & BattleSuitFX) != 0)
				{					
					if (viewModel)
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.battleSuitWeaponFxMaterial);
					else
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.battleSuitFxMaterial);
				}
				else if ((currentFx & QuadFX) != 0)
				{
					if (viewModel)
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.quadWeaponFxMaterial);
					else
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.quadFxMaterial);
				}

				if (currentFx == RegenFX)
				{
					if (viewModel)
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.regenWeaponFxMaterial);
					else
						mesh.SetSurfaceOverrideMaterial(0, MaterialManager.regenFxMaterial);
				}
				else if ((currentFx & RegenFX) != 0)
				{
					if (viewModel)
						mesh.MaterialOverlay = MaterialManager.regenWeaponFxMaterial;
					else
						mesh.MaterialOverlay = MaterialManager.regenFxMaterial;
				}
			}
			else if (FXMesh)
				mesh.Visible = false;
			else
				mesh.SetSurfaceOverrideMaterial(0, null);
		}
	}
	public static void Print(string Message, PrintType type = PrintType.Log)
	{
		if (type >= printType)
		{
			GD.Print(printLine + ": " + Message);

			if (Instance == null)
				return;

			Console.AddToConsole(Message, type);
			switch (type)
			{
				default:
				break;
				case PrintType.Warning:
					GD.PushWarning(printLine + ": " + Message);
				break;
				case PrintType.Error:
					GD.PushError(printLine + ": " + Message);
				break;
			}
			printLine++;
		}
	}
	private bool CheckIfSyncTime(float deltaTime)
	{
		syncTime -= deltaTime;
		if (syncTime < 0)
		{
			syncTime += 1;
			return true;
		}
		return false;
	}

	public void ChangeTimeLimit(int limit)
	{
		if (limit < gameConfig.TimeLimit)
		{
			mapLeftTime -= (gameConfig.TimeLimit - limit) * 60;
			if (mapLeftTime < 1)
			{
				limitReach = LimitReach.Time;
				mapLeftTime = 1;
			}
		}
		else
			mapLeftTime += (limit - gameConfig.TimeLimit) * 60;
		gameConfig.TimeLimit = limit;
		SaveGameData();
	}

	public void ChangeFragLimit(int limit)
	{
		gameConfig.FragLimit = limit;
		foreach (PlayerThing player in Players)
			CheckDeathCount(player.frags);
		SaveGameData();
	}

	public void ChangePlayerName(int playerNum, string playerName)
	{
		gameConfig.Players[playerNum] = playerName;
		SaveGameData();

		Players[playerNum].playerName = playerName;
		if (!Players[playerNum].playerInfo.LoadSavedConfigData())
			Players[playerNum].playerInfo.SaveConfigData();
	}
	public static void QuitGame()
	{
		SceneTree main = Instance.GetTree();
		PakManager.ClosePK3Files();
		main.Root.PropagateNotification((int)NotificationWMCloseRequest);
		main.Quit();
	}

}
```

./Assets/Scripts/SurfaceType.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;

public class SurfaceType
{
	public uint value;
	public bool NoFallDamage = false;
	public bool Slick = false;
	public bool Sky = false;
	public bool Ladder = false;
	public bool NoImpact = false;
	public bool NoMarks = false;
	public bool Flesh = false;
	public bool NoDraw = false;
	public bool Hint = false;
	public bool Skip = false;
	public bool NoLightMap = false;
	public bool PointLight = false;
	public bool MetalSteps = false;
	public bool NoSteps = false;
	public bool NonSolid = false;
	public bool LightFilter = false;
	public bool AlphaShadow = false;
	public bool NoDynLight = false;

	public void Init(uint surfaceType)
	{
		value = surfaceType;
		if ((surfaceType & SurfaceFlags.NoFallDamage) != 0)
			NoFallDamage = true;
		if ((surfaceType & SurfaceFlags.Slick) != 0)
			Slick = true;
		if ((surfaceType & SurfaceFlags.Sky) != 0)
			Sky = true;
		if ((surfaceType & SurfaceFlags.Ladder) != 0)
			Ladder = true;
		if ((surfaceType & SurfaceFlags.NoImpact) != 0)
			NoImpact = true;
		if ((surfaceType & SurfaceFlags.NoMarks) != 0)
			NoMarks = true;
		if ((surfaceType & SurfaceFlags.Flesh) != 0)
			Flesh = true;
		if ((surfaceType & SurfaceFlags.NoDraw) != 0)
			NoDraw = true;
		if ((surfaceType & SurfaceFlags.Hint) != 0)
			Hint = true;
		if ((surfaceType & SurfaceFlags.Skip) != 0)
			Skip = true;
		if ((surfaceType & SurfaceFlags.NoLightMap) != 0)
			NoLightMap = true;
		if ((surfaceType & SurfaceFlags.PointLight) != 0)
			PointLight = true;
		if ((surfaceType & SurfaceFlags.MetalSteps) != 0)
			MetalSteps = true;
		if ((surfaceType & SurfaceFlags.NoSteps) != 0)
			NoSteps = true;
		if ((surfaceType & SurfaceFlags.NonSolid) != 0)
			NonSolid = true;
		if ((surfaceType & SurfaceFlags.LightFilter) != 0)
			LightFilter = true;
		if ((surfaceType & SurfaceFlags.AlphaShadow) != 0)
			AlphaShadow = true;
		if ((surfaceType & SurfaceFlags.NoDynLight) != 0)
			NoDynLight = true;
	}
}```

./Assets/Scripts/ScoreBoard.cs:
```
using Godot;
using System.Collections.Generic;
using System.Linq;
public partial class ScoreBoard : Node3D
{
	public static ScoreBoard Instance = null;
	[Export]
	public Node3D RootScore;
	[Export]
	public PackedScene playerScore;
	[Export]
	public Sprite3D medalImpressiveIcon;
	[Export]
	public Sprite3D medalGauntletIcon;
	[Export]
	public Sprite3D medalExcellentIcon;

	public List<PlayerScore> ScoreList = new List<PlayerScore>();
	public List<PlayerData> playerDatas = new List<PlayerData>();

	private static readonly string medalImpressive = "MENU/MEDALS/MEDAL_IMPRESSIVE";
	private static readonly string medalGauntlet = "MENU/MEDALS/MEDAL_GAUNTLET";
	private static readonly string medalExcellent = "MENU/MEDALS/MEDAL_EXCELLENT";
	//Fixed Medal Size
	private static int defaultMedalSize = 64;
	public override void _Ready()
	{
		Instance = this;
		medalImpressiveIcon.Texture = TextureLoader.GetTextureOrAddTexture(medalImpressive, false, false);
		TextureLoader.AdjustIconSize(medalImpressiveIcon, defaultMedalSize);

		medalGauntletIcon.Texture = TextureLoader.GetTextureOrAddTexture(medalGauntlet, false, false);
		TextureLoader.AdjustIconSize(medalGauntletIcon, defaultMedalSize);

		medalExcellentIcon.Texture = TextureLoader.GetTextureOrAddTexture(medalExcellent, false, false);
		TextureLoader.AdjustIconSize(medalExcellentIcon, defaultMedalSize);
	}

	public void AddPlayer(PlayerThing player)
	{
		PlayerScore PlayerScore = (PlayerScore)playerScore.Instantiate();
		PlayerScore.Position = Vector3.Down * ScoreList.Count * .22f;
		RootScore.AddChild(PlayerScore);
		ScoreList.Add(PlayerScore);
		PlayerData playerData = new PlayerData(player);
		playerData.Name = playerData.Name.Substring(0, Mathf.Min(14, playerData.Name.Length));
		playerDatas.Add(playerData);
		RefreshScore();
	}

	public void RemovePlayer(int playerNum)
	{
		int scoreCount = ScoreList.Count();
		ScoreList[scoreCount - 1].QueueFree();
		ScoreList.RemoveAt(scoreCount - 1);
		playerDatas.RemoveAt(playerNum);
		RefreshScore();
	}

	public void RefreshScore()
	{
		for (int i = 0; i < playerDatas.Count; i++)
		{
			playerDatas[i].Kills = playerDatas[i].player.frags;
			playerDatas[i].Deaths = playerDatas[i].player.deaths;
		}


		List<PlayerData> newData = playerDatas.OrderByDescending(x =>  x.Kills ).ToList();
		for (int i = 0; i < newData.Count; i++) 
		{
			ScoreList[i].PlayerName.Text = newData[i].Name;
			if (newData[i].Kills > 0)
				ScoreList[i].Kills.Text= "+" + newData[i].Kills;
			if (newData[i].Deaths > 0)
				ScoreList[i].Deaths.Text = "-" + newData[i].Deaths;
			ScoreList[i].Impressive.Text = "" + newData[i].Impressive;
			ScoreList[i].Gauntlet.Text = "" + newData[i].Gauntlet;
			ScoreList[i].Excellent.Text = "" + newData[i].Excellent;
		}
	}


	public class PlayerData
	{
		public PlayerThing player;
		public string Name = "Unnamed Player";
		public int Kills = 0;
		public int Deaths = 0;
		public int Impressive = 0;
		public int Gauntlet = 0;
		public int Excellent = 0;
		public int AvgLifeTime = 0;

		public PlayerData(PlayerThing player)
		{
			this.player = player;
			this.Name = player.playerName;
		}

	}
}
```

./Assets/Scripts/BSP Loader/ConvexHull2D.cs:
```
/* MIT License

Copyright (c) 2020 Erik Nordeus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


erik.nordeus@gmail.com
https://github.com/Habrador/Computational-geometry
*/

using Godot;
using System.Collections.Generic;
using System.Linq;
public static class ConvexHull2D
{
	public static float GetPointInRelationToVectorValue(Vector2 a, Vector2 b, Vector2 p)
	{
		float x1 = a.X - p.X;
		float x2 = a.Y - p.Y;
		float y1 = b.X - p.X;
		float y2 = b.Y - p.Y;

		float determinant = x1 * y2 - y1 * x2;

		return determinant;
	}

	public static int IsPoint_Left_On_Right_OfVector(Vector2 a, Vector2 b, Vector2 p)
	{
		float relationValue = GetPointInRelationToVectorValue(a, b, p);
		float epsilon = Mathf.Epsilon;

		if (relationValue < -epsilon)
			return 1;
		else if (relationValue > epsilon)
			return -1;
		else
			return 0;
	}
	public static List<Vector2> GenerateConvexHull(List<Vector2> points)
	{
		List<Vector2> pointsOnConvexHull = new List<Vector2>();
		Vector2 startPos = points[0];

		for (int i = 1; i < points.Count; i++)
		{
			Vector2 testPos = points[i];
			if (testPos.X < startPos.X || ((Mathf.Abs(testPos.X - startPos.X) < Mathf.Epsilon && testPos.Y < startPos.Y)))
				startPos = points[i];
		}

		pointsOnConvexHull.Add(startPos);
		Vector2 previousPoint = pointsOnConvexHull[0];
		int counter = 0;
		for (;  counter < 100000; counter++)
		{
			List<Vector2> pointsToAddToTheHull = new List<Vector2>();
			Vector2 nextPoint = points[GD.RandRange(0, points.Count - 1)];
			if (previousPoint.Equals(pointsOnConvexHull[0]) && nextPoint.Equals(pointsOnConvexHull[0]))
				continue;
			

			pointsToAddToTheHull.Add(nextPoint);
			for (int i = 0; i < points.Count; i++)
			{
				Vector2 testPoint = points[i];

				if (testPoint.Equals(nextPoint) || testPoint.Equals(previousPoint))
					continue;

				int pointRelation = IsPoint_Left_On_Right_OfVector(previousPoint, nextPoint, testPoint);

				if (pointRelation == 0)
					pointsToAddToTheHull.Add(testPoint);
				else if (pointRelation == 1)
				{
					nextPoint = testPoint;
					pointsToAddToTheHull.Clear();
					pointsToAddToTheHull.Add(nextPoint);
				}
			}
			pointsToAddToTheHull = pointsToAddToTheHull.OrderBy(n => (n - previousPoint).LengthSquared()).ToList();
			pointsOnConvexHull.AddRange(pointsToAddToTheHull);
			previousPoint = pointsOnConvexHull[pointsOnConvexHull.Count - 1];
			if (previousPoint.Equals(pointsOnConvexHull[0]))
			{
				pointsOnConvexHull.RemoveAt(pointsOnConvexHull.Count - 1);
				break;
			}
		}
		if (counter == 100000)
		{
			GameManager.Print("Stuck in Endless Loop when generating 2d Convex Hull with Jarvis March", GameManager.PrintType.Warning);
			return new List<Vector2>();
		}

		return pointsOnConvexHull;
	}
}
```

./Assets/Scripts/BSP Loader/Classes.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;
public static class QuakeToGodot
{
	public static Vector3 Vect3(Vector3 inV3, bool scale = true)
	{
		Vector3 outV3 = new Vector3(-inV3.X, inV3.Z, inV3.Y);
		if (scale)
			outV3 *= GameManager.sizeDividor;
		return outV3;
	}
	public static Vector3 Vect3(Vector3I inV3, bool scale = true)
	{
		Vector3 outV3 = new Vector3(-inV3.X, inV3.Z, inV3.Y);
		if (scale)
			outV3 *= GameManager.sizeDividor;
		return outV3;
	}
}
public class QShader
{

	public string name;                 // The name of the texture w/o the extension 
	public uint surfaceFlags;			// The surface flags
	public uint contentsFlags;          // The content flags
	public bool addAlpha;               // Shader add Alpha 
	public QShader(string name, uint surfaceFlags, uint contentsFlags, bool addAlpha)
	{
		this.name = name;
		this.surfaceFlags = surfaceFlags;
		this.contentsFlags = contentsFlags;
		this.addAlpha = addAlpha;
	}
}
public class QNode
{
	public int plane;                   // The index into the planes array 
	public int front;                   // The child index for the front node 
	public int back;                    // The child index for the back node 
	public Vector3 bb_Min;              // The bounding box min position. 
	public Vector3 bb_Max;              // The bounding box max position.
	public QNode(int plane, int front, int back, Vector3I bb_Min, Vector3I bb_Max)
	{
		this.plane = plane;
		this.front = front;
		this.back = back;
		this.front = front;
		this.bb_Min = QuakeToGodot.Vect3(bb_Min);
		this.bb_Max = QuakeToGodot.Vect3(bb_Max);
	}
}
public class QLeaf
{
	public int cluster;                 // The visibility cluster 
	public int area;                    // The area portal 
	public Vector3 bb_Min;              // The bounding box min position 
	public Vector3 bb_Max;              // The bounding box max position 
	public int leafSurface;             // The first index into the surface array 
	public int numOfLeafFaces;          // The number of faces for this leaf 
	public int leafBrush;               // The first index for into the brushes 
	public int numOfLeafBrushes;        // The number of brushes for this leaf
	public QLeaf(int cluster, int area, Vector3I bb_Min, Vector3I bb_Max, int leafSurface, int numOfLeafFaces,
				int leafBrush, int numOfLeafBrushes)
	{
		this.cluster = cluster;
		this.area = area;
		this.leafSurface = leafSurface;
		this.numOfLeafFaces = numOfLeafFaces;
		this.leafBrush = leafBrush;
		this.numOfLeafBrushes = numOfLeafBrushes;
		this.bb_Min = QuakeToGodot.Vect3(bb_Min);
		this.bb_Max = QuakeToGodot.Vect3(bb_Max);
	}
};

public class QModel
{
	public Vector3 bb_Min;              // The bounding box min position 
	public Vector3 bb_Max;              // The bounding box max position 
	public int firstSurface;            // The starting index into the surface array 
	public int numSurfaces;             // The number of surface for this geometry 
	public int firstBrush;              // The starting brush for the geometry 
	public int numBrushes;              // Number of brush for the geometry

	public QModel(Vector3 bb_Min, Vector3 bb_Max, int firstSurface, int numSurfaces, int firstBrush, int numBrushes)
	{
		this.firstSurface = firstSurface;
		this.numSurfaces = numSurfaces;
		this.firstBrush = firstBrush;
		this.numBrushes = numBrushes;
		this.bb_Min = bb_Min; //QuakeToGodot.Vect3(bb_Min);
		this.bb_Max = bb_Max; //QuakeToGodot.Vect3(bb_Max);
	}
};

public class QBrush
{
	public int brushSide;				// The starting brush side for the brush 
	public int numOfBrushSides;			// Number of brush sides for the brush
	public int shaderId;				// The shader index for the brush
	public QBrush(int brushSide, int numOfBrushSides, int shaderId)
	{
		this.brushSide = brushSide;
		this.numOfBrushSides = numOfBrushSides;
		this.shaderId = shaderId;
	}
};

public class QBrushSide
{
	public int plane;					// The plane index
	public int shaderId;				// The shader index
	public QBrushSide(int plane, int shaderId)
	{
		this.plane = plane;
		this.shaderId = shaderId;
	}
};

public class QVisData
{
	public int numOfClusters;           // The number of clusters
	public int bytesPerCluster;         // The amount of bytes (8 bits) in the cluster's bitset
	public byte[] bitSets;              // The array of bytes that holds the cluster bitsets

	public QVisData(int numOfClusters, int bytesPerCluster)
	{
		this.numOfClusters = numOfClusters;
		this.bytesPerCluster = bytesPerCluster;
	}
};
public class QVertex
{
	public int vertId;                  // The index of this vertex
	public Vector3 position;            // (x, y, z) position. 
	public Vector2 textureCoord;        // (u, v) texture coordinate
	public Vector2 lightmapCoord;       // (u, v) lightmap coordinate
	public Vector3 normal;              // (x, y, z) normal vector	
	public Color color;					// RGBA color for the vertex 

	public QVertex(int vertId, Vector3 position, float texX, float texY, float lmX, float lmY, Vector3 normal, byte[] color)
	{
		this.vertId = vertId;
		this.position = QuakeToGodot.Vect3(position);
		this.normal = QuakeToGodot.Vect3(normal, false);

		this.color = new Color(color[0] / 255.0f, color[1] / 255.0f, color[2] / 255.0f, color[3] / 255.0f);

		textureCoord.X = texX;
		textureCoord.Y = texY;

		// Lightmaps are created dynamically
		lightmapCoord.X = lmX;
		lightmapCoord.Y = lmY;
	}
}
public class QFog
{
	public string name;				// The name of the shader of this effect 
	public int brushNum;			// The brush that generated this effect
	public int reserved;			// Reserved
	public QFog(string name, int brushNum, int reserved)
	{
		this.name = name;
		this.brushNum = brushNum;
		this.reserved = reserved;
	}
}

public class QSurface
{
	public int surfaceId;               // The index of this surface
	public int shaderId;                // The index into the shader array 
	public int effect;                  // The index for the effects (or -1 = n/a) 
	public int type;                    // 1=polygon, 2=patch, 3=mesh, 4=billboard 
	public int startVertIndex;          // The starting index into this surface's first vertex 
	public int numOfVerts;              // The number of vertices for this surface 
	public int startIndex;              // The starting index into the indices array for this surface
	public int numOfIndices;            // The number of indices for this surface
	public int lightMapID;              // The texture index for the lightmap 
	public int[] lm_Corner;             // The surface's lightmap corner in the image 
	public int[] lm_Size;               // The size of the lightmap section 
	public Vector3 lm_Origin;           // The 3D origin of lightmap. 
	public Vector3[] lm_vecs;           // The 3D space for s and t unit vectors. 
	public Vector3 normal;              // The surface normal. 
	public int[] size;                  // The bezier patch dimensions. 

	public QSurface(int surfaceId, int shaderId, int effect, int type, int startVertIndex, int numOfVerts, int startIndex, int numOfIndices,
		int lightMapID, int[] lm_Corner, int[] lm_Size, Vector3 lm_Origin, Vector3[] lm_vecs, Vector3 normal,
		int[] size)
	{
		this.surfaceId = surfaceId;
		this.shaderId = shaderId;
		this.effect = effect;
		this.type = type;
		this.startVertIndex = startVertIndex;
		this.numOfVerts = numOfVerts;
		this.startIndex = startIndex;
		this.numOfIndices = numOfIndices;
		this.lightMapID = lightMapID;
		this.lm_Corner = lm_Corner;
		this.lm_Size = lm_Size;
		this.lm_Origin = QuakeToGodot.Vect3(lm_Origin);
		this.lm_vecs = lm_vecs;
		this.normal = QuakeToGodot.Vect3(normal, false);
		this.size = size;
	}
}
public class QSurfaceType
{
	public const short None = 0;
	public const short Polygon = 1;
	public const short Patch = 2;
	public const short Mesh = 3;
	public const short Billboard = 4;
}

public class LumpType
{
	public const short Entities = 0;
	public const short Shaders = 1;
	public const short Planes = 2;
	public const short Nodes = 3;
	public const short Leafs = 4;
	public const short LeafSurfaces = 5;
	public const short LeafBrushes = 6;
	public const short Models = 7;
	public const short Brushes = 8;
	public const short BrushSides = 9;
	public const short Vertexes = 10;
	public const short VertIndices = 11;
	public const short Effects = 12;
	public const short Surfaces = 13;
	public const short LightMaps = 14;
	public const short LightGrid = 15;
	public const short VisData = 16;
}

public class ContentFlags
{
	public const uint Solid = 0x000001;				// Blocking surface
	public const uint Lava = 0x000008;				// Block and lava effects
	public const uint Slime = 0x000010;				// Block and slime effects
	public const uint Water = 0x000020;				// Non Blocking change physics
	public const uint Fog = 0x000040;				// Non Blocking Fog effect
	public const uint AreaPortal = 0x008000;		// Trigger Teleporter
	public const uint PlayerClip = 0x010000;
	public const uint MonsterClip = 0x020000;

	public const uint Teleporter = 0x040000;		// Bots info
	public const uint JumpPad = 0x080000;			// Jump Pad
	public const uint ClusterPortal = 0x100000;		// Bots info
	public const uint BotsNotEnter = 0x200000;		// Restricter area for Bots

	public const uint Origin = 0x1000000;

	public const uint Body = 0x2000000;				// Never on BSP
	public const uint Corpse = 0x4000000;
	public const uint Details = 0x8000000;			// Not used on BSP
	public const uint Structural = 0x10000000;		// Used on BSP 
	public const uint Translucent = 0x20000000;
	public const uint Trigger = 0x40000000;
	public const uint NoDrop = 0x80000000;			//Don't leave bodies or items
}
public class SurfaceFlags
{
	public const int NoFallDamage = 0x00001;		// Don't give falling damage
	public const int Slick = 0x00002;				// Affects game physics
	public const int Sky = 0x00004;					// Lighting from environment map
	public const int Ladder = 0x00008;				// Surface is climbable
	public const int NoImpact = 0x00010;			// No missile explosions
	public const int NoMarks = 0x00020;				// No missile marks
	public const int Flesh = 0x00040;				// Flesh sounds and effects
	public const int NoDraw = 0x00080;				// Don't generate a drawsurface at all
	public const int Hint = 0x00100;
	public const int Skip = 0x00200;				// Ignore, allowing non-closed brushes
	public const int NoLightMap = 0x00400;			// Don't add lightmap to surface
	public const int PointLight = 0x00800;			// Generate lighting info at verts
	public const int MetalSteps = 0x01000;			// Metal sounds and effects
	public const int NoSteps = 0x02000;				// No step sounds
	public const int NonSolid = 0x04000;			// No Collision
	public const int LightFilter = 0x08000;			// Act as a light filter during map compiling
	public const int AlphaShadow = 0x10000;			// Map compiling do per-pixel light shadow casting 
	public const int NoDynLight = 0x20000;			// Don't add dynamic lights
}```

./Assets/Scripts/BSP Loader/BezierMesh.cs:
```
using Godot;
using System.Collections.Generic;
using ExtensionMethods;
public static class BezierMesh
{
	private static List<Vector3> vertsCache = new List<Vector3>();
	private static List<Vector2> uvCache = new List<Vector2>();
	private static List<Vector2> uv2Cache = new List<Vector2>();
	private static List<Vector3> normalsCache = new List<Vector3>();
	private static List<Color> vertsColor = new List<Color>();
	private static List<int> indiciesCache = new List<int>();

	private const int VertexInd = (int)Mesh.ArrayType.Vertex;
	private const int TexUVInd = (int)Mesh.ArrayType.TexUV;
	private const int TexUV2Ind = (int)Mesh.ArrayType.TexUV2;
	private const int ColorInd = (int)Mesh.ArrayType.Color;
	private const int TriIndex = (int)Mesh.ArrayType.Index;

	private static List<Vector3> vertsLocalCache = new List<Vector3>();
	private static List<Vector2> uvLocalCache = new List<Vector2>();
	private static List<Vector2> uv2LocalCache = new List<Vector2>();
	private static List<Color> vertsLocalColor = new List<Color>();
	private static List<int> indiciesLocalCache = new List<int>();

	private static List<Vector3> p0sCache = new List<Vector3>();
	private static List<Vector2> p0suvLocalCache = new List<Vector2>();
	private static List<Vector2> p0suv2LocalCache = new List<Vector2>();
	private static List<Color> p0svertsLocalColor = new List<Color>();

	private static List<Vector3> p1sCache = new List<Vector3>();
	private static List<Vector2> p1suvLocalCache = new List<Vector2>();
	private static List<Vector2> p1suv2LocalCache = new List<Vector2>();
	private static List<Color> p1svertsLocalColor = new List<Color>();

	private static List<Vector3> p2sCache = new List<Vector3>();
	private static List<Vector2> p2suvLocalCache = new List<Vector2>();
	private static List<Vector2> p2suv2LocalCache = new List<Vector2>();
	private static List<Color> p2svertsLocalColor = new List<Color>();
	public enum Axis
	{
		None,
		X,
		Y,
		Z
	}
	public static void ClearCaches()
	{
		vertsCache = new List<Vector3>();
		uvCache = new List<Vector2>();
		uv2Cache = new List<Vector2>();
		normalsCache = new List<Vector3>();
		vertsColor = new List<Color>();
		indiciesCache = new List<int>();
	}
	public static void GenerateBezierMesh(int level, List<Vector3> control, List<Vector2> controlUvs, List<Vector2> controlUv2s, List<Color> controlColor, ref int offset)
	{
		// We'll use these two to hold our verts, tris, and uvs
		int capacity = level * level + (2 * level);
		if (vertsLocalCache.Capacity < capacity)
		{
			vertsLocalCache.Capacity = capacity;
			uvLocalCache.Capacity = capacity;
			uv2LocalCache.Capacity = capacity;
			indiciesLocalCache.Capacity = capacity;
			vertsLocalColor.Capacity = capacity;
		}

		if (offset == 0)
		{
			vertsCache.Clear();
			uvCache.Clear();
			uv2Cache.Clear();
			normalsCache.Clear();
			vertsColor.Clear();
			indiciesCache.Clear();
		}

		vertsLocalCache.Clear();
		uvLocalCache.Clear();
		uv2LocalCache.Clear();
		indiciesLocalCache.Clear();
		vertsLocalColor.Clear();


		p0sCache.Clear();
		p0suvLocalCache.Clear();
		p0suv2LocalCache.Clear();
		p0svertsLocalColor.Clear();

		p1sCache.Clear();
		p1suvLocalCache.Clear();
		p1suv2LocalCache.Clear();
		p1svertsLocalColor.Clear();

		p2sCache.Clear();
		p2suvLocalCache.Clear();
		p2suv2LocalCache.Clear();
		p2svertsLocalColor.Clear();

		// The incoming list is 9 entires, 
		// referenced as p0 through p8 here.

		// Generate extra rows to tessellate
		// each row is three control points
		// start, curve, end
		// The "lines" go as such
		// p0s from p0 to p3 to p6 ''
		// p1s from p1 p4 p7
		// p2s from p2 p5 p8

		Tessellate(level, control[0], control[3], control[6], p0sCache);
		TessellateUV(level, controlUvs[0], controlUvs[3], controlUvs[6], p0suvLocalCache);
		TessellateUV(level, controlUv2s[0], controlUv2s[3], controlUv2s[6], p0suv2LocalCache);
		TessellateColor(level, controlColor[0], controlColor[3], controlColor[6], p0svertsLocalColor);

		Tessellate(level, control[1], control[4], control[7], p1sCache);
		TessellateUV(level, controlUvs[1], controlUvs[4], controlUvs[7], p1suvLocalCache);
		TessellateUV(level, controlUv2s[1], controlUv2s[4], controlUv2s[7], p1suv2LocalCache);
		TessellateColor(level, controlColor[1], controlColor[4], controlColor[7], p1svertsLocalColor);

		Tessellate(level, control[2], control[5], control[8], p2sCache);
		TessellateUV(level, controlUvs[2], controlUvs[5], controlUvs[8], p2suvLocalCache);
		TessellateUV(level, controlUv2s[2], controlUv2s[5], controlUv2s[8], p2suv2LocalCache);
		TessellateColor(level, controlColor[2], controlColor[5], controlColor[8], p2svertsLocalColor);

		// Tessellate all those new sets of control points and pack
		// all the results into our vertex array, which we'll return.
		for (int i = 0; i <= level; i++)
		{
			Tessellate(level, p0sCache[i], p1sCache[i], p2sCache[i], vertsLocalCache);
			TessellateUV(level, p0suvLocalCache[i], p1suvLocalCache[i], p2suvLocalCache[i], uvLocalCache);
			TessellateUV(level, p0suv2LocalCache[i], p1suv2LocalCache[i], p2suv2LocalCache[i], uv2LocalCache);
			TessellateColor(level, p0svertsLocalColor[i], p1svertsLocalColor[i], p2svertsLocalColor[i], vertsLocalColor);
		}

		// This will produce (tessellationLevel + 1)^2 verts
		int numVerts = (level + 1) * (level + 1);

		// Compute triangle indexes for forming a mesh.
		// The mesh will be tessellationlevel + 1 verts
		// wide and tall.
		int xStep = 1;
		int width = level + 1;
		for (int i = 0; i < numVerts - width; i++)
		{
			//on left edge
			if (xStep == 1)
			{
				indiciesLocalCache.Add(i);
				indiciesLocalCache.Add(i + width);
				indiciesLocalCache.Add(i + 1);

				xStep++;
			}
			else if (xStep == width) //on right edge
			{
				indiciesLocalCache.Add(i);
				indiciesLocalCache.Add(i + (width - 1));
				indiciesLocalCache.Add(i + width);

				xStep = 1;
			}
			else // not on an edge, so add two
			{
				indiciesLocalCache.Add(i);
				indiciesLocalCache.Add(i + (width - 1));
				indiciesLocalCache.Add(i + width);


				indiciesLocalCache.Add(i);
				indiciesLocalCache.Add(i + width);
				indiciesLocalCache.Add(i + 1);

				xStep++;
			}
		}

		vertsCache.AddRange(vertsLocalCache);
		uvCache.AddRange(uvLocalCache);
		uv2Cache.AddRange(uv2LocalCache);
		vertsColor.AddRange(vertsLocalColor);

		int indicies = indiciesLocalCache.Count;
		for (int i = 0; i < indicies; i++)
			indiciesCache.Add(indiciesLocalCache[i] + offset);

		offset += vertsLocalCache.Count;
	}

	public static void BezierColliderMesh(uint ownerShapeId, CollisionObject3D collider, int surfaceId, int patchNumber, List<Vector3> control)
	{
		const int colliderTessellations = 4;  //Do not modify

		float step, s, f, m;
		int iterOne = colliderTessellations, interTwo = colliderTessellations;
		bool Collinear, allCollinear = false;

		// We'll use these two to hold our verts
		int capacity = control.Count;
		if (vertsLocalCache.Capacity < capacity)
			vertsLocalCache.Capacity = capacity;

		//Check if control points rows are collinear
		{
			p0sCache.Clear();
			p1sCache.Clear();
			p2sCache.Clear();

			for (int i = 0; i < 3; i++)
			{
				p0sCache.Add(control[i]);
				p1sCache.Add(control[3 + i]);
				p2sCache.Add(control[6 + i]);
			}

			Collinear = ArePointsCollinear(p0sCache);
			Collinear &= ArePointsCollinear(p1sCache);
			Collinear &= ArePointsCollinear(p2sCache);
		}

		//Check if control points columns are collinear
		if (!Collinear)
		{
			p0sCache.Clear();
			p1sCache.Clear();
			p2sCache.Clear();

			for (int i = 0; i < 3; i++)
			{
				p0sCache.Add(control[3 * i]);
				p1sCache.Add(control[(3 * i) + 1]);
				p2sCache.Add(control[(3 * i) + 2]);
			}

			Collinear = ArePointsCollinear(p0sCache);
			Collinear &= ArePointsCollinear(p1sCache);
			Collinear &= ArePointsCollinear(p2sCache);
		}
		else //Check if all control points are collinear
		{
			allCollinear = true;
			for (int j = 0; j < 3; j++)
			{
				vertsLocalCache.Clear();
				for (int i = 0; i < 3; i++)
					vertsLocalCache.Add(control[(3 * i) + j]);
				allCollinear &= ArePointsCollinear(vertsLocalCache);
				if (!allCollinear)
					break;
			}
			if (allCollinear)
			{
				interTwo = 1;
				vertsLocalCache.Clear();
				for (int i = 0; i < capacity; i++)
					vertsLocalCache.Add(control[i]);
			}
		}

		step = 1f / colliderTessellations;

		if (Collinear)
			iterOne = 1;

		for (int i = 0; i < iterOne; i++)
		{
			if (!Collinear)
			{
				s = i * step;
				f = (i + 1) * step;
				m = (s + f) / 2f;
				p0sCache.Clear();
				p1sCache.Clear();
				p2sCache.Clear();

				//Top row
				p0sCache.Add(BezCurve(s, control[0], control[1], control[2]));
				p0sCache.Add(BezCurve(m, control[0], control[1], control[2]));
				p0sCache.Add(BezCurve(f, control[0], control[1], control[2]));

				//Middle row
				p1sCache.Add(BezCurve(s, control[3], control[4], control[5]));
				p1sCache.Add(BezCurve(m, control[3], control[4], control[5]));
				p1sCache.Add(BezCurve(f, control[3], control[4], control[5]));

				//Bottom row
				p2sCache.Add(BezCurve(s, control[6], control[7], control[8]));
				p2sCache.Add(BezCurve(m, control[6], control[7], control[8]));
				p2sCache.Add(BezCurve(f, control[6], control[7], control[8]));
			}

			for (int j = 0; j < interTwo; j++)
			{
				if (!allCollinear)
				{
					s = j * step;
					f = (j + 1) * step;
					m = (s + f) / 2f;
					vertsLocalCache.Clear();

					//Top row
					vertsLocalCache.Add(BezCurve(s, p0sCache[0], p1sCache[0], p2sCache[0]));
					vertsLocalCache.Add(BezCurve(m, p0sCache[0], p1sCache[0], p2sCache[0]));
					vertsLocalCache.Add(BezCurve(f, p0sCache[0], p1sCache[0], p2sCache[0]));

					//Middle row
					vertsLocalCache.Add(BezCurve(s, p0sCache[1], p1sCache[1], p2sCache[1]));
					vertsLocalCache.Add(BezCurve(m, p0sCache[1], p1sCache[1], p2sCache[1]));
					vertsLocalCache.Add(BezCurve(f, p0sCache[1], p1sCache[1], p2sCache[1]));

					//Bottom row
					vertsLocalCache.Add(BezCurve(s, p0sCache[2], p1sCache[2], p2sCache[2]));
					vertsLocalCache.Add(BezCurve(m, p0sCache[2], p1sCache[2], p2sCache[2]));
					vertsLocalCache.Add(BezCurve(f, p0sCache[2], p1sCache[2], p2sCache[2]));
				}
				Vector3 normal = Vector3.Zero;
				List<Vector3> vertsCleanLocalCache = Mesher.RemoveDuplicatedVectors(vertsLocalCache);
				if (!Mesher.CanForm3DConvexHull(vertsCleanLocalCache, ref normal, 0.00015f))
				{
					if (normal.LengthSquared() == 0)
					{
						GameManager.Print("BezierColliderMesh: Cannot Form 2D/3D ConvexHull " + surfaceId + "_" + patchNumber + " this was a waste of time", GameManager.PrintType.Warning);
						return;
					}
					Axis axis;
					Quaternion changeRotation = Quaternion.Identity;
					List<Vector2> vertex2d = new List<Vector2>();
					if ((normal.X == 1) || (normal.X == -1))
						axis = Axis.X;
					else if ((normal.Y == 1) || (normal.Y == -1))
						axis = Axis.Y;
					else if ((normal.Z == 1) || (normal.Z == -1))
						axis = Axis.Z;
					else
					{
						float x = Mathf.Abs(normal.X), y = Mathf.Abs(normal.Y), z = Mathf.Abs(normal.Z);
						Vector3 normalRef = Vector3.Zero;

						if ((x >= y) && (x >= z))
							axis = Axis.X;
						else if ((y >= x) && (y >= z))
							axis = Axis.Y;
						else
							axis = Axis.Z;

						switch (axis)
						{
							case Axis.X:
								if (normal.X > 0)
									normalRef = Vector3.Right;
								else
									normalRef = Vector3.Left;
							break;
							case Axis.Y:
								if (normal.Y > 0)
									normalRef = Vector3.Up;
								else
									normalRef = Vector3.Down;
							break;
							case Axis.Z:
								if (normal.Z > 0)
									normalRef = Vector3.Back;
								else
									normalRef = Vector3.Forward;
							break;
						}
						changeRotation.CalculateRotation(normal, normalRef);
					}
					//Check if it's a 2D Surface
					float Offset = 0;
					for (int k = 0; k < vertsCleanLocalCache.Count; k++)
					{
						Vector3 vertex = changeRotation * vertsCleanLocalCache[k];
						switch (axis)
						{
							case Axis.X:
								vertex2d.Add(new Vector2(vertex.Y, vertex.Z));
								Offset += vertex.X;
							break;
							case Axis.Y:
								vertex2d.Add(new Vector2(vertex.X, vertex.Z));
								Offset += vertex.Y;
							break;
							case Axis.Z:
								vertex2d.Add(new Vector2(vertex.X, vertex.Y));
								Offset += vertex.Z;
							break;
						}
					}
					Offset /= vertsCleanLocalCache.Count;
					vertex2d = ConvexHull2D.GenerateConvexHull(vertex2d);
					if (vertex2d.Count == 0)
					{
						GameManager.Print("BezierColliderMesh: Cannot Form 2D ConvexHull " + surfaceId + "_" + patchNumber + " this was a waste of time", GameManager.PrintType.Warning);
						return;
					}
					changeRotation = changeRotation.Inverse();
					vertsCleanLocalCache.Clear();
					for (int k = 0; k < vertex2d.Count; k++)
					{
						Vector3 vertex3d;
						switch (axis)
						{
							default:
							case Axis.X:
								vertex3d = new Vector3(Offset, vertex2d[k].X, vertex2d[k].Y);
							break;
							case Axis.Y:
								vertex3d = new Vector3(vertex2d[k].X, Offset, vertex2d[k].Y);
							break;
							case Axis.Z:
								vertex3d = new Vector3(vertex2d[k].X, vertex2d[k].Y, Offset);
							break;
						}
						vertex3d = changeRotation * vertex3d;
						vertsCleanLocalCache.Add(vertex3d);
					}
					vertsCleanLocalCache = Mesher.GetExtrudedVerticesFromPoints(Mesher.RemoveDuplicatedVectors(vertsCleanLocalCache), normal);
				}

				ConvexPolygonShape3D convexHull = new ConvexPolygonShape3D();
				convexHull.Points = vertsCleanLocalCache.ToArray();
				collider.ShapeOwnerAddShape(ownerShapeId, convexHull);
			}
		}

		return;
	}
	public static void FinalizeBezierMesh(ArrayMesh arrMesh)
	{
		// The mesh we're building
		var surfaceArray = new Godot.Collections.Array();
		surfaceArray.Resize((int)Mesh.ArrayType.Max);

		// Add the verts and tris
		surfaceArray[VertexInd] = vertsCache.ToArray();
		surfaceArray[TexUVInd] = uvCache.ToArray();
		surfaceArray[TexUV2Ind] = uv2Cache.ToArray();
		surfaceArray[ColorInd] = vertsColor.ToArray();
		surfaceArray[TriIndex] = indiciesCache.ToArray();

		// Create the Mesh.
		arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);

		// Tool needed to recalculate normals .
		SurfaceTool st = new SurfaceTool();
		st.CreateFrom(arrMesh, 0);
		st.GenerateNormals();
		st.GenerateTangents();
		arrMesh.ClearSurfaces();
		surfaceArray.Clear();
		surfaceArray = st.CommitToArrays();
		arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
	}
	//Check Collinear
	private static bool ArePointsCollinear(List<Vector3> points)
	{
		const float EPSILON = 0.00001f;

		if (points.Count < 3)
		{
			// Cannot have collinear points with less than 3 points
			return false;
		}

		Vector3 firstDirection = points[1] - points[0];
		for (int i = 2; i < points.Count; i++)
		{
			Vector3 currentDirection = points[i] - points[0];

			if (firstDirection.Cross(currentDirection).LengthSquared() > EPSILON)
			{
				// The cross product of the two vectors is non-zero, meaning they are not collinear
				return false;
			}
		}

		// All the points are collinear
		return true;
	}

	private static Vector2 BezCurveUV(float t, Vector2 p0, Vector2 p1, Vector2 p2)
	{
		float[] tPoints = new float[2];

		float a = 1f - t;
		float tt = t * t;

		for (int i = 0; i < 2; i++)
			tPoints[i] = a * a * p0[i] + 2 * a * (t * p1[i]) + tt * p2[i];

		Vector2 bezPoint = new Vector2(tPoints[0], tPoints[1]);

		return bezPoint;
	}

	// This time for colors
	private static Color BezCurveColor(float t, Color p0, Color p1, Color p2)
	{
		float[] tPoints = new float[4];

		float a = 1f - t;
		float tt = t * t;

		for (int i = 0; i < 4; i++)
			tPoints[i] = a * a * p0[i] + 2 * a * (t * p1[i]) + tt * p2[i];

		Color bezPoint = new Color(tPoints[0], tPoints[1], tPoints[2], tPoints[3]);

		return bezPoint;
	}

	// Calculate a vector3 at point t on a quadratic Bezier curve between
	// Using the formula B(t) = (1-t)^2 * p0 + 2 * (1-t) * t * p1 + t^2 * p2
	// p0 and p2 via p1.  
	private static Vector3 BezCurve(float t, Vector3 p0, Vector3 p1, Vector3 p2)
	{
		float[] tPoints = new float[3];

		float a = 1f - t;
		float tt = t * t;

		for (int i = 0; i < 3; i++)
			tPoints[i] = a * a * p0[i] + 2 * a * (t * p1[i]) + tt * p2[i];

		Vector3 bezPoint = new Vector3(tPoints[0], tPoints[1], tPoints[2]);

		return bezPoint;
	}

	// This takes a tessellation level and three vector3
	// p0 is start, p1 is the midpoint, p2 is the endpoint
	// The returned list begins with p0, ends with p2, with
	// the tessellated verts in between.
	private static void Tessellate(int level, Vector3 p0, Vector3 p1, Vector3 p2, List<Vector3> appendList = null)
	{
		if (appendList == null)
			appendList = new List<Vector3>(level + 1);

		float stepDelta = 1.0f / level;
		float step = stepDelta;

		appendList.Add(p0);
		for (int i = 0; i < level - 1; i++)
		{
			appendList.Add(BezCurve(step, p0, p1, p2));
			step += stepDelta;
		}
		appendList.Add(p2);
	}

	// Same as above, but for UVs
	private static void TessellateUV(int level, Vector2 p0, Vector2 p1, Vector2 p2, List<Vector2> appendList = null)
	{
		if (appendList == null)
			appendList = new List<Vector2>(level + 2);

		float stepDelta = 1.0f / level;
		float step = stepDelta;

		appendList.Add(p0);
		for (int i = 0; i < level - 1; i++)
		{
			appendList.Add(BezCurveUV(step, p0, p1, p2));
			step += stepDelta;
		}
		appendList.Add(p2);
	}

	// Same, but this time for colors
	private static void TessellateColor(int level, Color p0, Color p1, Color p2, List<Color> appendList = null)
	{
		if (appendList == null)
			appendList = new List<Color>(level + 1);

		float stepDelta = 1.0f / level;
		float step = stepDelta;

		appendList.Add(p0);
		for (int i = 0; i < level - 1; i++)
		{
			appendList.Add(BezCurveColor(step, p0, p1, p2));
			step += stepDelta;
		}
		appendList.Add(p2);
	}
}
```

./Assets/Scripts/Generic/DestroyAfterTime.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;
public partial class DestroyAfterTime : Node
{
	[Export]
	public float destroyTimer = 10;

	private Node parent;
	private GameManager.FuncState currentState = GameManager.FuncState.None;
	public override void _Ready()
	{
		currentState = GameManager.FuncState.Ready;
	}

	public void Start()
	{
		parent = GetParent();
		currentState = GameManager.FuncState.Start;
	}
	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		switch (currentState)
		{
			default:

				break;
			case GameManager.FuncState.Ready:
				Start();
				break;
		}
		float deltaTime = (float)delta;
		destroyTimer -= deltaTime;
		if (destroyTimer < 0)
			parent.QueueFree();

	}
}
```

./Assets/Scripts/Generic/PortalSurface.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;
using ExtensionMethods;

public partial class PortalSurface : Area3D
{
	public bool mirror = false;
	public string targetName;
	private List<Camera3D> destCamera = new List<Camera3D>();
	private List<SubViewport> viewPorts = new List<SubViewport>();
	private Portal destPortal;
	private float radius = 256 * GameManager.sizeDividor;
	private float radiusSquared;
	private List<PlayerThing> currentPlayers = new List<PlayerThing>();
	private Transform3D MirrorTransform;
	private Vector3 UpVector;
	private Vector2 MirrorSize;

	private bool InvertX = true;
	private bool InvertY = true;

	private enum Axis
	{
		None,
		X,
		Y,
		Z
	}
	public override void _Ready()
	{
		BodyEntered += OnBodyEntered;
		BodyExited += OnBodyExit;
		radiusSquared = radius * radius;
	}

	private Transform3D MirrorTransform3D(Vector3 n, Vector3 d)
	{
		Vector3 BasisX = new Vector3(1, 0, 0) - 2 * new Vector3(n.X * n.X, n.X * n.Y, n.X * n.Z);
		Vector3 BasisY = new Vector3(0, 1, 0) - 2 * new Vector3(n.Y * n.X, n.Y * n.Y, n.Y * n.Z);
		Vector3 BasisZ = new Vector3(0, 0, 1) - 2 * new Vector3(n.Z * n.X, n.Z * n.Y, n.Z * n.Z);

		Vector3 offset = 2 * n.Dot(d) * n;
		return new Transform3D(new Basis(BasisX, BasisY, BasisZ), offset);
	}

	public override void _Process(double delta)
	{
		for (int i = 0; i < currentPlayers.Count; i++) 
		{
			int playerNum = currentPlayers[i].playerInfo.localPlayerNum;
			viewPorts[playerNum].RenderTargetUpdateMode = SubViewport.UpdateMode.Once;
			Camera3D playerCamera = currentPlayers[i].playerInfo.playerCamera.CurrentCamera;
			Basis globalBasis = playerCamera.GlobalTransform.Basis;
			if (mirror)
			{
				destCamera[playerNum].GlobalTransform = MirrorTransform * playerCamera.GlobalTransform;
				Vector3 lookVector = destCamera[playerNum].GlobalPosition / 2 + playerCamera.GlobalPosition / 2;
				destCamera[playerNum].GlobalTransform = destCamera[playerNum].GlobalTransform.LookingAt(lookVector, UpVector);
				Vector3 offSet = GlobalPosition - destCamera[playerNum].GlobalPosition;
				float near = Mathf.Abs((offSet).Dot(destPortal.normal));
				near += 0.15f;

				Vector3 localCam = destCamera[playerNum].GlobalTransform.Basis.Inverse() * offSet;
				Vector2 frustumOffset = new Vector2(localCam.X, localCam.Y);
				destCamera[playerNum].SetFrustum(MirrorSize.X, frustumOffset, near, 4000);
			}
			else
			{
				float distanceSquared = (GlobalPosition - playerCamera.GlobalPosition).LengthSquared();
				float lenght = Mathf.Clamp(1.3f - (distanceSquared / radiusSquared), 0f, 1f);
				destPortal.surfaces[playerNum].material.SetShaderParameter("Transparency", lenght);
				destCamera[playerNum].Basis = globalBasis;
				ClusterPVSManager.CheckPVS(currentPlayers[i].playerInfo.viewLayer, destCamera[playerNum].GlobalPosition);
			}
		}
	}

	public void NewLocalPlayerAdded()
	{
		int index = destCamera.Count;
		Node3D parent = destCamera[0].GetParentNode3D();
		Camera3D camera = (Camera3D)destCamera[0].Duplicate();
		parent.AddChild(camera);
		destCamera.Add(camera);

		MeshInstance3D mesh = new MeshInstance3D();
		GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
		mesh.Layers = (uint)(1 << (GameManager.Player1ViewLayer + index));
		mesh.Mesh = destPortal.commonMesh;
		ShaderMaterial material = (ShaderMaterial)destPortal.commonMat.Duplicate(true);
		mesh.SetSurfaceOverrideMaterial(0, material);
		destPortal.surfaces.Add(new Portal.Surface(mesh, material));

		if (mirror)
		{
			destPortal.surfaces[index].material = MaterialManager.GetMirrorMaterial(destPortal.shaderName);
			destPortal.surfaces[index].baseMat.NextPass = destPortal.surfaces[index].material;
			if (!InvertX)
				destPortal.surfaces[index].material.SetShaderParameter("InvertX", 0);
			if (!InvertY)
				destPortal.surfaces[index].material.SetShaderParameter("InvertY", 0);

		}

		SubViewport viewport = new SubViewport();
		AddChild(viewport);

		if (mirror)
			viewport.Size = new Vector2I(Mathf.CeilToInt(320 * MirrorSize.X), Mathf.CeilToInt(320 * MirrorSize.Y));
		else
			viewport.Size = GameManager.Instance.viewPortSize;

		viewport.RenderTargetUpdateMode = SubViewport.UpdateMode.Once;
		viewport.HandleInputLocally = false;

		var CamRID = camera.GetCameraRid();
		var viewPortRID = viewport.GetViewportRid();
		RenderingServer.ViewportAttachCamera(viewPortRID, CamRID);

		destPortal.surfaces[index].material.SetShaderParameter("Tex_0", viewport.GetTexture());
		viewPorts.Add(viewport);
	}

	public void SetUpPortal(Camera3D camera, Portal portal, bool isMirror = false)
	{
		destCamera.Add(camera);
		destPortal = portal;
		Node3D parent = camera.GetParentNode3D();

		mirror = isMirror;
		if (mirror)
		{
			radius *= 2;
			GlobalPosition = portal.position;
			destPortal.surfaces[0].material = MaterialManager.GetMirrorMaterial(destPortal.shaderName);
			destPortal.surfaces[0].baseMat.NextPass = destPortal.surfaces[0].material;
			MirrorTransform = MirrorTransform3D(destPortal.normal, GlobalPosition);
			if (Mathf.IsZeroApprox(destPortal.normal.Dot(Vector3.Forward)))
				UpVector = Vector3.Forward;
			else
			{
				Vector3 normal = destPortal.normal.Cross(Vector3.Up);
				if (normal.LengthSquared() > 0)
					UpVector = Vector3.Up;
				else
					UpVector = Vector3.Forward;
			}
			MirrorSize = FillMirrorData();
			if (!InvertX)
				destPortal.surfaces[0].material.SetShaderParameter("InvertX", 0);
			if(!InvertY)
				destPortal.surfaces[0].material.SetShaderParameter("InvertY", 0);
		}
		else
			parent.Rotation += Transform3D.Identity.LookingAt(-destPortal.normal, Vector3.Up).Basis.GetEuler();

		CollisionShape3D mc = new CollisionShape3D();
		mc.Name = "Portal Area";
		AddChild(mc);
		CollisionLayer = (1 << GameManager.WalkTriggerLayer);
		CollisionMask = GameManager.TakeDamageMask;

		SphereShape3D sphere = new SphereShape3D();
		sphere.Radius = radius;
		mc.Shape = sphere;

		SubViewport viewport = new SubViewport();
		AddChild(viewport);

		if (mirror)
			viewport.Size = new Vector2I(Mathf.CeilToInt(320 * MirrorSize.X), Mathf.CeilToInt(320 * MirrorSize.Y));
		else
			viewport.Size = GameManager.Instance.viewPortSize;

		viewport.RenderTargetUpdateMode = SubViewport.UpdateMode.Once;
		viewport.HandleInputLocally = false;

		var CamRID = camera.GetCameraRid();
		var viewPortRID = viewport.GetViewportRid();
		RenderingServer.ViewportAttachCamera(viewPortRID, CamRID);

		destPortal.surfaces[0].material.SetShaderParameter("Tex_0", viewport.GetTexture());
		viewPorts.Add(viewport);
		for (int i = 1; i < GameManager.NumLocalPlayers; i++)
			NewLocalPlayerAdded();
	}

	private Vector2 FillMirrorData()
	{
		MeshDataTool meshDataTool = new MeshDataTool();
		meshDataTool.CreateFromSurface(destPortal.commonMesh, 0);
		Vector3 min = Vector3.One * float.MaxValue;
		Vector3 max = Vector3.One * float.MinValue;
		Vector2 size = Vector2.One;

		Axis axis;
		Quaternion changeRotation = Quaternion.Identity;

		if ((destPortal.normal.X == 1) || (destPortal.normal.X == -1))
			axis = Axis.X;
		else if ((destPortal.normal.Y == 1) || (destPortal.normal.Y == -1))
			axis = Axis.Y;
		else if ((destPortal.normal.Z == 1) || (destPortal.normal.Z == -1))
			axis = Axis.Z;
		else
		{
			GameManager.Print("Mirror is Rotated");
			float x = Mathf.Abs(destPortal.normal.X), y = Mathf.Abs(destPortal.normal.Y), z = Mathf.Abs(destPortal.normal.Z);
			Vector3 normalRef = Vector3.Zero;

			if ((x >= y) && (x >= z))
				axis = Axis.X;
			else if ((y >= x) && (y >= z))
				axis = Axis.Y;
			else
				axis = Axis.Z;

			switch (axis)
			{
				case Axis.X:
					if (destPortal.normal.X > 0)
						normalRef = Vector3.Right;
					else
						normalRef = Vector3.Left;
					break;
				case Axis.Y:
					if (destPortal.normal.Y > 0)
						normalRef = Vector3.Up;
					else
						normalRef = Vector3.Down;
					break;
				case Axis.Z:
					if (destPortal.normal.Z > 0)
						normalRef = Vector3.Back;
					else
						normalRef = Vector3.Forward;
					break;
			}
			changeRotation.CalculateRotation(destPortal.normal, normalRef);
		}

		float numVert = meshDataTool.GetVertexCount();
		for (int i = 0; i < numVert; i++)
		{
			Vector3 vertex = meshDataTool.GetVertex(i);
			if (vertex.X > max.X)
				max.X = vertex.X;
			if (vertex.Y > max.Y)
				max.Y = vertex.Y;
			if (vertex.Z > max.Z)
				max.Z = vertex.Z;

			if (vertex.X < min.X)
				min.X = vertex.X;
			if (vertex.Y < min.Y)
				min.Y = vertex.Y;
			if (vertex.Z < min.Z)
				min.Z = vertex.Z;
		}

		max = changeRotation * max;
		min = changeRotation * min;

		for (int i = 0; i < numVert; i++)
		{
			Vector3 vertex = changeRotation * meshDataTool.GetVertex(i);
			Vector2 uv2 = Vector2.Zero;
			switch (axis)
			{
				case Axis.X:
					uv2 = new Vector2(GetUV2RangeValue(vertex.Y, min.Y, max.Y), GetUV2RangeValue(vertex.Z, min.Z, max.Z));
					if (i == 0)
						size = new Vector2(max.Y - min.Y, max.Z - min.Z);
				break;
				case Axis.Y:
					uv2 = new Vector2(GetUV2RangeValue(vertex.X, min.X, max.X), GetUV2RangeValue(vertex.Z, min.Z, max.Z));
					if (i == 0)
					{
						if (destPortal.normal.Y < 0)
							InvertX = false;
						InvertY = false;
						size = new Vector2(max.X - min.X, max.Z - min.Z);
					}
				break;
				case Axis.Z:
					uv2 = new Vector2(GetUV2RangeValue(vertex.X, min.X, max.X), GetUV2RangeValue(vertex.Y, min.Y, max.Y));
					if (i == 0)
						size = new Vector2(max.X - min.X, max.Y - min.Y);;
				break;
			}
			meshDataTool.SetVertexUV2(i, uv2);
		}
		destPortal.commonMesh.ClearSurfaces();
		meshDataTool.CommitToSurface(destPortal.commonMesh);
		return size;
	}

	private float GetUV2RangeValue(float X, float Min, float Max)
	{
		return (X - Min) / (Max - Min);
	}
	
	void OnBodyEntered(Node3D other)
	{
		if (GameManager.Paused)
			return;

		if (other is PlayerThing playerThing)
		{
			if (!currentPlayers.Contains(playerThing))
			{
				currentPlayers.Add(playerThing);
//				GameManager.Print("Why does " + other.Name + " DARES to enter my dominion " + Name);
			}
		}
	}
	void OnBodyExit(Node3D other)
	{
		if (GameManager.Paused)
			return;

		if (other is PlayerThing playerThing)
		{
			if (currentPlayers.Contains(playerThing))
			{
				currentPlayers.Remove(playerThing);
//				GameManager.Print("Finally " + other.Name + " got scared of my dominion " + Name);
			}
		}
	}
}
```

./Assets/Scripts/Generic/InterpolatedTransform.cs:
```
using Godot;
using ExtensionMethods;
using System;

public partial class InterpolatedTransform : Node3D
{
	[Export]
	public Node3D Source;
	[Export]
	public InterpolatedNode3D interpolationReset;

	private bool update = false;
	private Transform3D prev;
	private Transform3D current;

	public override void _Ready()
	{
		TopLevel = true;

		if (interpolationReset != null) 
			interpolationReset.SetTransformReset += ResetTransform;

		if (Source == null)
			Source = GetParentNode3D();

		if (Source == null)
			return;

		GlobalTransform = Source.GlobalTransform;
	}

	public void SetSource(Node3D source)
	{
		Source = source;
		GlobalTransform = Source.GlobalTransform;
	}

	public void SetInterpolationReset(InterpolatedNode3D interpolated) 
	{
		interpolationReset = interpolated;
		if (interpolationReset != null)
			interpolationReset.SetTransformReset += ResetTransform;
	}
	public void ResetTransform()
	{
		current = Source.GlobalTransform;
		prev = current;
		GlobalTransform = current;
	}
	public void UpdateTransform()
	{
		prev = current;
		current = Source.GlobalTransform;
		update = false;
	}

	public override void _Process(double delta)
	{
		if (update) 
			UpdateTransform();

		float deltaT = (float)Mathf.Clamp(Engine.GetPhysicsInterpolationFraction(), 0, 1);
//		GlobalTransform = prev.InterpolateWith(current, deltaT);
		GlobalTransform = prev.Lerp(current, deltaT);
	}

	public override void _PhysicsProcess(double delta)
	{
		update = true;
	}

	public override void _ExitTree()
	{
		if (interpolationReset != null)
			interpolationReset.SetTransformReset -= ResetTransform;
	}
}
```

./Assets/Scripts/Generic/BloodTrail.cs:
```
using ExtensionMethods;
using Godot;

public partial class BloodTrail : RigidBody3D
{
	[Export]
	public float destroyTimer = 1;
	public string[] decalMark = { "BloodMark1", "BloodMark2", "BloodMark3", "BloodMark4", "BloodMark5", "BloodMark6", "BloodMark7", "BloodMark8" };

	private Rid Sphere;
	private PhysicsShapeQueryParameters3D SphereCast;
	public override void _Ready()
	{
		BodyEntered += OnBodyEntered;
		Sphere = PhysicsServer3D.SphereShapeCreate();
		PhysicsServer3D.ShapeSetData(Sphere, .5f);
		SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		destroyTimer -= deltaTime;
		if (destroyTimer < 0)
			QueueFree();
	}

	void OnBodyEntered(Node other)
	{
		var SpaceState = GetWorld3D().DirectSpaceState;
		CollisionObject3D Hit = null;
		Vector3 Collision = Vector3.Zero;
		Vector3 Normal = Vector3.Zero;

		//check for collision on surfaces
		if (destroyTimer > 0)
		{
			SphereCast.CollisionMask = (1 << GameManager.ColliderLayer);
			SphereCast.Transform = GlobalTransform;
			var hit = SpaceState.GetRestInfo(SphereCast);
			if (hit.Count > 0)
			{
				Hit = (CollisionObject3D)InstanceFromId((ulong)hit["collider_id"]);
				Collision = (Vector3)hit["point"];
				Normal = (Vector3)hit["normal"];
			}

			if (Hit == null)
				return;

			destroyTimer = -1;
			if (CheckIfCanMark(SpaceState, Hit, Collision) == false)
				return;

			SpriteController DecalMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark[GD.RandRange(0, decalMark.Length - 1)]].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(DecalMark);
			DecalMark.GlobalPosition = Collision + (Normal * .03f);
			DecalMark.SetForward(Normal);
			DecalMark.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
			if (Hit is Crusher)
				DecalMark.referenceNode = Hit;
		}
	}
	public bool CheckIfCanMark(PhysicsDirectSpaceState3D SpaceState, CollisionObject3D collider, Vector3 collision)
	{
		if (collider is Damageable)
			return false;

		//Don't mark moving platforms
		if (collider is Crusher)
			return false;

		//Check if mapcollider are noMarks
		if (MapLoader.noMarks.Contains(collider))
			return false;

		//Check if collision in inside a fog Area
		var PointIntersect = new PhysicsPointQueryParameters3D();
		PointIntersect.CollideWithAreas = true;
		PointIntersect.CollideWithBodies = false;
		PointIntersect.CollisionMask = (1 << GameManager.FogLayer);
		PointIntersect.Position = collision;

		var hits = SpaceState.IntersectPoint(PointIntersect);
		if (hits.Count == 0)
			return true;

		return false;
	}
}
```

./Assets/Scripts/Generic/TimerController.cs:
```
using Godot;
using System;
public partial class TimerController : Node3D
{
	public float waitTime;
	public float randomTime;
	private float nextActivateTime;
	private TriggerController trigger;
	float time = 0f;
	public void Init(float wait, float random, TriggerController tc)
	{
		waitTime = wait;
		randomTime = random;
		trigger = tc;

		nextActivateTime = (float)GD.RandRange(waitTime - randomTime, waitTime + randomTime);
		if (trigger == null)
			SetProcess(false);
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		time += deltaTime;

		if (time >= nextActivateTime)
		{
			time = 0f;
			nextActivateTime = (float)GD.RandRange(waitTime - randomTime, waitTime + randomTime);
			trigger.Activate(null);
		}
	}
}
```

./Assets/Scripts/Generic/ModelController.cs:
```
using Godot;
using System.Collections.Generic;

public partial class ModelController : Node3D
{
	[Export]
	public string modelName = "";
	[Export]
	public string shaderName = "";
	[Export]
	public string tagName = "";
	[Export]
	public bool useCommon = true;
	[Export]
	public bool isTransparent = false;
	[Export]
	public bool receiveShadows = false;
	[Export]
	public bool castShadows = false;
	[Export]
	public bool useLowCountMultiMesh = true;
	[Export]
	public bool alphaFade = false;
	[Export]
	public bool isViewModel = false;

	public uint currentLayer = GameManager.AllPlayerViewMask;
	public MD3 Model { get { return md3Model; } }
	private MD3 md3Model = null;

	private MeshProcessed model;
	[Export]
	public float modelAnimationFPS = 0;
	[Export]
	public DestroyType destroyType;
	[Export]
	public float destroyTimer = 0;
	[Export]
	public GameManager.FuncState currentState = GameManager.FuncState.Ready;

	private List<MultiMeshData> multiMeshDataList = new List<MultiMeshData>();
	private List<Node3D> destroyNodes = new List<Node3D>();
	private List<int> modelAnim = new List<int>();

	private int modelCurrentFrame;

	private Vector3 currentOrigin;
	private float height;

	private float ModelLerpTime = 0;
	private float ModelCurrentLerpTime = 0;

	private Color Modulate = Colors.Black;
	private float baseTime = 1;
	public enum DestroyType
	{
		NoDestroy,
		DestroyAfterTime,
		DestroyAfterModelLastFrame
	}

	private Vector3 lastGlobalPosition = new Vector3(0, 0, 0);
	private Basis	lastGlobalBasis = Basis.Identity;	

	public void AddDestroyNode(Node3D node)
	{
		if (!destroyNodes.Contains(node))
			destroyNodes.Add(node);
	}

	public override void _Ready()
	{
		Init();
	}

	public void Init()
	{
		if (currentState == GameManager.FuncState.None)
			return;

		if (string.IsNullOrEmpty(modelName))
			return;

		md3Model = ModelsManager.GetModel(modelName, isTransparent);
		if (md3Model == null)
			return;

		Node3D currentObject = this;
		Dictionary<string, string> meshToSkin = null;
		if (!string.IsNullOrEmpty(shaderName))
		{
			shaderName = shaderName.ToUpper();
			meshToSkin = new Dictionary<string, string>
			{
				{ md3Model.meshes[0].name, shaderName }
			};
			if (!TextureLoader.HasTexture(shaderName))
				TextureLoader.AddNewTexture(shaderName, isTransparent);
		}

		model = Mesher.GenerateModelFromMeshes(md3Model, currentLayer, receiveShadows, castShadows, currentObject, isTransparent, ((modelAnimationFPS == 0) && !isTransparent) && useCommon, meshToSkin, useLowCountMultiMesh, alphaFade, isViewModel);

		for (int i = 0; i < md3Model.meshes.Count; i++)
		{
			var modelMesh = md3Model.meshes[i];
			if (modelMesh.numFrames > 1)
				modelAnim.Add(i);
		}

		modelCurrentFrame = 0;
		if (destroyTimer != 0)
			baseTime = destroyTimer;
		ModelsManager.AddModel(this);

	}

	void SetTagPosition()
	{
		Node parent = GetParent();
		if (parent is ModelController source)
		{
			if (source.Model.tagsIdbyName.TryGetValue(tagName, out int tagId))
			{
				Position = source.Model.tagsbyId[tagId][0].origin;
				Quaternion = source.Model.tagsbyId[tagId][0].rotation;
			}
		}
	}

	void AnimateModel(float deltaTime)
	{
		if (modelAnimationFPS == 0)
			return;

		int currentFrame = modelCurrentFrame;
		int nextFrame = currentFrame + 1;
		
		if (nextFrame >= md3Model.numFrames)
			nextFrame = 0;
		if ((nextFrame == 0) && (destroyType == DestroyType.DestroyAfterModelLastFrame))
		{
			QueueFree();
			return;
		}

		if (currentFrame == nextFrame)
			return;

		for (int i = 0; i < modelAnim.Count; i++)
		{
			MD3Mesh currentMesh = md3Model.meshes[modelAnim[i]];
			for (int j = 0; j < currentMesh.numVertices; j++)
			{
				Vector3 newVertex = currentMesh.verts[currentFrame][j].Lerp(currentMesh.verts[nextFrame][j], ModelCurrentLerpTime);
				Vector3 newNormal = currentMesh.normals[currentFrame][j].Lerp(currentMesh.normals[nextFrame][j], ModelCurrentLerpTime);
				model.data[i].meshDataTool.SetVertex(j, newVertex);
				model.data[i].meshDataTool.SetVertexNormal(j, newNormal);
			}
			model.data[i].arrMesh.ClearSurfaces();
			model.data[i].meshDataTool.CommitToSurface(model.data[i].arrMesh);
		}

		ModelLerpTime = modelAnimationFPS * deltaTime;
		ModelCurrentLerpTime += ModelLerpTime;

		if (ModelCurrentLerpTime >= 1.0f)
		{
			ModelCurrentLerpTime -= 1.0f;
			modelCurrentFrame = nextFrame;
		}
	}
	public void Start()
	{
		if (string.IsNullOrEmpty(modelName))
		{
			QueueFree();
			return;
		}

		if (md3Model == null)
		{
			GameManager.Print("Model not found: " + modelName, GameManager.PrintType.Warning);
			QueueFree();
			return;
		}

		if (!string.IsNullOrEmpty(tagName))
			SetTagPosition();

		if ((modelAnimationFPS == 0) && useCommon)
		{
			for (int i = 0; i < model.data.Length; i++)
			{
				if (model.data[i] == null)
					continue;
				if (model.data[i].isTransparent)
					continue;

				if (Mesher.MultiMeshes.ContainsKey(model.data[i].multiMesh))
				{
					MultiMeshData multiMeshData = new MultiMeshData();
					multiMeshData.multiMesh = model.data[i].multiMesh;
					Mesher.AddNodeToMultiMeshes(model.data[i].multiMesh, this, Modulate);
					multiMeshData.owner = this;
					multiMeshDataList.Add(multiMeshData);
				}
			}
		}

		currentState = GameManager.FuncState.Start;
	}

	void UpdateMultiMesh()
	{
		if (multiMeshDataList.Count == 0)
			return;

		if ((alphaFade) ||
			((GlobalPosition - lastGlobalPosition).LengthSquared() > Mathf.Epsilon) ||
			((GlobalBasis.X - lastGlobalBasis.X).LengthSquared() > Mathf.Epsilon) ||
			((GlobalBasis.Y - lastGlobalBasis.Y).LengthSquared() > Mathf.Epsilon) ||
			((GlobalBasis.Z - lastGlobalBasis.Z).LengthSquared() > Mathf.Epsilon))
		{

			for (int i = 0; i < multiMeshDataList.Count; i++)
			{
				if (alphaFade)
					Mesher.UpdateInstanceMultiMesh(multiMeshDataList[i].multiMesh, this, Modulate);
				else
					Mesher.UpdateInstanceMultiMesh(multiMeshDataList[i].multiMesh, this);
			}
		}

		lastGlobalPosition = GlobalPosition;
		lastGlobalBasis = GlobalBasis;	
	}

	public override void _Notification(int what)
	{
		if (what == NotificationPredelete)
			Destroy();
	}
	public void Destroy()
	{
		List<MultiMesh> updateMultiMesh = new List<MultiMesh>();
		for (int i = 0; i < multiMeshDataList.Count; i++)
		{
			MultiMesh multiMesh = multiMeshDataList[i].multiMesh;
			Dictionary<Node3D, int> multiMeshSet;

			multiMeshDataList[i].owner.Hide();
			Mesher.UpdateInstanceMultiMesh(multiMesh, multiMeshDataList[i].owner);
			if (Mesher.MultiMeshes.TryGetValue(multiMesh, out multiMeshSet))
			{
				if (multiMeshSet.ContainsKey(multiMeshDataList[i].owner))
					multiMeshSet.Remove(multiMeshDataList[i].owner);
			}
			if (!updateMultiMesh.Contains(multiMesh))
				updateMultiMesh.Add(multiMesh);
		}

		//No need to update or detroy other nodes if changing map
		if (GameManager.CurrentState != GameManager.FuncState.Start)
			return;

		foreach (MultiMesh multiMesh in updateMultiMesh)
			Mesher.MultiMeshUpdateInstances(multiMesh);

		foreach (Node3D node in destroyNodes)
		{
			if (IsInstanceValid(node))
				node.QueueFree();
		}

		ModelsManager.RemoveModel(this);
	}
	public void Process(float deltaTime)
	{
		if (currentState == GameManager.FuncState.None)
			return;

		if (currentState == GameManager.FuncState.Ready)
			Start();

		AnimateModel(deltaTime);
		UpdateMultiMesh();
		if (alphaFade)
		{
			float alphaValue = Mathf.Lerp(1.0f, 0.0f, destroyTimer / baseTime);
			Modulate = new Color(alphaValue, alphaValue, alphaValue);
		}	
		if (destroyType == DestroyType.DestroyAfterTime)
		{
			destroyTimer -= deltaTime;
			if (destroyTimer < 0)
				QueueFree();
		}
	}
}
```

./Assets/Scripts/Generic/Crusher.cs:
```
using Godot;
public interface Crusher
{
	void Crush(PlayerThing player);
}
```

./Assets/Scripts/Generic/GibsController.cs:
```
using Godot;
using System.Collections.Generic;
using ExtensionMethods;
public partial class GibsController : RigidBody3D
{
	[Export]
	public MultiAudioStream audioStream;
	[Export]
	public string[] _sounds = new string[0];
	[Export]
	public ModelController modelController;

	public string[] decalMark = { "BloodMark1", "BloodMark2", "BloodMark3", "BloodMark4", "BloodMark5", "BloodMark6", "BloodMark7", "BloodMark8" };
	public AudioStream[] Sounds = new AudioStream[0];
	public float spawnTime = .1f;

	private Rid Sphere;
	private PhysicsShapeQueryParameters3D SphereCast;
	private PhysicsPointQueryParameters3D PointIntersect;

	private ConvexPolygonShape3D shape;
	private bool leaveMark = true;
	private float dropTime;
	public override void _Ready()
	{
		Sounds = new AudioStream[_sounds.Length];
		for (int i = 0; i < _sounds.Length; i++)
			Sounds[i] = SoundManager.LoadSound(_sounds[i]);
		BodyEntered += OnBodyEntered;
		if (ThingsManager.gibsShapes.TryGetValue(Name, out shape))
			GenerateCollider(true);

		Sphere = PhysicsServer3D.SphereShapeCreate();
		PhysicsServer3D.ShapeSetData(Sphere, .5f);
		SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;

		PointIntersect = new PhysicsPointQueryParameters3D();
		PointIntersect.CollideWithAreas = true;
		PointIntersect.CollideWithBodies = false;
		PointIntersect.CollisionMask = (1 << GameManager.FogLayer);
		dropTime = spawnTime;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		if (dropTime > 0)
			dropTime -= deltaTime;
		else if (dropTime < 0)
		{
			Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.BloodTrail].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
			Blood.GlobalTransform = GlobalTransform;
			dropTime += spawnTime;
		}
	}
	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (modelController.Model == null)
			return;

		GenerateCollider(false);
	}
	void OnBodyEntered(Node other)
	{
		int soundIndex = 0;
		float speed = LinearVelocity.LengthSquared();

		if (leaveMark)
			CheckCollision();

		if (speed > 30)
			soundIndex = GD.RandRange(0, 2);
		else if (speed > 10)
			soundIndex = GD.RandRange(0, 1);
		else if (speed < 5)
		{
			leaveMark = false;
			return;
		}

		if (Sounds.Length > soundIndex)
		{
			audioStream.Stream = Sounds[soundIndex];
			audioStream.Play();
		}
	}

	void CheckCollision()
	{
		var SpaceState = GetWorld3D().DirectSpaceState;
		CollisionObject3D Hit = null;
		Vector3 Collision = Vector3.Zero;
		Vector3 Normal = Vector3.Zero;

		//Don't spawn more blood
		SetProcess(false);

		//check for collision on surfaces
		{
			SphereCast.CollisionMask = (1 << GameManager.ColliderLayer);
			SphereCast.Transform = GlobalTransform;
			var hit = SpaceState.GetRestInfo(SphereCast);
			if (hit.Count > 0)
			{
				Hit = (CollisionObject3D)InstanceFromId((ulong)hit["collider_id"]);
				Collision = (Vector3)hit["point"];
				Normal = (Vector3)hit["normal"];
			}

			if (Hit == null)
				return;

			if (CheckIfCanMark(SpaceState, Hit, Collision) == false)
				return;

			SpriteController DecalMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark[GD.RandRange(0, decalMark.Length - 1)]].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(DecalMark);
			DecalMark.GlobalPosition = Collision + (Normal * .03f);
			DecalMark.SetForward(Normal);
			DecalMark.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
			if (Hit is Crusher)
				DecalMark.referenceNode = Hit;
		}
	}

	void GenerateCollider(bool colliderReady)
	{
		CollisionShape3D collisionShape = new CollisionShape3D();
		collisionShape.Name = "GibShape";
		AddChild(collisionShape);

		//Remember models are rotated 90
		Quaternion rotation = new Quaternion(Vector3.Right, Mathf.DegToRad(90));

		if (!colliderReady)
		{
			List<Vector3> modelPoints = new List<Vector3>();
			for (int i = 0; i < modelController.Model.meshes.Count; i++)
			{
				MD3Mesh currentMesh = modelController.Model.meshes[i];
				List<Vector3> verts = new List<Vector3>();
				for (int j = 0; j < currentMesh.numVertices; j++)
				{
					Vector3 newVertex = rotation * currentMesh.verts[0][j];
					verts.Add(newVertex);
				}
				modelPoints.AddRange(verts);
			}
			shape = new ConvexPolygonShape3D();
			shape.Points = modelPoints.ToArray();
			ThingsManager.AddGibsShapes(Name, shape);
		}
		collisionShape.Shape = shape;
		SetPhysicsProcess(false);
	}

	public bool CheckIfCanMark(PhysicsDirectSpaceState3D SpaceState, CollisionObject3D collider, Vector3 collision)
	{
		if (collider is Damageable)
			return false;

		//Don't mark moving platforms
		if (collider is Crusher)
			return false;

		//Check if mapcollider are noMarks
		if (MapLoader.noMarks.Contains(collider))
			return false;

		//Check if collision in inside a fog Area
		var PointIntersect = new PhysicsPointQueryParameters3D();
		PointIntersect.CollideWithAreas = true;
		PointIntersect.CollideWithBodies = false;
		PointIntersect.CollisionMask = (1 << GameManager.FogLayer);
		PointIntersect.Position = collision;

		var hits = SpaceState.IntersectPoint(PointIntersect);
		if (hits.Count == 0)
			return true;

		return false;
	}
}
```

./Assets/Scripts/Generic/NodeAnimation.cs:
```
using Godot;
using System;

public partial class NodeAnimation : Node3D
{
	[Export]
	public bool rotEnable = false;
	[Export]
	public float rotFPS = 0;
	[Export]
	public Axis rotAxis = Axis.Up;

	[Export]
	public bool posEnable = false;
	[Export]
	public float posAmplitude = 0;
	[Export]
	public float posFPS = 0;

	private Node3D parent;
	private Vector3 rotateAxis;
	private float height = 0;
	private float timer = 0;

	private GameManager.FuncState currentState = GameManager.FuncState.None;
	public enum Axis
	{
		Up,
		Down,
		Right,
		Left,
		Back,
		Forward
	}

	public override void _Ready()
	{
		Init();
	}

	public void Init()
	{
		if ((!rotEnable) && (!posEnable))
			SetProcess(false);
		else
			SetProcess(true);

		parent = GetParentNode3D();

		if (rotEnable)
		{
			switch (rotAxis)
			{
				default:
				case Axis.Up:
					rotateAxis = Vector3.Up;
				break;
				case Axis.Down:
					rotateAxis = Vector3.Down;
					break;
				case Axis.Right:
					rotateAxis = Vector3.Right;
					break;
				case Axis.Left:
					rotateAxis = Vector3.Left;
					break;
				case Axis.Back:
					rotateAxis = Vector3.Back;
					break;
				case Axis.Forward:
					rotateAxis = Vector3.Forward;
				break;
			}
		}
		currentState = GameManager.FuncState.Ready;
	}
	void RotateNode(float deltaTime)
	{
		if (!rotEnable)
			return;

		parent.RotateObjectLocal(rotateAxis, Mathf.DegToRad(deltaTime * rotFPS));
	}

	void MoveNode(float deltaTime)
	{
		if (!posEnable)
			return;

		timer += deltaTime * posFPS;
		float offSet = posAmplitude * Mathf.Sin(timer) + height;
		parent.Position = new Vector3(parent.Position.X, offSet, parent.Position.Z);
	}

	public void Start()
	{
		height = parent.Position.Y;
		currentState = GameManager.FuncState.Start;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		switch(currentState)
		{
			default:

			break;
			case GameManager.FuncState.Ready:
				Start();
			break;
		}

		float deltaTime = (float)delta;
		RotateNode(deltaTime);
		MoveNode(deltaTime);
	}
}
```

./Assets/Scripts/Generic/LightFade.cs:
```
using Godot;
using System;

public partial class LightFade : OmniLight3D
{
	[Export]
	public float destroyTimer = 0;

	private float baseTime = 1;
	private float BaseLight = 0;
	public override void _Ready()
	{
		if (destroyTimer == 0)
			SetProcess(false);
		else
			baseTime = destroyTimer;
		BaseLight = LightEnergy;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		destroyTimer -= deltaTime;
		if (destroyTimer < 0)
		{
			QueueFree();
			return;
		}
		LightEnergy = Mathf.Lerp(0.0f, BaseLight, destroyTimer / baseTime);
	}
}
```

./Assets/Scripts/Generic/SpriteController.cs:
```
using Godot;
using System;
using System.Linq;

public partial class SpriteController : Node3D
{
	[Export]
	public string spriteName = "";
	[Export]
	public float spriteRadius = 2;
	[Export]
	public Vector2 spriteSize = Vector2.Zero;
	[Export]
	public BaseMaterial3D.BillboardModeEnum billboard = BaseMaterial3D.BillboardModeEnum.Disabled;
	[Export]
	public bool isTransparent = false;
	[Export]
	public bool castShadows = false;
	[Export]
	public MultiMeshType useMultiMesh = MultiMeshType.LowCount;
	[Export]
	public SpriteData spriteData;
	[Export]
	public Node3D referenceNode = null;

	public enum MultiMeshType
	{
		NoMultiMesh,
		LowCount,
		HighCount
	}
	private MeshProcessed sprite;

	private GameManager.FuncState currentState = GameManager.FuncState.None;
	public override void _Ready()
	{
		Init();
	}

	public void Init()
	{
		currentState = GameManager.FuncState.Ready;
		if (string.IsNullOrEmpty(spriteName))
			return;

		spriteName = spriteName.ToUpper();

		if (billboard != BaseMaterial3D.BillboardModeEnum.Disabled)
			MaterialManager.AddBillBoard(spriteName);

		if (!TextureLoader.HasTexture(spriteName))
			TextureLoader.AddNewTexture(spriteName, isTransparent);

		if (spriteSize.X == 0)
			spriteSize.X = spriteRadius;
		if (spriteSize.Y == 0)
			spriteSize.Y = spriteRadius;

		sprite = Mesher.GenerateSprite(spriteName + "_" + spriteRadius, spriteName, spriteSize.X, spriteSize.Y, GameManager.AllPlayerViewMask, castShadows, spriteData.destroyTimer, this, isTransparent, ((useMultiMesh != MultiMeshType.NoMultiMesh) && !isTransparent), (useMultiMesh == MultiMeshType.LowCount));

		spriteData.baseTime = spriteData.destroyTimer;
	}

	public void Start()
	{
		currentState = GameManager.FuncState.Start;
		if (string.IsNullOrEmpty(spriteName))
		{
			QueueFree();
			return;
		}

		if (sprite.data[0] == null)
			return;
		if (sprite.data[0].isTransparent)
			return;

		if (useMultiMesh == MultiMeshType.NoMultiMesh)
			return;

		if (Mesher.MultiMeshSprites.ContainsKey(sprite.data[0].multiMesh))
		{
			currentState = GameManager.FuncState.None;
			MultiMeshData multiMeshData = new MultiMeshData();
			multiMeshData.multiMesh = sprite.data[0].multiMesh;
			spriteData.GlobalTransform = GlobalTransform;
			spriteData.GlobalPosition = GlobalPosition;
			spriteData.GlobalBasis = GlobalBasis;
			spriteData.SetReferenceNode(referenceNode);
			spriteData.SetMultiMeshData(multiMeshData);

			Mesher.AddSpriteToMultiMeshes(sprite.data[0].multiMesh, spriteData, spriteData.Modulate);
			//As Node is going to be deleted, children need to be reparented
			var Parent = GetParent();
			spriteData.destroyNodes = GetChildren().ToList();
			foreach (var child in spriteData.destroyNodes)
				child.Reparent(Parent);
			QueueFree();
		}
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		switch (currentState)
		{
			default:
				break;
			case GameManager.FuncState.Ready:
				Start();
			break;
			case GameManager.FuncState.Start:
				spriteData.Process((float)delta);
				if (spriteData.readyToDestroy)
					QueueFree();
			break;
		}
	}
}
```

./Assets/Scripts/Generic/Extension.cs:
```
using Godot;
using System;

namespace ExtensionMethods
{
	public static class NodeExtensions
	{
		public static void SetForward(this Node3D node3D, Vector3 forward)
		{
			if (Mathf.IsZeroApprox(forward.Dot(Vector3.Forward)))
				node3D.Rotation = Transform3D.Identity.LookingAt(forward, Vector3.Forward).Basis.GetEuler();
			else
				node3D.Rotation = Transform3D.Identity.LookingAt(forward, Vector3.Up).Basis.GetEuler();
		}

		public static Vector3 ForwardVector(this Node3D node3D)
		{
			Vector3 Forward = node3D.Basis.Z;
			if (Forward.IsNormalized())
				return Forward;
			return Forward.Normalized();
		}
		public static Vector3 UpVector(this Node3D node3D)
		{
			Vector3 Up = node3D.Basis.Y;
			if (Up.IsNormalized())
				return Up;
			return Up.Normalized();
		}
		public static Vector3 RightVector(this Node3D node3D)
		{
			Vector3 Right = node3D.Basis.X;
			if (Right.IsNormalized())
				return Right;
			return Right.Normalized();
		}
	}

	public static class QuaternionExtensions
	{
		public static Quaternion FastNormal(this Quaternion quaternion)
		{
			float qmagsq = quaternion.LengthSquared();
			if (Mathf.Abs(1.0 - qmagsq) < 2.107342e-08)
				quaternion *= (2.0f / (1.0f + qmagsq));
			else
				quaternion = quaternion.Normalized();
			return quaternion;
		}

		public static Quaternion CalculateRotation(this Quaternion quaternion, Vector3 normal1, Vector3 normal2)
		{
			float dotProduct = normal1.Dot(normal2);
			float angle = Mathf.RadToDeg(Mathf.Acos(dotProduct));

			Vector3 crossProduct = normal1.Cross(normal2);
			Vector3 axis = crossProduct.Normalized();
			quaternion = new Quaternion(axis, angle);

			return quaternion;
		}
	}

	public static class TransformExtensions
	{
		public static Transform3D Lerp(this Transform3D transform, Transform3D to, float weight)
		{
			Vector3 scale = transform.Basis.Scale;
			Quaternion rotationQuaternion = transform.Basis.GetRotationQuaternion().FastNormal();
			Vector3 origin = transform.Origin;
			Vector3 scale2 = to.Basis.Scale;
			Quaternion rotationQuaternion2 = to.Basis.GetRotationQuaternion().FastNormal();
			Vector3 origin2 = to.Origin;
			Transform3D result = Transform3D.Identity;
			Quaternion quaternion = rotationQuaternion.Slerp(rotationQuaternion2, weight).FastNormal();
			result.Basis = new Basis(quaternion);
			Vector3 scale3 = scale.Lerp(scale2, weight);
			result.Basis.Scaled(scale3);
			result.Origin = origin.Lerp(origin2, weight);
			return result;
		}
		public static Vector3 ForwardVector(this Transform3D transform)
		{
			return transform.Basis.Z;
		}
		public static Vector3 UpVector(this Transform3D transform)
		{
			return transform.Basis.Y;
		}
		public static Vector3 RightVector(this Transform3D transform)
		{
			return transform.Basis.X;
		}
	}

	public static class BasisExtensions
	{
		public static Basis Lerp(this Basis basis, Basis to, float weight)
		{
			Vector3 scale = basis.Scale;
			Quaternion rotationQuaternion = basis.GetRotationQuaternion().FastNormal();
			Vector3 scale2 = to.Scale;
			Quaternion rotationQuaternion2 = to.GetRotationQuaternion().FastNormal();
			Quaternion quaternion = rotationQuaternion.Slerp(rotationQuaternion2, weight).FastNormal();
			Basis result = new Basis(quaternion);
			Vector3 scale3 = scale.Lerp(scale2, weight);
			result.Scaled(scale3);
			return result;
		}
	}

	public static class StringExtensions
	{
		public static string StripExtension(this string String)
		{
			int fileExtPos = String.LastIndexOf(".");
			if (fileExtPos >= 0)
				return String.Substring(0, fileExtPos);
			return String;
		}
		public static string GetStringFromBytes(this string String, byte[] bytes)
		{
			string name;
			char[] nameData = new char[bytes.Length];
			bool fill = true;
			for (int i = 0; i < bytes.Length; i++)
			{
				if (fill)
					nameData[i] = Convert.ToChar(bytes[i]);
				else
				{
					nameData[i] = '\0';
					continue;
				}
				if (nameData[i] == '\0')
					fill = false;
			}
			if (nameData[0] == '\0')
				name = string.Empty;
			else
				name = new string(nameData).Replace("\0", string.Empty);

			return name;
		}
		public static float GetNumValue(this string String)
		{
			int inum = 0;
			float num = 0;
			if (int.TryParse(String, out inum))
				num = inum;
			else
				num = float.Parse(String);
			return num;
		}
	}

	public static class Vector3Extension
	{
		public static Vector3 GetLenghtAndNormalize(this Vector3 vector3, out float num)
		{
			num = vector3.LengthSquared();
			if (num == 0f)
			{
				vector3.X = (vector3.Y = (vector3.Z = 0f));
				return vector3;
			}

			num = Mathf.Sqrt(num);
			vector3.X /= num;
			vector3.Y /= num;
			vector3.Z /= num;

			return vector3;
		}
	}
}
```

./Assets/Scripts/Generic/InterpolatedNode3D.cs:
```
using Godot;
using System;
public partial class InterpolatedNode3D : Node3D
{
	public event Action SetTransformReset;

	public void InvoqueSetTransformReset()
	{
		SetTransformReset();
	}
}
```

./Assets/Scripts/Generic/SwitchController.cs:
```
using Godot;
using System;

public partial class SwitchController : DoorController
{
	public TriggerController internalSwitch;
	public override float waitTime { get { return internalSwitch.AutoReturnTime; } set { internalSwitch.AutoReturnTime = value; } }
	public override bool Activated { get { return internalSwitch.activated; } set { internalSwitch.activated = value; } }
	public override void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null)
	{
		if (Dead)
			return;

		if (Activated)
			return;

		if (tc == null)
		{
			TriggerController swTrigger;
			if (!ThingsManager.triggerToActivate.TryGetValue(internalSwitch.triggerName, out swTrigger))
				return;
			tc = swTrigger;
		}
		CurrentState = State.Opening;
		tc.Activate(null);
	}
	public override void _Ready()
	{
		internalSwitch = new TriggerController();
		AddChild(internalSwitch);
	}

}

```

./Assets/Scripts/Generic/ParentIsDamageable.cs:
```
using Godot;
using System;

public partial class ParentIsDamageable : StaticBody3D, Damageable
{
	public Damageable parent = null;
	public int Hitpoints { get { return parent.Hitpoints; } }
	public bool Dead { get { return parent.Dead; } }
	public bool Bleed { get { return parent.Bleed; } }
	public BloodType BloodColor { get { return parent.BloodColor; } }

	public void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null)
	{
		if (parent == null)
			return;

		parent.Damage(amount, damageType, attacker);
	}
	public void Impulse(Vector3 direction, float force)
	{
		if (parent == null)
			return;

		parent.Impulse(direction, force);
	}
}```

./Assets/Scripts/Generic/Data Resources/SpriteData.cs:
```
using Godot;
using System.Collections.Generic;

public partial class SpriteData : Resource
{
	[Export]
	public DestroyType destroyType = DestroyType.NoDestroy;
	[Export]
	public float destroyTimer = 0;
	[Export]
	public Color Modulate = Colors.Black;

	public List<Node> destroyNodes;
	public enum DestroyType
	{
		NoDestroy,
		DestroyAfterTime
	}

	public float baseTime = 1;
	private MultiMeshData multiMeshData = null;
	private Vector3 lastGlobalPosition = new Vector3(0, 0, 0);
	private Basis lastGlobalBasis = Basis.Identity;

	private Node3D referenceNode = null;
	private Vector3 startPosition;
	private Vector3 referencePosition;


	public Vector3 GlobalPosition;
	public Basis GlobalBasis;

	public Transform3D GlobalTransform;
	public bool readyToDestroy = false;
	public bool update = false;
	public void SetMultiMeshData(MultiMeshData data)
	{
		multiMeshData = data;
		//Set OffSetTime
		Modulate.A = GameManager.CurrentTimeMsec;
	}

	public void SetReferenceNode(Node3D node)
	{
		referenceNode = node;
		if (referenceNode == null)
			return;
		referencePosition = node.GlobalPosition;
		startPosition = GlobalPosition;
	}

	void CheckReference()
	{
		if (referenceNode == null)
			return;

		//"Parent" node was detroyed
		if (!IsInstanceValid(referenceNode))
		{
			readyToDestroy = true;
			GlobalPosition = MapLoader.mapMinCoord * 2f;
			return;
		}
			
		Vector3 distance = referenceNode.GlobalPosition - referencePosition;
		if (distance.LengthSquared() > Mathf.Epsilon)
			GlobalPosition = startPosition + distance;
	}

	void UpdateMultiMesh()
	{
		if (multiMeshData == null)
			return;

		if (((GlobalPosition - lastGlobalPosition).LengthSquared() > Mathf.Epsilon) ||
			((GlobalBasis.X - lastGlobalBasis.X).LengthSquared() > Mathf.Epsilon) ||
			((GlobalBasis.Y - lastGlobalBasis.Y).LengthSquared() > Mathf.Epsilon) ||
			((GlobalBasis.Z - lastGlobalBasis.Z).LengthSquared() > Mathf.Epsilon))
		{
			update = true;
			lastGlobalPosition = GlobalPosition;
			lastGlobalBasis = GlobalBasis;
			GlobalTransform = new Transform3D(GlobalBasis, GlobalPosition);
		}
	}

	public void Process(float deltaTime)
	{
		CheckReference();
		UpdateMultiMesh();
		if (destroyType == DestroyType.NoDestroy)
			return;

		destroyTimer -= deltaTime;
		if (destroyTimer < 0)
		{
			readyToDestroy = true;
			GlobalPosition = MapLoader.mapMinCoord * 2f;
		}
	}

	public void Destroy()
	{
		MultiMesh multiMesh = multiMeshData.multiMesh;
		List<SpriteData> multiMeshSet;
		if (Mesher.MultiMeshSprites.TryGetValue(multiMesh, out multiMeshSet))
		{
			if (multiMeshSet.Contains(this))
				multiMeshSet.Remove(this);
		}
		
		if (destroyNodes == null)
			return;
		
		for (int i = 0; i < destroyNodes.Count; i++)
		{
			Node node = destroyNodes[i];
			if (IsInstanceValid(node))
				node.QueueFree();
		}
	}
}```

./Assets/Scripts/Generic/Data Resources/AdaptativeTrack.cs:
```
using Godot;
using System;

public partial class AdaptativeTrack : Resource
{
	public int uniqueId;
	[Export]
	public int intesityLevel;
	[Export]
	public bool isRepeatable;
	[Export]
	public AudioStreamOggVorbis TrackFile;
	[Export]
	public bool hasOutro;
	[Export]
	public AudioStreamOggVorbis OutroFile;
}
```

./Assets/Scripts/Generic/Data Resources/SoundData.cs:
```
using Godot;
using System;

public partial class SoundData : Resource
{
	[Export]
	public string name;
	[Export]
	public AudioStream sound;
}
```

./Assets/Scripts/Generic/ParticlesController.cs:
```
using Godot;
using System;

public partial class ParticlesController : GpuParticles3D
{
	[Export]
	public float lifeTime = 0;
	[Export]
	public bool enableLifeTime = false;
	public override void _Ready()
	{

	}

	public override void _Process(double delta)
	{
		if (enableLifeTime)
		{
			float deltaTime = (float)delta;
			lifeTime -= deltaTime;
			if (lifeTime < 0)
			{
				OneShot = true;
				SetProcess(false);
			}
		}
	}
}
```

./Assets/Scripts/Generic/PlayAfterRandomTime.cs:
```
using Godot;
using System;

public partial class PlayAfterRandomTime : Node
{
	public float waitTime;
	public float randomTime;
	private float nextPlayTime;
	private AudioStreamPlayer sAudioStream;
	private MultiAudioStream mAudioStream;
	AudioType audioType = AudioType.None;
	enum AudioType
	{
		None,
		Single,
		Multi
	}

	float time = 0f;
	public void Init(float wait, float random)
	{
		waitTime = wait;
		randomTime = random;
		nextPlayTime = (float)GD.RandRange(waitTime - randomTime, waitTime + randomTime);
	}

	public void AddMultiAudioStream(MultiAudioStream audioStream)
	{
		if (audioStream == null)
		{
			SetProcess(false);
			return;
		}
		mAudioStream = audioStream;
		audioType = AudioType.Multi;
	}
	public void AddAudioStream(AudioStreamPlayer audioStream)
	{
		if (audioStream == null)
		{
			SetProcess(false);
			return;
		}
		sAudioStream = audioStream;
		audioType = AudioType.Single;
	}

	void ResetTimer()
	{
		time = 0f;
		nextPlayTime = (float)GD.RandRange(waitTime - randomTime, waitTime + randomTime + 1);
	}
	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		time += deltaTime;

		if (time >= nextPlayTime)
		{
			switch (audioType)
			{
				default:
				break;
				case AudioType.Single:
					if (!sAudioStream.Playing)
					{
						ResetTimer();
						sAudioStream.Play();
					}
				break;
				case AudioType.Multi:
					if (!mAudioStream.Playing)
					{
						ResetTimer();
						mAudioStream.Play();
					}
				break;
			}
		}
	}
}
```

./Assets/Scripts/Generic/WaterSurface.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;

public partial class WaterSurface : Area3D
{
	public List<Aabb> Boxes = new List<Aabb>();
	private List<PlayerThing> currentPlayers = new List<PlayerThing>();
	private Dictionary<Node3D, int> CurrentColliders = new Dictionary<Node3D, int>();
	public string waterIn = "player/watr_in";
	public string waterOut = "player/watr_out";
	public string waterUnder = "player/watr_un";
	public string zap = "world/button_zap";
	private AudioStream inSound;
	private AudioStream outSound;
	private AudioStream underSound;
	private AudioStream zapSound;
	public DamageableType damageable = DamageableType.None;

	public enum DamageableType
	{
		None,
		Lava,
		Slime
	}
	public override void _Ready()
	{
		Gravity /= 2;
		GravitySpaceOverride = SpaceOverride.Replace;
		AngularDamp = 3;
		AngularDampSpaceOverride = SpaceOverride.Replace;
		LinearDamp = 3;
		LinearDampSpaceOverride = SpaceOverride.Replace;

		BodyEntered += OnBodyEntered;
		BodyExited += OnBodyExit;
		inSound = SoundManager.LoadSound(waterIn);
		outSound = SoundManager.LoadSound(waterOut);
		underSound = SoundManager.LoadSound(waterUnder);
		zapSound = SoundManager.LoadSound(zap);
	}

	public override void _Process(double delta)
	{
		for (int i = 0; i < currentPlayers.Count; i++)
		{
			PlayerThing currentPlayer = currentPlayers[i];
			if (currentPlayer.Dead)
			{
//				GameManager.Print(currentPlayer.Name + "died in the Water " + Name);
				currentPlayers.Remove(currentPlayer);
				continue;
			}

			for (int j = 0; j < Boxes.Count; j++) 
			{
				if (Boxes[j].HasPoint(currentPlayer.GlobalPosition))
				{
					float deep = Boxes[j].GetEndpoint(2).Y - currentPlayer.GlobalPosition.Y;
					if (!currentPlayer.underWater)
					{
						if (deep > GameManager.Instance.playerHeight)
						{
							SoundManager.Create3DSound(currentPlayer.GlobalPosition, underSound);
							currentPlayer.playerInfo.playerPostProcessing.SetWaterEffect();
							currentPlayer.waterLever = 2;
							currentPlayer.drownTime = 12;
							currentPlayer.underWater = true;
						}
						else if (deep < 1)
							currentPlayer.drownTime = 12;
					}
					else if (currentPlayer.waterLever > 1)
					{
						if (deep < 1)
						{
							currentPlayer.playerInfo.playerPostProcessing.ResetEffects();
							currentPlayer.PlayModelSound("gasp");
							currentPlayer.underWater = false;
							currentPlayer.drownTime = 12;
						}
					}
					break;
				}
			}
		}
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (CurrentColliders.Count == 0)
			return;

		var CurrentBodies = GetOverlappingBodies();
		int CurrentBodiesNum = CurrentBodies.Count;
		if (CurrentBodiesNum == 0)
		{
			CurrentColliders.Clear();
			return;
		}

		for (int i = 0; i < CurrentBodiesNum; i++)
		{
			Node3D CurrentBody = CurrentBodies[i];
			if (CurrentColliders.ContainsKey(CurrentBody))
			{
				PlayerThing playerThing = CurrentBody as PlayerThing;
				if ((!playerThing.ready) || (playerThing.Dead))
				{
					CurrentColliders.Remove(CurrentBody);
					continue;
				}
				//We need antibounce
				int value = CurrentColliders[CurrentBody]++;
				if (value > 1)
				{
					PlayerEnterIntoWater(CurrentBody as PlayerThing);
					CurrentColliders.Remove(CurrentBody);
				}
			}
		}
	}

	public void ElectroShockDischarge(PlayerThing player)
	{
		int damage = player.playerInfo.Ammo[PlayerInfo.lightningAmmo];
		if (player.playerInfo.quadDamage)
			damage *= 4;

		int ammo = damage - player.hitpoints;
		player.playerInfo.Ammo[PlayerInfo.lightningAmmo] = ammo >= 0 ? ammo : 0;
		player.Damage(damage, DamageType.Electric, player);
		SoundManager.Create3DSound(player.GlobalPosition, zapSound);
		if (ammo <= 0)
			return;

		var CurrentBodies = GetOverlappingBodies();
		int totalEnemies = 0;
		for (int i = 0; i < CurrentBodies.Count; i++)
		{
			Node3D CurrentBody = CurrentBodies[i];
			if (CurrentBody is PlayerThing)
			{
				PlayerThing enemy = (PlayerThing)CurrentBody;
				if (enemy == player)
					continue;
				totalEnemies++;
			}
		}
		if (totalEnemies == 0)
			return;

		damage = ammo / totalEnemies;
		for (int i = 0; i < CurrentBodies.Count; i++)
		{
			Node3D CurrentBody = CurrentBodies[i];
			if (CurrentBody is PlayerThing)
			{
				PlayerThing enemy = (PlayerThing)CurrentBody;
				if (enemy == player)
					continue;
				enemy.Damage(damage, DamageType.Electric, player);
			}
		}
	}

	void OnBodyEntered(Node3D other)
	{
		if (GameManager.Paused)
			return;

		//Hide smoke and modify physics of grenade in water
		if (other is PhysicProjectile projectile)
			projectile.ChangeWater(true, underSound);

		if (other is PlayerThing player)
		{
			if (player.currentState == GameManager.FuncState.Ready)
				return;

			//Will check everything back on the main thread
			if (!CurrentColliders.ContainsKey(other))
				CurrentColliders.Add(other, 0);
		}
	}

	void OnBodyExit(Node3D other)
	{
		if (GameManager.Paused)
			return;

		//Restore smoke and physics of grenade outside water
		if (other is Grenade grenade)
			grenade.ChangeWater(false, inSound);

		if (other is PlayerThing playerThing)
		{
			if (currentPlayers.Contains(playerThing))
			{
				if (playerThing.underWater)
				{
					playerThing.playerInfo.playerPostProcessing.ResetEffects();
					playerThing.PlayModelSound("gasp");
				}
				playerThing.underWater = false;
				playerThing.waterLever = 0;
				playerThing.currentWaterSurface = null;
				playerThing.inDamageable = DamageableType.None;
				playerThing.avatar.lowerAnimation = PlayerModel.LowerAnimation.Jump;
				SoundManager.Create3DSound(playerThing.GlobalPosition, outSound);
				currentPlayers.Remove(playerThing);
//				GameManager.Print("Finally " + other.Name + "got out of the Water " + Name);
			}
		}
	}

	void PlayerEnterIntoWater(PlayerThing playerThing)
	{
		if (!currentPlayers.Contains(playerThing))
		{
			playerThing.waterLever = 1;
			playerThing.currentWaterSurface = this;
			playerThing.inDamageable = damageable;
//			playerThing.playerInfo.playerPostProcessing.SetWaterEffect();
			SoundManager.Create3DSound(playerThing.GlobalPosition, inSound);
			currentPlayers.Add(playerThing);
//			GameManager.Print(playerThing.Name + " Jump into the Water " + Name);
		}
	}

}
```

./Assets/Scripts/Generic/Damageable.cs:
```
using Godot;
public enum DamageType
{
	Generic,
	Rocket,
	Grenade,
	Plasma,
	Lightning,
	BFGBall,
	BFGBlast,
	Explosion,
	Environment,
	Crusher,
	Telefrag,
	Electric,
	Drown,
	Bullet,
	Pellet,
	Melee,
	Rail,
	Land,
	Fall,
	Trigger
}

public enum BloodType
{
	Red,
	Blue,
	Green,
	None
}

public interface Damageable
{
	int Hitpoints { get; }
	bool Dead { get; }
	bool Bleed { get; }
	BloodType BloodColor { get; }
	void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null);
	void Impulse(Vector3 direction, float force);
}```

./Assets/Scripts/Generic/TriggerController.cs:
```
using Godot;
using System;
using System.Collections;
using System.Collections.Generic;

public partial class TriggerController : Node3D
{
	public List<Area3D> Areas = new List<Area3D>();
	public string triggerName = "";
	public bool activated = false;
	private List<Action<PlayerThing>> OnActivate = new List<Action<PlayerThing>>();
	private Dictionary<Node3D, int> CurrentColliders = new Dictionary<Node3D, int>();
	private List<Node3D> DestroyNodes = new List<Node3D>();
	public bool Repeatable = false;
	public bool destroyPhysicsNodes = false;
	public bool AutoReturn = false;
	public float AutoReturnTime = 1f;
	public bool activateOnInit = false;

	public Func<bool> PreReq = new Func<bool>(() => { return true; });

	public float time = 0f;
	private float waitTime = 0;
	private PlayerThing delayActivator = null;
	private GameManager.FuncState currentState = GameManager.FuncState.None;

	public void SetController(string name, Action<PlayerThing> activeAction)
	{
		triggerName = name;
		OnActivate.Add(activeAction);
	}
	public bool Activate(PlayerThing playerThing)
	{
		if (!PreReq())
		{
			GameManager.Print("TriggerController: Prereq False for: " + triggerName, GameManager.PrintType.Info);
			return false;
		}

		if ((!Repeatable) || (AutoReturn))
			if (activated)
				return false;

		if (AutoReturn)
			time = AutoReturnTime;

		activated = !activated;
		for(int i = 0; i < OnActivate.Count; i++)
			OnActivate[i].Invoke(playerThing);

		return true;
	}

	public void ActivateAfterTime(float time, PlayerThing playerThing)
	{
		if (currentState == GameManager.FuncState.Start)
			return;

		waitTime = time;
		delayActivator = playerThing;
		currentState = GameManager.FuncState.Start;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		switch (currentState)
		{
			default:
			break;
			case GameManager.FuncState.None:
				if (activateOnInit)
					Activate(null);
				currentState = GameManager.FuncState.Ready;
			break;
			case GameManager.FuncState.Start:
				waitTime -= deltaTime;
				if (waitTime <= 0)
				{
					if (Activate(delayActivator))
						GameManager.Print("This " + Name + " was delayed activated");
					currentState = GameManager.FuncState.Ready;
				}
			break;
		}

		if (time <= 0)
			return;
		else
		{
			time -= deltaTime;
			if (time <= 0)
				activated = !activated;
		}
	}
	public void OnBodyEntered(Node3D other)
	{
		if (GameManager.Paused)
			return;

		if (other is PlayerThing player)
		{
			if (!player.ready)
				return;

			GameManager.Print("Someone " + other.Name + " tried to activate this " + Name);

			//Will activate everything back on the main thread
			if (!CurrentColliders.ContainsKey(other))
				CurrentColliders.Add(other,0);
		}
		else if (destroyPhysicsNodes)
		{
			if (other is PlayerModel avatar)
				avatar.Gib(false);
			else if (!DestroyNodes.Contains(other))
				DestroyNodes.Add(other);
		}
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (Areas.Count == 0)
		{
			SetPhysicsProcess(false);
			return;
		}

		if (DestroyNodes.Count > 0)
		{
			for (int i = 0; i < DestroyNodes.Count; i++)
			{
				GameManager.Print("DESTROY: " + DestroyNodes[i].Name);
				DestroyNodes[i].QueueFree();
			}
			DestroyNodes.Clear();
		}

		if (CurrentColliders.Count == 0)
			return;

		for (int n = 0; n < Areas.Count; n++)
		{
			Area3D Area = Areas[n];
			var CurrentBodies = Area.GetOverlappingBodies();
			int CurrentBodiesNum = CurrentBodies.Count;
			if (CurrentBodiesNum == 0)
			{
				CurrentColliders.Clear();
				return;
			}

			for (int i = 0; i < CurrentBodiesNum; i++)
			{
				Node3D CurrentBody = CurrentBodies[i];
				if (CurrentColliders.ContainsKey(CurrentBody))
				{
					PlayerThing playerThing = CurrentBody as PlayerThing;
					if ((!playerThing.ready) || (playerThing.Dead))
					{
						CurrentColliders.Remove(CurrentBody);
						continue;
					}
					//We need antibounce
					int value = CurrentColliders[CurrentBody]++;
					if (value > 1)
					{
						if (Activate(playerThing))
							GameManager.Print("Someone " + CurrentBody.Name + " activated this " + Name);
						CurrentColliders[CurrentBody] = 0;
						if (!Repeatable)
							CurrentColliders.Remove(CurrentBody);
					}
				}
			}
		}
	}
}
```

./Assets/Scripts/MapLoader.cs:
```
using Godot;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ExtensionMethods;
public static class MapLoader
{
	public static string CurrentMap;

	private static BinaryReader BSPMap;

	public static BSPHeader header;

	public static List<QSurface> surfaces;
	public static List<ImageTexture> lightMaps;
	public static List<QVertex> verts;
	public static List<int> vertIndices;
	public static List<Plane> planes;
	public static List<QNode> nodes;
	public static List<QLeaf> leafs;
	public static List<int> leafsSurfaces;
	public static uint[] leafRenderFrameLayer;
	public static List<QModel> models;
	public static List<QBrush> brushes;
	public static List<int> leafsBrushes;
	public static List<QBrushSide> brushSides;
	public static List<QShader> mapTextures;
	public static List<QFog> mapFog;
	public static QVisData visData;

	public static LightMapSize currentLightMapSize = LightMapSize.Q3_QL;

	public static Node3D MapMesh;
	public static Node3D MapFlares;
	public static Node3D ColliderGroup;
	public static List<Node3D> Locations;
	public static List<WaterSurface> waterSurfaces;

	public static int MAX_MESH_SURFACES = 256;
	public enum LightMapSize
	{
		Q3_QL = 128,
		QAA = 512
	}
	public enum LightMapLenght
	{
		Q3_QL = 49152,      //128*128*3
		QAA = 786432        //512*512*3
	}

	//Don't add decals nor marks to these surfaces
	public static HashSet<CollisionObject3D> noMarks;
	public static Dictionary<CollisionObject3D, SurfaceType> mapSurfaceTypes;
	public static Dictionary<CollisionObject3D, ContentType> mapContentTypes;

	//Map Data Limits
	public static Vector3 mapMinCoord;
	public static Vector3 mapMaxCoord;
	public static Aabb mapBounds;

	//Light Vol Data
	public static Vector3 LightVolNormalize;
	public static Vector3 LightVolOffset;
	public static ImageTexture3D LightVolAmbient;
	public static ImageTexture3D LightVolDirectonal;

	public static bool UseCheats = false;
	public static bool Load(string mapName)
	{
		string FileName;
		string path = Directory.GetCurrentDirectory() + "/StreamingAssets/maps/" + mapName + ".bsp";
		if (File.Exists(path))
			BSPMap = new BinaryReader(File.Open(path, FileMode.Open));
		else if (PakManager.ZipFiles.TryGetValue(path = ("maps/" + mapName + ".bsp").ToUpper(), out FileName))
		{
			MemoryStream ms = new MemoryStream(PakManager.GetPK3FileData(path, FileName));
			BSPMap = new BinaryReader(ms);
		}
		else
			return false;

		//Clear noMarks
		noMarks = new HashSet<CollisionObject3D>();

		//clear waterSurfaces
		waterSurfaces = new List<WaterSurface>();

		//Clear SurfaceType
		mapSurfaceTypes = new Dictionary<CollisionObject3D, SurfaceType>();

		//Clear ContentType
		mapContentTypes = new Dictionary<CollisionObject3D, ContentType>();

		//Clean Locations
		Locations = new List<Node3D>();

		//header
		{
			header = new BSPHeader(BSPMap);
		}

		//entities
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Entities].Offset, SeekOrigin.Begin);
			ThingsManager.ReadEntities(BSPMap.ReadBytes(header.Directory[LumpType.Entities].Length));
		}

		//shaders (textures)
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Shaders].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Shaders].Length / 72;
			mapTextures = new List<QShader>(num);
			GameManager.Print("mapTextures " + num);
			for (int i = 0; i < num; i++)
			{
				mapTextures.Add(new QShader(mapName.GetStringFromBytes(BSPMap.ReadBytes(64)).ToUpper(), BSPMap.ReadUInt32(), BSPMap.ReadUInt32(), false));
			}
		}

		//planes
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Planes].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Planes].Length / 16;
			planes = new List<Plane>(num);
			GameManager.Print("planes " + num);
			for (int i = 0; i < num; i++)
			{
				planes.Add(new Plane(QuakeToGodot.Vect3(new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()), false), BSPMap.ReadSingle() * GameManager.sizeDividor));
			}
		}

		//nodes
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Nodes].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Nodes].Length / 36;
			nodes = new List<QNode>(num);
			GameManager.Print("nodes " + num);
			for (int i = 0; i < num; i++)
			{
				nodes.Add(new QNode(BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(), new Vector3I(BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32()), new Vector3I(BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32())));
			}
		}

		//leafs
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Leafs].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Leafs].Length / 48;
			leafs = new List<QLeaf>(num);
			GameManager.Print("leafs " + num);
			for (int i = 0; i < num; i++)
			{
				leafs.Add(new QLeaf(BSPMap.ReadInt32(), BSPMap.ReadInt32(), new Vector3I(BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32()), new Vector3I(BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32()), BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32()));
			}
		}

		//leafs faces
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.LeafSurfaces].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.LeafSurfaces].Length / 4;
			leafsSurfaces = new List<int>(num);
			leafRenderFrameLayer = new uint[num];
			GameManager.Print("leafsSurfaces " + num);
			for (int i = 0; i < num; i++)
			{
				leafsSurfaces.Add(BSPMap.ReadInt32());
			}
		}

		//leafs brushes
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.LeafBrushes].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.LeafBrushes].Length / 4;
			leafsBrushes = new List<int>(num);
			GameManager.Print("leafsBrushes " + num);
			for (int i = 0; i < num; i++)
			{
				leafsBrushes.Add(BSPMap.ReadInt32());
			}
		}

		//models (map geometry)
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Models].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Models].Length / 40;
			models = new List<QModel>(num);
			GameManager.Print("map geometry " + num);
			for (int i = 0; i < num; i++)
			{
				models.Add(new QModel(new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()),
										new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()),
										BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32()));
			}
		}

		//brushes
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Brushes].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Brushes].Length / 12;
			brushes = new List<QBrush>(num);
			GameManager.Print("brushes " + num);
			for (int i = 0; i < num; i++)
			{
				brushes.Add(new QBrush(BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32()));
			}
		}

		//brush sides
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.BrushSides].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.BrushSides].Length / 8;
			brushSides = new List<QBrushSide>(num);
			GameManager.Print("brushSides " + num);
			for (int i = 0; i < num; i++)
			{
				brushSides.Add(new QBrushSide(BSPMap.ReadInt32(), BSPMap.ReadInt32()));
			}
		}

		//vertices
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Vertexes].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Vertexes].Length / 44;
			verts = new List<QVertex>(num);
			GameManager.Print("vertices " + num);
			for (int i = 0; i < num; i++)
			{
				verts.Add(new QVertex(i, new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()),
													BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle(),
													new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()), BSPMap.ReadBytes(4)));
			}
		}

		//vertex indices
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.VertIndices].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.VertIndices].Length / 4;
			vertIndices = new List<int>(num);
			GameManager.Print("vertIndices " + num);
			for (int i = 0; i < num; i++)
			{
				vertIndices.Add(BSPMap.ReadInt32());
			}
		}

		//effects (Fog)
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Effects].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Effects].Length / 72;
			mapFog = new List<QFog>(num);
			GameManager.Print("mapFog " + num);
			for (int i = 0; i < num; i++)
			{
				mapFog.Add(new QFog(mapName.GetStringFromBytes(BSPMap.ReadBytes(64)).ToUpper(), BSPMap.ReadInt32(), BSPMap.ReadInt32()));
			}
		}

		//We need to determine the max number in order to check lightmap type
		int maxlightMapNum = 0;
		//surfaces
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.Surfaces].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.Surfaces].Length / 104;
			surfaces = new List<QSurface>(num);
			GameManager.Print("surfaces " + num);
			for (int i = 0; i < num; i++)
			{
				surfaces.Add(new QSurface(i, BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(),
					BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(), BSPMap.ReadInt32(), new[]
					{
						BSPMap.ReadInt32(),
						BSPMap.ReadInt32()
					}, new[]
					{
						BSPMap.ReadInt32(),
						BSPMap.ReadInt32()
					}, new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()), new[]
					{
						new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()),
						new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle())
					}, new Vector3(BSPMap.ReadSingle(), BSPMap.ReadSingle(), BSPMap.ReadSingle()), new[]
					{
						BSPMap.ReadInt32(),
						BSPMap.ReadInt32()
					}));

				if (surfaces[i].lightMapID > maxlightMapNum)
					maxlightMapNum = surfaces[i].lightMapID;
			}
			//Need to count lightmap 0
			maxlightMapNum++;
		}

		//Q3/QL lightmaps (128x128x3)
		//QAA lightmaps (512x512x3)
		{
			//Check lightmap type
			int lightMapLenght = (int)LightMapLenght.QAA;
			if ((maxlightMapNum * lightMapLenght) > header.Directory[LumpType.LightMaps].Length)
				lightMapLenght = (int)LightMapLenght.Q3_QL;
			else
				currentLightMapSize = LightMapSize.QAA;

			BSPMap.BaseStream.Seek(header.Directory[LumpType.LightMaps].Offset, SeekOrigin.Begin);
			int num = header.Directory[LumpType.LightMaps].Length / lightMapLenght;
			lightMaps = new List<ImageTexture>(num);
			GameManager.Print("lightMaps " + num);
			for (int i = 0; i < num; i++)
			{
				lightMaps.Add(TextureLoader.CreateLightmapTexture(BSPMap.ReadBytes(lightMapLenght)));
			}
		}

		//Light Vols
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.LightGrid].Offset, SeekOrigin.Begin);
			(LightVolAmbient, LightVolDirectonal) = TextureLoader.CreateLightVolTextures(BSPMap.ReadBytes(header.Directory[LumpType.LightGrid].Length), models[0].bb_Min, models[0].bb_Max, ref LightVolNormalize, ref LightVolOffset);
		}

		//vis data
		{
			BSPMap.BaseStream.Seek(header.Directory[LumpType.VisData].Offset, SeekOrigin.Begin);
			if (header.Directory[LumpType.VisData].Length > 0)
			{
				visData = new QVisData(BSPMap.ReadInt32(), BSPMap.ReadInt32());
				visData.bitSets = BSPMap.ReadBytes(visData.numOfClusters * visData.bytesPerCluster);
			}
		}

		LerpColorOnRepeatedVertex();
		GetMapTextures();
		BSPMap.Close();
		
		return true;
	}

	public static void UnloadMap(bool useCheats)
	{
		UseCheats = useCheats;
		SpawnerManager.ClearLists();
		ModelsManager.ClearModels();
		ClusterPVSManager.Instance.ResetClusterList(1);
		Mesher.MultiMeshes = new Dictionary<MultiMesh, Dictionary<Node3D, int>>();
		Mesher.MultiMeshesInstances = new Dictionary<MultiMesh, MultiMeshInstance3D>();
		Mesher.MultiMeshSprites = new Dictionary<MultiMesh, List<SpriteData>>();
		Mesher.MultiMeshesChanged = new HashSet<MultiMesh>();
		ThingsManager.UnloadThings();
		MapMesh.QueueFree();
		MapFlares.QueueFree();
		ColliderGroup.QueueFree();
		GameManager.Instance.TemporaryObjectsHolder.QueueFree();
		GameManager.Console.ClearConsole();
		System.GC.Collect(2, System.GCCollectionMode.Forced);
	}

	public static void GenerateMapCollider()
	{
		Node3D MapColliders = new Node3D();
		MapColliders.Name = "MapColliders";
		ColliderGroup = MapColliders;

		mapBounds = new Aabb();
		List<QBrush> staticBrushes = new List<QBrush>();
		for (int i = 0; i < models[0].numBrushes; i++)
			staticBrushes.Add(brushes[models[0].firstBrush + i]);

		// Each brush group is its own object
		var groups = staticBrushes.GroupBy(x => new { mapTextures[x.shaderId].contentsFlags, mapTextures[x.shaderId].surfaceFlags });
		int groupId = 0;
		foreach (var group in groups)
		{
			QBrush[] groupBrushes = group.ToArray();
			if (groupBrushes.Length == 0)
				continue;
			
			groupId++;

			Mesher.GenerateGroupBrushCollider(groupId, ColliderGroup, groupBrushes);
		}
		mapMinCoord = mapBounds.Position;
		mapMaxCoord = mapBounds.Size;
	}
	public static void GenerateSurfaces()
	{
		MapMesh = new Node3D();
		MapMesh.Name = "MapMeshes";
		Node3D holder = MapMesh;
		GameManager.Instance.AddChild(MapMesh);
		MapFlares = new Node3D();
		MapFlares.Name = "MapFlares";
		holder.AddChild(MapFlares);

		List<QSurface> staticGeometry = new List<QSurface>();
		for (int i = 0; i < models[0].numSurfaces; i++)
			staticGeometry.Add(surfaces[models[0].firstSurface + i]);

		// Each surface group is its own object
		var groups = staticGeometry.GroupBy(x => new { x.type, x.shaderId, x.lightMapID });
		int groupId = 0;
		foreach (var bigGroup in groups)
		{
			bool billBoard = false;
			int ChunkSize = MAX_MESH_SURFACES;
			string shaderName = mapTextures[bigGroup.ElementAt(0).shaderId].name;
			if (MaterialManager.HasBillBoard.Contains(shaderName))
			{
				billBoard = true;
				if (bigGroup.Key.type != QSurfaceType.Billboard)
					ChunkSize = 1;
				GameManager.Print("AUTOSPRITE " + shaderName);
			}
			else if (MaterialManager.IsPortalMaterial(shaderName))
			{
				ChunkSize = 1;
				GameManager.Print("PORTAL " + shaderName);
			}
			var limitedGroup = bigGroup.Chunk(ChunkSize);
			foreach (var group in limitedGroup)
			{
				QSurface[] groupSurfaces = group.ToArray();
				if (groupSurfaces.Length == 0)
					continue;

				groupId++;

				switch (bigGroup.Key.type)
				{
					case QSurfaceType.Patch:
						Mesher.GenerateBezObject(groupSurfaces[0].shaderId, groupSurfaces[0].lightMapID, groupId, holder, groupSurfaces);
						break;
					case QSurfaceType.Polygon:
					case QSurfaceType.Mesh:
						if (billBoard)
							Mesher.GenerateBillBoardObject(mapTextures[groupSurfaces[0].shaderId].name, groupSurfaces[0].lightMapID, holder, groupSurfaces[0]);
						else
							Mesher.GeneratePolygonObject(mapTextures[groupSurfaces[0].shaderId].name, groupSurfaces[0].lightMapID, holder, groupSurfaces);
						break;
					case QSurfaceType.Billboard:
							Mesher.GenerateBillBoardSprites(mapTextures[groupSurfaces[0].shaderId].name, groupSurfaces[0].lightMapID, MapFlares, groupSurfaces);
						break;
					default:
						GameManager.Print("Group " + groupId + "Skipped surface because it was not a polygon, mesh, or bez patch (" + bigGroup.Key.type + ").", GameManager.PrintType.Info);
						break;
				}
			}
		}
		//JOLT require Node (ColliderGroup) to be added after all the shapes have been adeed:
		//"Manipulating a body's shape(s) after it has entered a scene tree can be costly"
		GameManager.Instance.AddChild(ColliderGroup);
		System.GC.Collect(2, System.GCCollectionMode.Forced);
	}

	public static void GenerateMapFog()
	{
		for (int i = 0; i < mapFog.Count; i++)
		{
			QBrush brush = brushes[mapFog[i].brushNum];
			Mesher.GenerateVolumetricFog(i, brush, ColliderGroup, mapFog[i].name);
		}
	}

	public static void SetLightVolData()
	{
		RenderingServer.GlobalShaderParameterSet("LightVolNormalize", LightVolNormalize);
		RenderingServer.GlobalShaderParameterSet("LightVolOffset", LightVolOffset);
		RenderingServer.GlobalShaderParameterSet("LightVolAmbient", LightVolAmbient);
		RenderingServer.GlobalShaderParameterSet("LightVolDirectonal", LightVolDirectonal);
	}

public static void LerpColorOnRepeatedVertex()
	{
		// We are only looking for bezier type
		var groupsurfaces = surfaces.Where(s => s.type == QSurfaceType.Patch);

		// Initialize 2 lists (one for test) to hold the vertices of each surface in the group
		List<QVertex> surfVerts = new List<QVertex>();
		List<QVertex> testVerts = new List<QVertex>();

		// Now searh all the vertexes for all the bezier surface
		foreach (var groupsurface in groupsurfaces)
		{
			testVerts.Clear();

			int startVert = groupsurface.startVertIndex;
			for (int j = 0; j < groupsurface.numOfVerts; j++)
				testVerts.Add(verts[startVert + j]);

			//Get number of groups for all the vertexes by their position, as we want to get the uniques it need to match the number of vertex
			int numGroups = testVerts.GroupBy(v => new { v.position.X, v.position.Y, v.position.Z }).Count();

			// If the verts are unique, add the test vertices to the surface list
			if (numGroups == groupsurface.numOfVerts)
				surfVerts.AddRange(testVerts);
		}

		//Now we got unique vertexes for each bezier surface, search for common positions
		var vGroups = surfVerts.GroupBy(v => new { v.position.X, v.position.Y, v.position.Z });

		foreach (var vGroup in vGroups)
		{
			QVertex[] groupVerteces = vGroup.ToArray();

			if (groupVerteces.Length == 0)
				continue;

			// Set the initial color to the color of the first vertex in the group
			// The we will be interpolating the color of every common vertex
			Color color = groupVerteces[0].color;
			for (int i = 1; i < groupVerteces.Length; i++)
				color = color.Lerp(groupVerteces[i].color, 0.5f);

			// Finally set the final color to all the common vertexex
			for (int i = 0; i < groupVerteces.Length; i++)
			{
				int index = groupVerteces[i].vertId;
				verts[index].color = color;
			}
		}
	}

	public static void GenerateGeometricSurface(Node3D holder, int num)
	{
		GenerateGeometricSurface(holder, null, 0, num);
	}

	public static uint GenerateGeometricSurface(Node3D holder, CollisionObject3D collider, int num)
	{
		uint OwnerShapeId = collider.CreateShapeOwner(holder);
		GenerateGeometricSurface(holder, collider, OwnerShapeId, num);
		return OwnerShapeId;
	}


	public static void GenerateGeometricSurface(Node3D holder, CollisionObject3D collider, uint OwnerShapeId, int num)
	{
		List<QSurface> staticGeometry = new List<QSurface>();
		for (int i = 0; i < models[num].numSurfaces; i++)
			staticGeometry.Add(surfaces[models[num].firstSurface + i]);

		// Each surface group is its own object
		var groups = staticGeometry.GroupBy(x => new { x.type, x.shaderId, x.lightMapID });
		int groupId = 0;
		foreach (var bigGroup in groups)
		{
			bool billBoard = false;
			int ChunkSize = MAX_MESH_SURFACES;
			string shaderName = mapTextures[bigGroup.ElementAt(0).shaderId].name;
			if (MaterialManager.HasBillBoard.Contains(shaderName))
			{
				billBoard = true;
				if (bigGroup.Key.type != QSurfaceType.Billboard)
					ChunkSize = 1;
				GameManager.Print("AUTOSPRITE NUM" + num + " NAME: "+ shaderName);
			}
			else if (MaterialManager.IsPortalMaterial(shaderName))
			{
				ChunkSize = 1;
				GameManager.Print("PORTAL " + shaderName);
			}

			var limitedGroup = bigGroup.Chunk(ChunkSize);
			foreach (var group in limitedGroup)
			{
				QSurface[] groupSurfaces = group.ToArray();
				if (groupSurfaces.Length == 0)
					continue;

				groupId++;

				switch (bigGroup.Key.type)
				{
					case QSurfaceType.Patch:
						Mesher.GenerateBezObject(groupSurfaces[0].shaderId, groupSurfaces[0].lightMapID, groupId, holder, groupSurfaces, false, collider, OwnerShapeId);
						break;
					case QSurfaceType.Polygon:
					case QSurfaceType.Mesh:
						if (billBoard)
							Mesher.GenerateBillBoardObject(mapTextures[groupSurfaces[0].shaderId].name, groupSurfaces[0].lightMapID, holder, groupSurfaces[0]);
						else
							Mesher.GeneratePolygonObject(mapTextures[groupSurfaces[0].shaderId].name, groupSurfaces[0].lightMapID, holder, groupSurfaces, false);
						break;
					case QSurfaceType.Billboard:
//							Mesher.GenerateBillBoardObject(mapTextures[groupSurfaces[0].shaderId].name, groupSurfaces[0].lightMapID, groupId, holder, modelObject, groupSurfaces);
						break;
					default:
						GameManager.Print("Group " + groupId + "Skipped surface because it was not a polygon, mesh, or bez patch (" + bigGroup.Key.type + ").", GameManager.PrintType.Info);
						break;
				}
			}
		}
	}
	public static (uint, CollisionObject3D) GenerateGeometricCollider(Node3D node, CollisionObject3D collider, int num, uint contentFlags = 0, bool isTrigger = true)
	{
		List<QBrush> listBrushes = new List<QBrush>();

		for (int i = 0; i < models[num].numBrushes; i++)
			listBrushes.Add(brushes[models[num].firstBrush + i]);

		if (listBrushes.Count == 0)
		{
			GameManager.Print("GenerateGeometricCollider brushes: " + num + " is empty", GameManager.PrintType.Info);
			return (0, null);
		}
		uint OwnerShapeId = 0;
		CollisionObject3D shapesOwner;
		(OwnerShapeId, shapesOwner) = Mesher.GenerateGroupBrushCollider(num, node, listBrushes.ToArray(), collider, contentFlags);
		return (OwnerShapeId, shapesOwner);
	}

	public static Vector3 GenerateJumpPadCollider(Area3D jumpPad, int num)
	{
		Vector3 center = Vector3.Zero;
		int numCenters = 0;
		for (int i = 0; i < models[num].numBrushes; i++)
		{
			if (!Mesher.GenerateBrushCollider(brushes[models[num].firstBrush + i], ColliderGroup, jumpPad, false, ContentFlags.JumpPad))
				continue;

			jumpPad.CollisionLayer = (1 << GameManager.WalkTriggerLayer);
			CollisionShape3D mc = jumpPad.GetChild<CollisionShape3D>(0);
			Shape3D boxShape = mc.Shape;
			Aabb box = boxShape.GetDebugMesh().GetAabb();
			center += box.GetCenter();
			numCenters++;
		}
		center /= numCenters;
		return center;
	}
	public static void GetMapTextures()
	{
		TextureLoader.LoadTextures(mapTextures, true, TextureLoader.ImageFormat.PNG);
		TextureLoader.LoadTextures(mapTextures, true, TextureLoader.ImageFormat.JPG);
		TextureLoader.LoadTextures(mapTextures, true, TextureLoader.ImageFormat.TGA);
	}
}
```

./Assets/Scripts/DataTypes.cs:
```
using Godot;
using System.IO;
using System.Text.Json.Serialization;
public class BSPHeader
{
	private const int LumpCount = 17;

	private readonly BinaryReader BSP;

	public BSPHeader(BinaryReader BSP)
	{
		this.BSP = BSP;

		ReadMagic();
		ReadVersion();
		ReadLumps();
	}

	public BSPDirectoryEntry[] Directory { get; set; }

	public string Magic { get; private set; }

	public uint Version { get; private set; }

	public string PrintInfo()
	{
		string blob = "\r\n=== BSP Header =====\r\n";
		blob += "Magic Number: " + Magic + "\r\n";
		blob += "BSP Version: " + Version + "\r\n";
		blob += "Header Directory:\r\n";
		int count = 0;
		foreach (BSPDirectoryEntry entry in Directory)
		{
			blob += "Lump " + count + ": " + entry.Name + " Offset: " + entry.Offset + " Length: " + entry.Length +
					"\r\n";
			count++;
		}

		return blob;
	}

	private void ReadLumps()
	{
		Directory = new BSPDirectoryEntry[LumpCount];
		for (int i = 0; i < 17; i++)
			Directory[i] = new BSPDirectoryEntry(BSP.ReadInt32(), BSP.ReadInt32());

		Directory[LumpType.Entities].Name = "Entities";
		Directory[LumpType.Shaders].Name = "Shaders";
		Directory[LumpType.Planes].Name = "Planes";
		Directory[LumpType.Nodes].Name = "Nodes";
		Directory[LumpType.Leafs].Name = "Leafs";
		Directory[LumpType.LeafSurfaces].Name = "Leaf Surfaces";
		Directory[LumpType.LeafBrushes].Name = "Leaf Brushes";
		Directory[LumpType.Models].Name = "Models";
		Directory[LumpType.Brushes].Name = "Brushes";
		Directory[LumpType.BrushSides].Name = "Brush Sides";
		Directory[LumpType.Vertexes].Name = "Vertexes";
		Directory[LumpType.VertIndices].Name = "Vertexes Indices";
		Directory[LumpType.Effects].Name = "Effects";
		Directory[LumpType.Surfaces].Name = "Surfaces";
		Directory[LumpType.LightMaps].Name = "Light Maps";
		Directory[LumpType.LightGrid].Name = "Light Grid";
		Directory[LumpType.VisData].Name = "Vis data";
	}

	private void ReadMagic()
	{
		BSP.BaseStream.Seek(0, SeekOrigin.Begin);
		Magic = new string(BSP.ReadChars(4));
	}

	private void ReadVersion()
	{
		BSP.BaseStream.Seek(4, SeekOrigin.Begin);
		Version = BSP.ReadUInt32();
	}
}
public class BSPDirectoryEntry
{
	public BSPDirectoryEntry(int offset, int length)
	{
		Offset = offset;
		Length = length;
	}

	public int Offset { get; }

	public int Length { get; }

	public string Name { get; set; }

	public bool Validate()
	{
		if (Length % 4 == 0)
			return true;
		return false;
	}
}

[JsonSourceGenerationOptions(WriteIndented = true, AllowTrailingCommas = true, NumberHandling = JsonNumberHandling.AllowReadingFromString | JsonNumberHandling.WriteAsString, ReadCommentHandling = System.Text.Json.JsonCommentHandling.Skip)]
[JsonSerializable(typeof(PlayerInfo.PlayerConfigData))]
[JsonSerializable(typeof(GameManager.GameConfigData))]
internal partial class SourceGenerationContext : JsonSerializerContext
{
}```

./Assets/Scripts/Mesher.cs:
```
using Godot;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
public static class Mesher
{
	public static Node3D MapMeshes;

	private static List<Vector3> vertsCache = new List<Vector3>();
	private static List<Vector2> uvCache = new List<Vector2>();
	private static List<Vector2> uv2Cache = new List<Vector2>();
	private static List<Vector3> normalsCache = new List<Vector3>();
	private static List<Color> vertsColor = new List<Color>();
	private static List<int> indiciesCache = new List<int>();

	private const int VertexInd = (int)Mesh.ArrayType.Vertex;
	private const int NormalInd = (int)Mesh.ArrayType.Normal;
	private const int TexUVInd = (int)Mesh.ArrayType.TexUV;
	private const int TexUV2Ind = (int)Mesh.ArrayType.TexUV2;
	private const int ColorInd = (int)Mesh.ArrayType.Color;
	private const int TriIndex = (int)Mesh.ArrayType.Index;

	public const float APROX_ERROR = 0.001f;

	public const int LOW_USE_MULTIMESHES = 512;
	public const int HIGH_USE_MULTIMESHES = 16384;

	public const uint MaskSolid = ContentFlags.Solid;
	public const uint MaskPlayerSolid = ContentFlags.Solid | ContentFlags.PlayerClip | ContentFlags.Body;
	public const uint MaskDeadSolid = ContentFlags.Solid | ContentFlags.PlayerClip;
	public const uint MaskWater = ContentFlags.Water | ContentFlags.Lava | ContentFlags.Slime;
	public const uint MaskOpaque = ContentFlags.Solid | ContentFlags.Lava | ContentFlags.Slime;
	public const uint MaskShot = ContentFlags.Solid | ContentFlags.Body | ContentFlags.Corpse;

	public const uint MaskTransparent = SurfaceFlags.NonSolid | SurfaceFlags.Sky;
	public const uint NoMarks = SurfaceFlags.NoImpact | SurfaceFlags.NoMarks;

	public static Dictionary<MultiMesh, Dictionary<Node3D, int>> MultiMeshes = new Dictionary<MultiMesh, Dictionary<Node3D, int>>();
	public static HashSet<MultiMesh> MultiMeshesChanged = new HashSet<MultiMesh>();
	public static Dictionary<MultiMesh, List<SpriteData>> MultiMeshSprites = new Dictionary<MultiMesh, List<SpriteData>>();
	public static Dictionary<MultiMesh, MultiMeshInstance3D> MultiMeshesInstances = new Dictionary<MultiMesh, MultiMeshInstance3D>();
	
	public static void ClearMesherCache()
	{
		vertsCache = new List<Vector3>();
		uvCache = new List<Vector2>();
		uv2Cache = new List<Vector2>();
		normalsCache = new List<Vector3>();
		indiciesCache = new List<int>();
		vertsColor = new List<Color>();
		BezierMesh.ClearCaches();
	}

	public static void GenerateBezObject(int shaderId, int lmIndex, int indexId, Node3D holder, QSurface[] surfaces, bool addPVS = true, CollisionObject3D collider = null, uint OwnerShapeId = 0)
	{
		if (surfaces == null || surfaces.Length == 0)
		{
			GameManager.Print("GenerateBezObject: Failed to create bezier object " + indexId + " there are no surfaces", GameManager.PrintType.Warning);
			return;
		}

		bool addCollider = true;
		string textureName = MapLoader.mapTextures[shaderId].name;
		string Name = "Bezier_Surfaces";
		int[] numPatches = new int[surfaces.Length];
		int totalPatches = 0;
		for (int i = 0; i < surfaces.Length; i++)
		{
			int patches = (surfaces[i].size[0] - 1) / 2 * ((surfaces[i].size[1] - 1) / 2);
			numPatches[i] = patches;
			totalPatches += patches;
			Name += "_" + surfaces[i].surfaceId;
		}

		uint type = MapLoader.mapTextures[shaderId].contentsFlags;
		uint stype = MapLoader.mapTextures[shaderId].surfaceFlags;

		SurfaceType surfaceType = new SurfaceType();
		surfaceType.Init(stype);
		ContentType contentType = new ContentType();
		contentType.Init(type);

		if (((contentType.value & ContentFlags.Details) != 0) || ((contentType.value & ContentFlags.Structural) != 0))
			addCollider = false;
		if ((contentType.value & MaskPlayerSolid) == 0)
			addCollider = false;

		if (addCollider)
		{
			if (collider == null)
			{
				collider = new StaticBody3D();
				collider.InputRayPickable = false;
				MapLoader.ColliderGroup.AddChild(collider);
				collider.Name = "Bezier_" + indexId + "_collider";
				OwnerShapeId = collider.CreateShapeOwner(holder);
			}

			if (!MapLoader.mapContentTypes.ContainsKey(collider))
				MapLoader.mapContentTypes.Add(collider, contentType);
		}

		int offset = 0;
		for (int i = 0; i < surfaces.Length; i++)
		{
			for (int n = 0; n < numPatches[i]; n++)
				GenerateBezMesh(OwnerShapeId, collider, surfaces[i], n, (surfaceType.NoDraw == false), ref offset);
		}

		bool noDraw = surfaceType.NoDraw;
		if (addCollider)
		{
			if ((surfaceType.value & MaskTransparent) != 0)
				collider.CollisionLayer = (1 << GameManager.InvisibleBlockerLayer);
			else
				collider.CollisionLayer = (1 << GameManager.ColliderLayer);

			//If noMarks add it to the table
			if ((surfaceType.value & NoMarks) != 0)
				MapLoader.noMarks.Add(collider);

			collider.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
			if (!MapLoader.mapSurfaceTypes.ContainsKey(collider))
				MapLoader.mapSurfaceTypes.Add(collider, surfaceType);
		}

		if (noDraw)
			return;

		bool hasPortal = false;
		bool forceSkinAlpha = false;

		ShaderMaterial material = MaterialManager.GetMaterials(textureName, lmIndex, ref forceSkinAlpha, ref hasPortal);
		MeshInstance3D mesh = new MeshInstance3D();
		ArrayMesh arrMesh = new ArrayMesh();

		BezierMesh.FinalizeBezierMesh(arrMesh);
		arrMesh.SurfaceSetMaterial(0, material);

		if (!forceSkinAlpha)
		{
			Texture mainText = (Texture2D)material.Get("shader_parameter/Tex_0");
			float luminance = .25f;
			if (mainText != null)
				if (mainText.HasMeta("luminance"))
					luminance = (float)mainText.GetMeta("luminance");
			mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
		}

		holder.AddChild(mesh);
		if (addPVS)
			mesh.Layers = GameManager.InvisibleMask;
		else //As dynamic surface don't have bsp data, assign it to the always visible layer 
			mesh.Layers = GameManager.AllPlayerViewMask;
		mesh.Name = Name;
		mesh.Mesh = arrMesh;

//		if (MaterialManager.IsSkyTexture(textureName))
			mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
//		else
//			mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.DoubleSided;

		//PVS only add on Static Geometry, as it has BSP Nodes
		if (addPVS)
			ClusterPVSManager.Instance.RegisterClusterAndSurfaces(mesh, surfaces);
	}
	public static void GenerateBezMesh(uint OwnerShapeId, CollisionObject3D collider, QSurface surface, int patchNumber, bool draw, ref int offset)
	{
		//Calculate how many patches there are using size[]
		//There are n_patchesX by n_patchesY patches in the grid, each of those
		//starts at a vert (i,j) in the overall grid
		//We don't actually need to know how many are on the Y length
		//but the forumla is here for historical/academic purposes
		int n_patchesX = (surface.size[0] - 1) / 2;
		//int n_patchesY = ((surface.size[1]) - 1) / 2;


		//Calculate what [n,m] patch we want by using an index
		//called patchNumber  Think of patchNumber as if you 
		//numbered the patches left to right, top to bottom on
		//the grid in a piece of paper.
		int pxStep = 0;
		int pyStep = 0;
		for (int i = 0; i < patchNumber; i++)
		{
			pxStep++;
			if (pxStep == n_patchesX)
			{
				pxStep = 0;
				pyStep++;
			}
		}

		//Create an array the size of the grid, which is given by
		//size[] on the surface object.
		QVertex[,] vertGrid = new QVertex[surface.size[0], surface.size[1]];

		//Read the verts for this surface into the grid, making sure
		//that the final shape of the grid matches the size[] of
		//the surface.
		int gridXstep = 0;
		int gridYstep = 0;
		int vertStep = surface.startVertIndex;
		for (int i = 0; i < surface.numOfVerts; i++)
		{
			vertGrid[gridXstep, gridYstep] = MapLoader.verts[vertStep];
			vertStep++;
			gridXstep++;
			if (gridXstep == surface.size[0])
			{
				gridXstep = 0;
				gridYstep++;
			}
		}

		//We now need to pluck out exactly nine vertexes to pass to our
		//teselate function, so lets calculate the starting vertex of the
		//3x3 grid of nine vertexes that will make up our patch.
		//we already know how many patches are in the grid, which we have
		//as n and m.  There are n by m patches.  Since this method will
		//create one object at a time, we only need to be able to grab
		//one.  The starting vertex will be called vi,vj think of vi,vj as x,y
		//coords into the grid.
		int vi = 2 * pxStep;
		int vj = 2 * pyStep;
		//Now that we have those, we need to get the vert at [vi,vj] and then
		//the two verts at [vi+1,vj] and [vi+2,vj], and then [vi,vj+1], etc.
		//the ending vert will at [vi+2,vj+2]

		int capacity = 3 * 3;
		List<Vector3> bverts = new List<Vector3>(capacity);

		//read texture/lightmap coords while we're at it
		//they will be tessellated as well.
		List<Vector2> uv = new List<Vector2>(capacity);
		List<Vector2> uv2 = new List<Vector2>(capacity);
		List<Color> color = new List<Color>(capacity);

		//Top row
		bverts.Add(vertGrid[vi, vj].position);
		bverts.Add(vertGrid[vi + 1, vj].position);
		bverts.Add(vertGrid[vi + 2, vj].position);

		uv.Add(vertGrid[vi, vj].textureCoord);
		uv.Add(vertGrid[vi + 1, vj].textureCoord);
		uv.Add(vertGrid[vi + 2, vj].textureCoord);

		uv2.Add(vertGrid[vi, vj].lightmapCoord);
		uv2.Add(vertGrid[vi + 1, vj].lightmapCoord);
		uv2.Add(vertGrid[vi + 2, vj].lightmapCoord);

		color.Add(vertGrid[vi, vj].color);
		color.Add(vertGrid[vi + 1, vj].color);
		color.Add(vertGrid[vi + 2, vj].color);

		//Middle row
		bverts.Add(vertGrid[vi, vj + 1].position);
		bverts.Add(vertGrid[vi + 1, vj + 1].position);
		bverts.Add(vertGrid[vi + 2, vj + 1].position);

		uv.Add(vertGrid[vi, vj + 1].textureCoord);
		uv.Add(vertGrid[vi + 1, vj + 1].textureCoord);
		uv.Add(vertGrid[vi + 2, vj + 1].textureCoord);

		uv2.Add(vertGrid[vi, vj + 1].lightmapCoord);
		uv2.Add(vertGrid[vi + 1, vj + 1].lightmapCoord);
		uv2.Add(vertGrid[vi + 2, vj + 1].lightmapCoord);

		color.Add(vertGrid[vi, vj + 1].color);
		color.Add(vertGrid[vi + 1, vj + 1].color);
		color.Add(vertGrid[vi + 2, vj + 1].color);

		//Bottom row
		bverts.Add(vertGrid[vi, vj + 2].position);
		bverts.Add(vertGrid[vi + 1, vj + 2].position);
		bverts.Add(vertGrid[vi + 2, vj + 2].position);

		uv.Add(vertGrid[vi, vj + 2].textureCoord);
		uv.Add(vertGrid[vi + 1, vj + 2].textureCoord);
		uv.Add(vertGrid[vi + 2, vj + 2].textureCoord);

		uv2.Add(vertGrid[vi, vj + 2].lightmapCoord);
		uv2.Add(vertGrid[vi + 1, vj + 2].lightmapCoord);
		uv2.Add(vertGrid[vi + 2, vj + 2].lightmapCoord);

		color.Add(vertGrid[vi, vj + 2].color);
		color.Add(vertGrid[vi + 1, vj + 2].color);
		color.Add(vertGrid[vi + 2, vj + 2].color);

		if (draw)
			BezierMesh.GenerateBezierMesh(GameManager.Instance.tessellations, bverts, uv, uv2, color, ref offset);
		if (collider != null)
			BezierMesh.BezierColliderMesh(OwnerShapeId, collider, surface.surfaceId, patchNumber, bverts);

		return;
	}
	public static void GeneratePolygonObject(string textureName, int lmIndex, Node3D holder, QSurface[] surfaces, bool addPVS = true)
	{
		if (surfaces == null || surfaces.Length == 0)
		{
			GameManager.Print("GeneratePolygonObject: Failed to create polygon there are no surfaces", GameManager.PrintType.Warning);
			return;
		}

		if (MaterialManager.IsFogMaterial(textureName))
		{
			GameManager.Print("GeneratePolygonObject: Object is FOG " + textureName + " so no Meshes are going to be made");
			return;
		}


		bool hasPortal = false;
		bool forceSkinAlpha = false;
		ShaderMaterial material = MaterialManager.GetMaterials(textureName, lmIndex, ref forceSkinAlpha, ref hasPortal);

//		Don't show illegal (sad faced) material, just remove mesh/shader
		if (material == MaterialManager.Instance.illegal)
			return;

		MeshInstance3D mesh = new MeshInstance3D();
		ArrayMesh arrMesh = new ArrayMesh();
		string Name = "Mesh_Surfaces";
		int offset = 0;
		for (var i = 0; i < surfaces.Length; i++)
		{
			GeneratePolygonMesh(surfaces[i], lmIndex, ref offset);
			Name += "_" + surfaces[i].surfaceId;
		}
		FinalizePolygonMesh(arrMesh);
		if (!hasPortal)
			arrMesh.SurfaceSetMaterial(0, material);
		holder.AddChild(mesh);
		if (addPVS)
			mesh.Layers = GameManager.InvisibleMask;
		else //As dynamic surface don't have bsp data, assign it to the always visible layer 
			mesh.Layers = GameManager.AllPlayerViewMask;
		mesh.Name = Name;
		mesh.Mesh = arrMesh;

//		if (MaterialManager.IsSkyTexture(textureName))
			mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
//		else
//			mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.DoubleSided;

		if (!forceSkinAlpha && !hasPortal)
		{
			Texture mainText = (Texture2D)material.Get("shader_parameter/Tex_0");
			float luminance = .25f;
			if (mainText != null)
				if (mainText.HasMeta("luminance"))
					luminance = (float)mainText.GetMeta("luminance");
			mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
		}

		if (hasPortal)
		{
			Portal portal = new Portal(textureName, material);
			Aabb box = arrMesh.GetAabb();
			portal.position = box.GetCenter();
			Vector3 normals = Vector3.Zero;
			for (var i = 0; i < normalsCache.Count; i++)
				normals += normalsCache[i];

			mesh.Layers = (1 << GameManager.Player1ViewLayer);
			mesh.SetSurfaceOverrideMaterial(0, material);
			portal.normal = normals.Normalized();
			portal.commonMesh = arrMesh;
			portal.surfaces.Add(new Portal.Surface(mesh, material));
			ThingsManager.AddPortalToMap(portal);
		}

		//PVS only add on Static Geometry, as it has BSP Nodes
		else if (addPVS)
			ClusterPVSManager.Instance.RegisterClusterAndSurfaces(mesh, surfaces);
	}
	public static void GeneratePolygonMesh(QSurface surface, int lm_index, ref int offset)
	{
		if (offset == 0)
		{
			vertsCache.Clear();
			uvCache.Clear();
			uv2Cache.Clear();
			normalsCache.Clear();
			indiciesCache.Clear();
			vertsColor.Clear();
		}

		int vstep = surface.startVertIndex;
		for (int n = 0; n < surface.numOfVerts; n++)
		{
			vertsCache.Add(MapLoader.verts[vstep].position);
			uvCache.Add(MapLoader.verts[vstep].textureCoord);
			uv2Cache.Add(MapLoader.verts[vstep].lightmapCoord);
			normalsCache.Add(MapLoader.verts[vstep].normal);

			//Need to compensate for Color lightning as lightmapped textures will change
			if (lm_index >= 0)
				vertsColor.Add(MapLoader.verts[vstep].color);
			else
				vertsColor.Add(TextureLoader.ChangeColorLighting(MapLoader.verts[vstep].color));
			vstep++;
		}

		// Rip meshverts / triangles
		int mstep = surface.startIndex;
		for (int n = 0; n < surface.numOfIndices; n++)
		{
			indiciesCache.Add(MapLoader.vertIndices[mstep] + offset);
			mstep++;
		}

		offset += surface.numOfVerts;
	}
	public static void FinalizePolygonMesh(ArrayMesh arrMesh)
	{
		var surfaceArray = new Godot.Collections.Array();
		surfaceArray.Resize((int)Mesh.ArrayType.Max);

		// add the verts, uvs, and normals we ripped to the surfaceArray
		surfaceArray[VertexInd] = vertsCache.ToArray();
		surfaceArray[NormalInd] = normalsCache.ToArray();

		// Add the texture co-ords (or UVs) to the surface/mesh
		surfaceArray[TexUVInd] = uvCache.ToArray();
		surfaceArray[TexUV2Ind] = uv2Cache.ToArray();

		// Add the vertex color
		surfaceArray[ColorInd] = vertsColor.ToArray();

		// add the meshverts to the object being built
		surfaceArray[TriIndex] = indiciesCache.ToArray();

		// Create the Mesh.
		arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
	}

	public static (Vector3 , Quaternion) GenerateBillBoardMesh(List<Vector3I> Quad, QSurface surface, int lm_index)
	{
		Vector3 center = Vector3.Zero;
		Vector3 normal = Vector3.Zero;
		Quaternion changeRotation;

		vertsCache.Clear();
		uvCache.Clear();
		uv2Cache.Clear();
		normalsCache.Clear();
		indiciesCache.Clear();
		vertsColor.Clear();

		List<int> localIndex = new List<int>();
		List<int> isRoot = new List<int>();
		int vstep = surface.startVertIndex;

		for (int i = 0; i < Quad.Count; i++)
		{
			int index = Quad[i].X;
			if (!localIndex.Contains(index))
			{
				localIndex.Add(index);
				isRoot.Add(index);
			}
			else
				isRoot.Remove(index);

			index = Quad[i].Y;
			if (!localIndex.Contains(index))
			{
				localIndex.Add(index);
				isRoot.Add(index);
			}
			else
				isRoot.Remove(index);

			index = Quad[i].Z;
			if (!localIndex.Contains(index))
			{
				localIndex.Add(index);
				isRoot.Add(index);
			}
			else
				isRoot.Remove(index);

		}

		localIndex.Sort();

		for (int n = 0; n < localIndex.Count; n++)
		{
			Vector3 pos = MapLoader.verts[vstep + localIndex[n]].position;
			vertsCache.Add(pos);
			center += pos;
		}

		center /= vertsCache.Count;
		CanForm3DConvexHull(vertsCache, ref normal, 0.00001f, false);

		if (Mathf.IsZeroApprox(normal.Dot(Vector3.Up)))
			changeRotation = Transform3D.Identity.LookingAt(normal, Vector3.Up).Basis.GetRotationQuaternion();
		else
			changeRotation = Transform3D.Identity.LookingAt(normal, Vector3.Forward).Basis.GetRotationQuaternion();

		float zRotationAngle = 0;
		float largestEdge = float.MinValue;
		//Need to make sure we don't take diagonals
		for (int i = 0; i < isRoot.Count; i++)
		{
			vertsCache.Clear();
			int indexA, indexB, indexC;
			indexA = isRoot[i];
			if (indexA == Quad[i].X)
			{
				indexB = Quad[i].Y;
				indexC = Quad[i].Z;
			}
			else if (indexA == Quad[i].Y)
			{
				indexB = Quad[i].X;
				indexC = Quad[i].Z;
			}
			else
			{
				indexB = Quad[i].X;
				indexC = Quad[i].Y;
			}
			Vector3 pos = changeRotation * (MapLoader.verts[vstep + indexA].position - center);
			pos.Z = 0;
			vertsCache.Add(pos);

			pos = changeRotation * (MapLoader.verts[vstep + indexB].position - center);
			pos.Z = 0;
			vertsCache.Add(pos);

			pos = changeRotation * (MapLoader.verts[vstep + indexC].position - center);
			pos.Z = 0;
			vertsCache.Add(pos);

			for (int j = 1; j < vertsCache.Count; j++)
			{
				Vector3 edge = vertsCache[j] - vertsCache[0];
				float edgeLenght = edge.LengthSquared();

				if (edgeLenght > largestEdge)
				{
					largestEdge = edgeLenght;
					zRotationAngle = (float)Math.Atan2(edge.X, edge.Y);
				}
			}
		}
		Quaternion quat = Quaternion.FromEuler(new Vector3(0, 0, zRotationAngle));
		changeRotation = quat * changeRotation;

		vertsCache.Clear();
		for (int n = 0; n < localIndex.Count; n++)
		{
			Vector3 pos = changeRotation * (MapLoader.verts[vstep + localIndex[n]].position - center);
			pos.Z = 0;
			vertsCache.Add(pos);
			uvCache.Add(MapLoader.verts[vstep + localIndex[n]].textureCoord);
			uv2Cache.Add(MapLoader.verts[vstep + localIndex[n]].lightmapCoord);
//			Because it's Z aligned, the normal will always be Back
//			normalsCache.Add(changeRotation * MapLoader.verts[vstep + localIndex[n]].normal);
			normalsCache.Add(Vector3.Back);

			//Need to compensate for Color lightning as lightmapped textures will change
			if (lm_index >= 0)
				vertsColor.Add(MapLoader.verts[vstep + localIndex[n]].color);
			else
				vertsColor.Add(TextureLoader.ChangeColorLighting(MapLoader.verts[vstep + localIndex[n]].color));
		}

		// Rip meshverts / triangles
		for (int i = 0; i < Quad.Count; i++)
		{
			indiciesCache.Add(localIndex.IndexOf(Quad[i].X));
			indiciesCache.Add(localIndex.IndexOf(Quad[i].Y));
			indiciesCache.Add(localIndex.IndexOf(Quad[i].Z));
		}

		return (center, changeRotation.Inverse());
	}
	public static void GenerateBillBoardObject(string textureName, int lmIndex, Node3D holder, QSurface surface, bool addPVS = true)
	{
		if (surface == null)
		{
			GameManager.Print("Failed to create polygon object because there are no surfaces", GameManager.PrintType.Warning);
			return;
		}

		ShaderMaterial material = MaterialManager.GetMaterials(textureName, lmIndex);

		//Get All Triangles in a List
		List<Vector3I> Tris = new List<Vector3I>();
		Vector3I triangle = Vector3I.Zero;
		for (int i = 0, vertex = 0; i < surface.numOfIndices; i++, vertex++)
		{
			int index = MapLoader.vertIndices[surface.startIndex + i];
			if (vertex > 2)
				vertex = 0;
			switch (vertex)
			{
				default:
				case 0:
					triangle = new Vector3I(index, 0, 0);
				break;
				case 1:
					triangle.Y = index;
				break;
				case 2:
					triangle.Z = index;
					Tris.Add(triangle);
				break;
			}
		}

		//Now Find the Quads
		List<List<Vector3I>> Quads = new List<List<Vector3I>>();
		for (int i = 1, j = 0; j < Tris.Count; i++)
		{
			if (i == Tris.Count)
			{
				j++;
				i = j + 1;
				if (j == (Tris.Count - 1))
					break;
			}

			if (i == j)
				continue;
			if ((Tris[j].X == Tris[i].X) || (Tris[j].X == Tris[i].Y) || (Tris[j].X == Tris[i].Z))
			{
				if (((Tris[j].Y == Tris[i].X) || (Tris[j].Y == Tris[i].Y) || (Tris[j].Y == Tris[i].Z))
					|| ((Tris[j].Z == Tris[i].X) || (Tris[j].Z == Tris[i].Y) || (Tris[j].Z == Tris[i].Z)))
				{
					List<Vector3I> Quad = new List<Vector3I>
					{
						Tris[j],
						Tris[i]
					};
					Quads.Add(Quad);
				}
			}
			else if ((Tris[j].Y == Tris[i].X) || (Tris[j].Y == Tris[i].Y) || (Tris[j].Y == Tris[i].Z))
			{
				if ((Tris[j].Z == Tris[i].X) || (Tris[j].Z == Tris[i].Y) || (Tris[j].Z == Tris[i].Z))
				{
					List<Vector3I> Quad = new List<Vector3I>
					{
						Tris[j],
						Tris[i]
					};
					Quads.Add(Quad);
				}
			}
		}

		addPVS = false;
		for (int i = 0; i < Quads.Count; i++)
		{
			MeshInstance3D mesh = new MeshInstance3D();
			ArrayMesh arrMesh = new ArrayMesh();
			string Name = "BillBoard_Surfaces_" + surface.surfaceId;
			Vector3 center;
			Quaternion rotation;
			(center, rotation) = GenerateBillBoardMesh(Quads[i], surface, lmIndex);

			Node3D billBoard = new Node3D();
			holder.AddChild(billBoard);
			billBoard.GlobalPosition = center;
			billBoard.Quaternion = rotation;
			FinalizePolygonMesh(arrMesh);
			arrMesh.SurfaceSetMaterial(0, material);
			billBoard.AddChild(mesh);
			if (addPVS)
				mesh.Layers = GameManager.InvisibleMask;
			else //As dynamic surface don't have bsp data, assign it to the always visible layer 
				mesh.Layers = GameManager.AllPlayerViewMask;
			mesh.Name = Name;
			mesh.Mesh = arrMesh;
//			if (MaterialManager.IsSkyTexture(textureName))
				mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
//			else
//				mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.DoubleSided;
			//PVS only add on Static Geometry, as it has BSP Nodes
			if (addPVS)
				ClusterPVSManager.Instance.RegisterClusterAndSurface(mesh, surface);
		}
	}

	public static void GenerateBillBoardSprites(string textureName, int lmIndex, Node3D holder, QSurface[] surfaces, bool addPVS = true)
	{
		if (surfaces == null || surfaces.Length == 0)
		{
			GameManager.Print("Failed to create polygon object because there are no surfaces", GameManager.PrintType.Warning);
			return;
		}

		for (var i = 0; i < surfaces.Length; i++)
		{
			SpriteController sprite = new SpriteController();
			string Name = "BillBoard_Surfaces_" + surfaces[i].surfaceId;
			holder.AddChild(sprite);
			sprite.spriteName = textureName;
			sprite.billboard = BaseMaterial3D.BillboardModeEnum.Enabled;
			sprite.Name = Name;
			sprite.spriteRadius = 1;
			sprite.Position = surfaces[i].lm_Origin;
			sprite.spriteData = new SpriteData();
			sprite.spriteData.Modulate = new Color(surfaces[i].lm_vecs[0].X, surfaces[i].lm_vecs[0].Y, surfaces[i].lm_vecs[0].Z, 1f);
			sprite.Init();
		}
	}

	public static MeshProcessed GenerateModelFromMeshes(MD3 model, Dictionary<string, string> meshToSkin, uint layer = GameManager.AllPlayerViewMask, bool useCommon = false, int frame = 0)
	{
		return GenerateModelFromMeshes(model, layer, true, true, null, false, useCommon, meshToSkin, true, false, false, true, frame);
	}
	public static MeshProcessed GenerateModelFromMeshes(MD3 model, uint layer, bool receiveShadows, bool castShadows, Node3D ownerObject = null, bool forceSkinAlpha = false, bool useCommon = true, Dictionary<string, string> meshToSkin = null, bool useLowMultimeshes = true, bool useColorData = false, bool isViewModel = false, bool useLightVol = true, int frame = 0)
	{
		if (model == null || model.meshes.Count == 0)
		{
			GameManager.Print("Failed to create model object because there are no meshes", GameManager.PrintType.Warning);
			return null;
		}

		if (model.frameSurfaces.ContainsKey(frame))
			return FillModelFromProcessedData(model, layer, receiveShadows, castShadows, ownerObject, useCommon, meshToSkin, forceSkinAlpha, useLowMultimeshes, useColorData, isViewModel, useLightVol, frame);

		if (ownerObject == null)
		{
			GameManager.Print("No ownerObject");
			ownerObject = new Node3D();
			ownerObject.Name = "Model_" + model.name;
		}

		FrameSurfaces frameSurfaces = new FrameSurfaces();
		MeshProcessed md3Model = new MeshProcessed();
		md3Model.node = ownerObject;
		md3Model.numMeshes = model.meshes.Count;
		md3Model.data = new MeshProcessed.dataMeshes[md3Model.numMeshes];

		int n = 0;
		if ((model.numFrames > 1) || (meshToSkin != null))
		{
			for(n = 0; n < model.meshes.Count; n++)
			{
				MD3Mesh modelMesh = model.meshes[n];
				MeshProcessed.dataMeshes data = new MeshProcessed.dataMeshes();
				var surfaceArray = GenerateModelMesh(modelMesh, frame);
				data.arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);

				Node3D modelObject;

				if (n == 0)
					modelObject = ownerObject;
				else
				{
					modelObject = new Node3D();
					modelObject.Name = "Mesh_" + n;
					ownerObject.AddChild(modelObject);
					modelObject.Position = Vector3.Zero;
				}

				string skinName;
				if (meshToSkin == null)
					skinName = modelMesh.skins[0].name;
				else
					skinName = meshToSkin[modelMesh.name];
				bool currentTransparent = forceSkinAlpha;
				ShaderMaterial material = MaterialManager.GetMaterials(skinName, -1, ref currentTransparent);
				data.isTransparent = currentTransparent;
				data.arrMesh.SurfaceSetMaterial(0, material);
				data.meshDataTool.CreateFromSurface(data.arrMesh, 0);
				md3Model.data[modelMesh.meshNum] = data;
				frameSurfaces.readySurfaceArray.Add(surfaceArray);
				MultiMesh multiMesh = new MultiMesh();
				data.multiMesh = multiMesh;
				multiMesh.Mesh = data.arrMesh;
				multiMesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
				if (useColorData)
					multiMesh.UseColors = true;
				if (useLowMultimeshes)
					multiMesh.InstanceCount = LOW_USE_MULTIMESHES;
				else
					multiMesh.InstanceCount = HIGH_USE_MULTIMESHES;
				multiMesh.VisibleInstanceCount = 0;

				SurfaceData surfaceData = new SurfaceData();
				surfaceData.skinName = skinName;
				surfaceData.commonMesh = multiMesh;
				surfaceData.useTransparent = currentTransparent;
				surfaceData.readyMaterials = material;
				frameSurfaces.surfaceIdbySkinName.Add(skinName + "_" + n, frameSurfaces.readySurfaces.Count());
				frameSurfaces.readySurfaces.Add(surfaceData);

				if (!MultiMeshes.ContainsKey(multiMesh))
				{
					Dictionary<Node3D, int> Set = new Dictionary<Node3D, int>();
					MultiMeshes.Add(multiMesh, Set);
				}

				if (useCommon && !currentTransparent)
				{
					MultiMeshInstance3D mesh = new MultiMeshInstance3D();
					mesh.Name = "MultiMesh_" + model.name;
					mesh.Multimesh = multiMesh;
					mesh.Layers = layer;
					if (!castShadows)
						mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
					mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
					if (useLightVol)
						mesh.SetInstanceShaderParameter("UseLightVol", true);
					if (!currentTransparent && receiveShadows)
					{
						Texture mainText = (Texture2D)material.Get("shader_parameter/Tex_0");
						float luminance = .25f;
						if (mainText != null)
							if (mainText.HasMeta("luminance"))
								luminance = (float)mainText.GetMeta("luminance");
						mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
					}

					GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
					MultiMeshesInstances.Add(multiMesh, mesh);
					GameManager.Print("Adding MultiMesh : " + mesh.Name);
				}
				else
				{
					MeshInstance3D mesh = new MeshInstance3D();
					mesh.Name = modelMesh.name;
					mesh.Mesh = data.arrMesh;
					mesh.Layers = layer;
					if (!castShadows)
						mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
					mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
					if (isViewModel)
						mesh.SetInstanceShaderParameter("ViewModel", true);
					if (useLightVol)
						mesh.SetInstanceShaderParameter("UseLightVol", true);
					if (!currentTransparent && receiveShadows)
					{
						Texture mainText = (Texture2D)material.Get("shader_parameter/Tex_0");
						float luminance = .25f;
						if (mainText != null)
							if (mainText.HasMeta("luminance"))
								luminance = (float)mainText.GetMeta("luminance");
						mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
					}

					modelObject.AddChild(mesh);
					GameManager.Print("Adding Child: " + mesh.Name + " to: " + modelObject.Name);
				}
			}
		}
		else
		{
			var baseGroups = model.meshes.GroupBy(x => new { x.numSkins });
			foreach (var baseGroup in baseGroups)
			{
				MD3Mesh[] baseGroupMeshes = baseGroup.ToArray();
				if (baseGroupMeshes.Length == 0)
					continue;

				var groupMeshes = baseGroupMeshes.GroupBy(x => new { x.skins[0].name });
				foreach (var groupMesh in groupMeshes)
				{
					MD3Mesh[] meshes = groupMesh.ToArray();
					if (meshes.Length == 0)
						continue;

					string Name = "Mesh_";
					int offset = 0;
					for (int i = 0; i < meshes.Length; i++)
					{
						GenerateModelMesh(meshes[i], frame, ref offset);
						if (i != 0)
							Name += "_";
						Name += meshes[i].name;
					}

					MeshProcessed.dataMeshes data = new MeshProcessed.dataMeshes();
					var surfaceArray = FinalizeModelMesh();
					data.arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);

					Node3D modelObject;
					if (n == 0)
						modelObject = ownerObject;
					else
					{
						modelObject = new Node3D();
						modelObject.Name = "Mesh_" + n;
						ownerObject.AddChild(modelObject);
						modelObject.Position = Vector3.Zero;
					}

					string skinName = meshes[0].skins[0].name;
					bool currentTransparent = forceSkinAlpha;
					ShaderMaterial material = MaterialManager.GetMaterials(skinName, -1, ref currentTransparent);

					for (int i = 0; i < meshes.Length; i++)
						md3Model.data[meshes[i].meshNum] = data;

					data.isTransparent = currentTransparent;
					data.arrMesh.SurfaceSetMaterial(0, material);
					data.meshDataTool.CreateFromSurface(data.arrMesh, 0);
					frameSurfaces.readySurfaceArray.Add(surfaceArray);
					MultiMesh multiMesh = new MultiMesh();
					data.multiMesh = multiMesh;
					multiMesh.Mesh = data.arrMesh;
					multiMesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
					if (useColorData)
						multiMesh.UseColors = true;
					if (useLowMultimeshes)
						multiMesh.InstanceCount = LOW_USE_MULTIMESHES;
					else
						multiMesh.InstanceCount = HIGH_USE_MULTIMESHES;
					multiMesh.VisibleInstanceCount = 0;

					SurfaceData surfaceData = new SurfaceData();
					surfaceData.skinName = skinName;
					surfaceData.commonMesh = multiMesh;
					surfaceData.useTransparent = currentTransparent;
					surfaceData.readyMaterials = material;
					frameSurfaces.surfaceIdbySkinName.Add(skinName + "_" + n, frameSurfaces.readySurfaces.Count());
					frameSurfaces.readySurfaces.Add(surfaceData);

					if (!MultiMeshes.ContainsKey(multiMesh))
					{
						Dictionary<Node3D, int> Set = new Dictionary<Node3D, int>();
						MultiMeshes.Add(multiMesh, Set);
					}

					if (useCommon && !currentTransparent)
					{
						MultiMeshInstance3D mesh = new MultiMeshInstance3D();
						mesh.Name = "MultiMesh_" + model.name;
						mesh.Multimesh = multiMesh;
						mesh.Layers = layer;
						if (!castShadows)
							mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
						mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
						if (useLightVol)
							mesh.SetInstanceShaderParameter("UseLightVol", true);
						if (receiveShadows)
						{
							Texture mainText = (Texture2D)material.Get("shader_parameter/Tex_0");
							float luminance = .25f;
							if (mainText != null)
								if (mainText.HasMeta("luminance"))
									luminance = (float)mainText.GetMeta("luminance");
							mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
						}

						GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
						MultiMeshesInstances.Add(multiMesh, mesh);
						GameManager.Print("Adding MultiMesh : " + mesh.Name + " skin group name " + meshes[0].skins[0].name);
					}
					else
					{
						MeshInstance3D mesh = new MeshInstance3D();
						mesh.Name = Name;
						mesh.Mesh = data.arrMesh;
						mesh.Layers = layer;
						if (!castShadows)
							mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
						mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
						if (isViewModel)
							mesh.SetInstanceShaderParameter("ViewModel", true);
						if (useLightVol)
							mesh.SetInstanceShaderParameter("UseLightVol", true);
						if (receiveShadows)
						{
							Texture mainText = (Texture2D)material.Get("shader_parameter/Tex_0");
							float luminance = .25f;
							if (mainText != null)
								if (mainText.HasMeta("luminance"))
									luminance = (float)mainText.GetMeta("luminance");
							mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
						}

						modelObject.AddChild(mesh);
						GameManager.Print("Adding Child: " + mesh.Name + " to: " + modelObject.Name + " skin group name " + meshes[0].skins[0].name);
					}
					n++;
				}
			}
		}
		model.frameSurfaces.Add(frame, frameSurfaces);
		return md3Model;
	}
	
	public static MeshProcessed FillModelFromProcessedData(MD3 model, uint layer, bool receiveShadows, bool castShadows, Node3D ownerObject = null, bool useCommon = true, Dictionary<string, string> meshToSkin = null, bool forceSkinAlpha = false, bool useLowMultimeshes = true, bool useColorData = false, bool isViewModel = false, bool useLightVol = true, int frame = 0)
	{
		if (ownerObject == null)
		{
			ownerObject = new Node3D();
			ownerObject.Name = "Model_" + model.name;
		}

		MeshProcessed meshProcessed = new MeshProcessed();
		meshProcessed.node = ownerObject;
		meshProcessed.numMeshes = model.meshes.Count;
		meshProcessed.data = new MeshProcessed.dataMeshes[meshProcessed.numMeshes];

		FrameSurfaces frameSurfaces = model.frameSurfaces[frame];
		for (int i = 0; i < frameSurfaces.readySurfaceArray.Count; i++)
		{
			Node3D modelObject;
			if (i == 0)
				modelObject = ownerObject;
			else
			{
				modelObject = new Node3D();
				modelObject.Name = "Mesh_" + i;
				ownerObject.AddChild(modelObject);
				modelObject.Position = Vector3.Zero;
			}

			meshProcessed.data[model.meshes[i].meshNum] = new MeshProcessed.dataMeshes();
			SurfaceData surfaceData = null;
			int skinIndex = -1;
			string skinName;
			if (meshToSkin == null)
			{
				surfaceData = frameSurfaces.readySurfaces[i];
				skinName = surfaceData.skinName;
			}
			else
				skinName = meshToSkin[model.meshes[i].name];

			
			if (frameSurfaces.surfaceIdbySkinName.TryGetValue(skinName + "_" + i, out skinIndex))
			{
				if (surfaceData == null)
					surfaceData = frameSurfaces.readySurfaces[skinIndex];

				bool useTransparent = surfaceData.useTransparent;
				meshProcessed.data[model.meshes[i].meshNum].isTransparent = useTransparent;
				if (useCommon && !useTransparent)
				{
					meshProcessed.data[model.meshes[i].meshNum].multiMesh = surfaceData.commonMesh;
					if (!MultiMeshes.ContainsKey(surfaceData.commonMesh))
					{
						Dictionary<Node3D, int> Set = new Dictionary<Node3D, int>();
						MultiMeshes.Add(surfaceData.commonMesh, Set);
					}

					if (!MultiMeshesInstances.ContainsKey(surfaceData.commonMesh))
					{
						MultiMeshInstance3D mesh = new MultiMeshInstance3D();
						mesh.Name = "MultiMesh_" + model.name;
						mesh.Multimesh = surfaceData.commonMesh;
						mesh.Layers = layer;
						if (!castShadows)
							mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
						GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
						MultiMeshesInstances.Add(surfaceData.commonMesh, mesh);
						mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
						if (useLightVol)
							mesh.SetInstanceShaderParameter("UseLightVol", true);
						if (receiveShadows)
						{
							Texture mainText = (Texture2D)surfaceData.readyMaterials.Get("shader_parameter/Tex_0");
							float luminance = .25f;
							if (mainText != null)
								if (mainText.HasMeta("luminance"))
									luminance = (float)mainText.GetMeta("luminance");
							mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
						}
					}
				}
				else
				{
					MeshInstance3D mesh = new MeshInstance3D();
					var surfaceArray = frameSurfaces.readySurfaceArray[i];
					meshProcessed.data[model.meshes[i].meshNum].arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
					meshProcessed.data[model.meshes[i].meshNum].arrMesh.SurfaceSetMaterial(0, surfaceData.readyMaterials);
					meshProcessed.data[model.meshes[i].meshNum].meshDataTool.CreateFromSurface(meshProcessed.data[model.meshes[i].meshNum].arrMesh, 0);
					mesh.Name = "Mesh_" + model.name;
					mesh.Mesh = meshProcessed.data[model.meshes[i].meshNum].arrMesh;
					mesh.Layers = layer;
					if (!castShadows)
						mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
					modelObject.AddChild(mesh);
					mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
					if (isViewModel)
						mesh.SetInstanceShaderParameter("ViewModel", true);
					if (useLightVol)
						mesh.SetInstanceShaderParameter("UseLightVol", true);
					if (receiveShadows)
					{
						Texture mainText = (Texture2D)surfaceData.readyMaterials.Get("shader_parameter/Tex_0");
						float luminance = .25f;
						if (mainText != null)
							if (mainText.HasMeta("luminance"))
								luminance = (float)mainText.GetMeta("luminance");
						mesh.SetInstanceShaderParameter(MaterialManager.shadowProperty, GameManager.Instance.shadowIntensity * luminance);
					}
				}
			}
			else
			{
				GameManager.Print("NO SKIN FOUND" + skinName);
				surfaceData = new SurfaceData();
				surfaceData.skinName = skinName;

				bool useTransparent = forceSkinAlpha;
				var surfaceArray = frameSurfaces.readySurfaceArray[i];

				ShaderMaterial material = MaterialManager.GetMaterials(skinName, -1, ref useTransparent);
				ArrayMesh arrMesh = new ArrayMesh();
				arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
				arrMesh.SurfaceSetMaterial(0, material);
				MultiMesh multiMesh = new MultiMesh();
				multiMesh.Mesh = arrMesh;
				multiMesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
				if (useColorData)
					multiMesh.UseColors = true;
				if (useLowMultimeshes)
					multiMesh.InstanceCount = LOW_USE_MULTIMESHES;
				else
					multiMesh.InstanceCount = HIGH_USE_MULTIMESHES;
				multiMesh.VisibleInstanceCount = 0;

				surfaceData.commonMesh = multiMesh;
				surfaceData.useTransparent = useTransparent;
				surfaceData.readyMaterials = material;
				frameSurfaces.surfaceIdbySkinName.Add(skinName + "_" + i, frameSurfaces.readySurfaces.Count());
				frameSurfaces.readySurfaces.Add(surfaceData);
				if (!MultiMeshes.ContainsKey(multiMesh))
				{
					Dictionary<Node3D, int> Set = new Dictionary<Node3D, int>();
					MultiMeshes.Add(multiMesh, Set);
				}

				meshProcessed.data[model.meshes[i].meshNum].isTransparent = useTransparent;
				if (useCommon && !useTransparent)
				{
					meshProcessed.data[model.meshes[i].meshNum].multiMesh = surfaceData.commonMesh;
					if (!MultiMeshesInstances.ContainsKey(surfaceData.commonMesh))
					{
						MultiMeshInstance3D mesh = new MultiMeshInstance3D();
						mesh.Name = "MultiMesh_" + model.name;
						mesh.Multimesh = surfaceData.commonMesh;
						mesh.Layers = layer;
						if (!castShadows)
							mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
						GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
						MultiMeshesInstances.Add(surfaceData.commonMesh, mesh);
						mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
						if (useLightVol)
							mesh.SetInstanceShaderParameter("UseLightVol", true);
					}
				}
				else
				{
					MeshInstance3D mesh = new MeshInstance3D();
					meshProcessed.data[model.meshes[i].meshNum].arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
					meshProcessed.data[model.meshes[i].meshNum].arrMesh.SurfaceSetMaterial(0, surfaceData.readyMaterials);
					meshProcessed.data[model.meshes[i].meshNum].meshDataTool.CreateFromSurface(meshProcessed.data[model.meshes[i].meshNum].arrMesh, 0);
					mesh.Mesh = meshProcessed.data[model.meshes[i].meshNum].arrMesh;
					mesh.Layers = layer;
					if (!castShadows)
						mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
					modelObject.AddChild(mesh);
					mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
					if (isViewModel)
						mesh.SetInstanceShaderParameter("ViewModel", true);
					if (useLightVol)
						mesh.SetInstanceShaderParameter("UseLightVol", true);
				}
			}
		}
		return meshProcessed;
	}

	public static MeshProcessed GenerateSprite(string spriteName, string textureName, float width, float height, uint layer, bool castShadows, float destroyTimer, Node3D ownerObject = null, bool forceSkinAlpha = false, bool useCommon = true, bool useLowMultimeshes = true)
	{
		if (ModelsManager.Sprites.ContainsKey(spriteName))
			return FillSpriteFromProcessedData(spriteName, layer, castShadows, destroyTimer, ownerObject, forceSkinAlpha, useCommon);

		if (ownerObject == null)
		{
			GameManager.Print("No ownerObject");
			ownerObject = new Node3D();
			ownerObject.Name = "Sprite_" + spriteName;
		}

		MeshProcessed meshProcessed = new MeshProcessed();
		meshProcessed.node = ownerObject;
		meshProcessed.numMeshes = 1;
		meshProcessed.data = new MeshProcessed.dataMeshes[meshProcessed.numMeshes];

		MeshProcessed.dataMeshes data = new MeshProcessed.dataMeshes();
		data.arrMesh =  GenerateQuadMesh(width, height, 0.5f, 0.5f);

		bool currentTransparent = forceSkinAlpha;
		ShaderMaterial material = MaterialManager.GetMaterials(textureName, -1, ref currentTransparent);

		meshProcessed.data[0] = data;
		data.isTransparent = currentTransparent;
		data.arrMesh.SurfaceSetMaterial(0, material);
		data.meshDataTool.CreateFromSurface(data.arrMesh, 0);
		MultiMesh multiMesh = new MultiMesh();
		data.multiMesh = multiMesh;
		multiMesh.Mesh = data.arrMesh;
		multiMesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
		multiMesh.UseColors = true;
		if (useLowMultimeshes)
			multiMesh.InstanceCount = LOW_USE_MULTIMESHES;
		else
			multiMesh.InstanceCount = HIGH_USE_MULTIMESHES;
		multiMesh.VisibleInstanceCount = 0;

		if (!MultiMeshSprites.ContainsKey(multiMesh))
		{
			List<SpriteData> Set = new List<SpriteData>(multiMesh.InstanceCount);
			MultiMeshSprites.Add(multiMesh, Set);
		}

		if (useCommon && !currentTransparent)
		{
			MultiMeshInstance3D mesh = new MultiMeshInstance3D();
			mesh.Name = "MultiMeshSprite_" + spriteName;
			mesh.Multimesh = multiMesh;
			mesh.Layers = layer;
			if (!castShadows)
				mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
			mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
			if (destroyTimer > 0)
				mesh.SetInstanceShaderParameter("LifeTime", destroyTimer);
			GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
			MultiMeshesInstances.Add(multiMesh, mesh);
			GameManager.Print("Adding MultiMesh : " + mesh.Name);
		}
		else
		{
			MeshInstance3D mesh = new MeshInstance3D();
			mesh.Name = spriteName;
			mesh.Mesh = data.arrMesh;
			mesh.Layers = layer;
			if (!castShadows)
				mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
			mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
			if (destroyTimer > 0)
				mesh.SetInstanceShaderParameter("LifeTime", destroyTimer);
			ownerObject.AddChild(mesh);
		}
		ModelsManager.Sprites.Add(spriteName, data);
		return meshProcessed;
	}
	public static MeshProcessed FillSpriteFromProcessedData(string spriteName, uint layer, bool castShadows, float destroyTimer, Node3D ownerObject = null, bool forceSkinAlpha = false, bool useCommon = true)
	{
		if (ownerObject == null)
		{
			GameManager.Print("No ownerObject");
			ownerObject = new Node3D();
			ownerObject.Name = "Sprite_" + spriteName;
		}

		MeshProcessed meshProcessed = new MeshProcessed();
		meshProcessed.node = ownerObject;
		meshProcessed.numMeshes = 1;
		meshProcessed.data = new MeshProcessed.dataMeshes[meshProcessed.numMeshes];

		MeshProcessed.dataMeshes data = ModelsManager.Sprites[spriteName];
		MultiMesh multiMesh = data.multiMesh;
		bool currentTransparent = forceSkinAlpha;
		meshProcessed.data[0] = data;

		if (useCommon && !currentTransparent)
		{
			if (!MultiMeshesInstances.ContainsKey(multiMesh))
			{
				MultiMeshInstance3D mesh = new MultiMeshInstance3D();
				mesh.Name = "MultiMeshSprite_" + spriteName;
				mesh.Multimesh = multiMesh;
				mesh.Layers = layer;
				if (!castShadows)
					mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
				GameManager.Instance.TemporaryObjectsHolder.AddChild(mesh);
				MultiMeshesInstances.Add(multiMesh, mesh);
				GameManager.Print("Adding MultiMesh : " + mesh.Name);
				mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
				if (destroyTimer > 0)
					mesh.SetInstanceShaderParameter("LifeTime", destroyTimer);
			}

			if (!MultiMeshSprites.ContainsKey(multiMesh))
			{
				List<SpriteData> Set = new List<SpriteData>(multiMesh.InstanceCount);
				MultiMeshSprites.Add(multiMesh, Set);
			}
		}
		else
		{
			MeshInstance3D mesh = new MeshInstance3D();
			mesh.Name = spriteName;
			mesh.Mesh = data.arrMesh;
			mesh.Layers = layer;
			if (!castShadows)
				mesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.Off;
			mesh.SetInstanceShaderParameter("OffSetTime", GameManager.CurrentTimeMsec);
			if (destroyTimer > 0)
				mesh.SetInstanceShaderParameter("LifeTime", destroyTimer);
			ownerObject.AddChild(mesh);
		}
		return meshProcessed;
	}

	public static Godot.Collections.Array GenerateModelMesh(MD3Mesh md3Mesh, int frame)
	{
		if (md3Mesh == null)
		{
			GameManager.Print("Failed to generate polygon mesh because there are no meshe info", GameManager.PrintType.Warning);
			return null;
		}

		var surfaceArray = new Godot.Collections.Array();
		surfaceArray.Resize((int)Mesh.ArrayType.Max);

		List<int> Triangles = new List<int>();

		for (int i = 0; i < md3Mesh.triangles.Count; i++)
		{
			Triangles.Add(md3Mesh.triangles[i].vertex1);
			Triangles.Add(md3Mesh.triangles[i].vertex2);
			Triangles.Add(md3Mesh.triangles[i].vertex3);
		}

		// add the verts
		surfaceArray[VertexInd] = md3Mesh.verts[frame].ToArray();

		// add normals
		surfaceArray[NormalInd] = md3Mesh.normals[frame].ToArray();

		// Add the texture co-ords (or UVs) to the surface/mesh
		surfaceArray[TexUVInd] = md3Mesh.texCoords.ToArray();

		// add the meshverts to the object being built
		surfaceArray[TriIndex] = Triangles.ToArray();

		return surfaceArray;
	}

	public static void GenerateModelMesh(MD3Mesh md3Mesh, int frame, ref int offset)
	{
		if (offset == 0)
		{
			vertsCache.Clear();
			uvCache.Clear();
			uv2Cache.Clear();
			normalsCache.Clear();
			indiciesCache.Clear();
			vertsColor.Clear();
		}

		vertsCache.AddRange(md3Mesh.verts[frame].ToArray());
		normalsCache.AddRange(md3Mesh.normals[frame].ToArray());
		uvCache.AddRange(md3Mesh.texCoords.ToArray());

		// Rip meshverts / triangles
		for (int i = 0; i < md3Mesh.triangles.Count; i++)
		{
			indiciesCache.Add(md3Mesh.triangles[i].vertex1 + offset);
			indiciesCache.Add(md3Mesh.triangles[i].vertex2 + offset);
			indiciesCache.Add(md3Mesh.triangles[i].vertex3 + offset);
		}
		offset += md3Mesh.verts[frame].Count;
	}
	public static Godot.Collections.Array FinalizeModelMesh()
	{
		var surfaceArray = new Godot.Collections.Array();
		surfaceArray.Resize((int)Mesh.ArrayType.Max);

		// add the verts, uvs, and normals we ripped to the surfaceArray
		surfaceArray[VertexInd] = vertsCache.ToArray();
		surfaceArray[NormalInd] = normalsCache.ToArray();

		// Add the texture co-ords (or UVs) to the surface/mesh
		surfaceArray[TexUVInd] = uvCache.ToArray();

		// add the meshverts to the object being built
		surfaceArray[TriIndex] = indiciesCache.ToArray();

		return surfaceArray;
	}

	public static ArrayMesh GenerateRagdollFromMesh(ArrayMesh arrMesh)
	{
		SurfaceTool st = new SurfaceTool();
		ArrayMesh ragdoll = new ArrayMesh();
		st.CreateFrom(arrMesh, 0);
		st.GenerateNormals();
		st.GenerateTangents();
		var surfaceArray = st.CommitToArrays();
		ragdoll.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);

		return ragdoll;
	}

	public static (uint, CollisionObject3D) GenerateGroupBrushCollider(int indexId, Node3D holder, QBrush[] brushes, CollisionObject3D objCollider = null, uint extraContentFlag = 0)
	{
		WaterSurface waterSurface = null;
		bool isWater = false;
		uint type = MapLoader.mapTextures[brushes[0].shaderId].contentsFlags;
		uint stype = MapLoader.mapTextures[brushes[0].shaderId].surfaceFlags;
		if (((type & ContentFlags.Details) != 0) || ((type & ContentFlags.Structural) != 0))
		{
			GameManager.Print("brushes: " + indexId + " Not used for collisions, Content Type is: " + type, GameManager.PrintType.Info);
			return (0 , null);
		}

		type |= extraContentFlag;

		if (((type & ContentFlags.Water) != 0) || ((type & ContentFlags.Lava) != 0) || ((type & ContentFlags.Slime) != 0))
		{
			isWater = true;
			if ((type & ContentFlags.Translucent) == 0)
			{
				GameManager.Print("brushes: " + indexId + " state it's liquid however it is not Translucent, Content Type is: " + type);
				return (0, null);
			}
		}
		else if ((type & MaskPlayerSolid) == 0)
		{
			GameManager.Print("brushes: " + indexId + " Is not solid, Content Type is: " + type);
			return (0, null);
		}

		ContentType contentType = new ContentType();
		contentType.Init(type);

		if (objCollider == null)
		{
			if (isWater)
			{
				waterSurface = new WaterSurface();
				if ((type & ContentFlags.Lava) != 0)
					waterSurface.damageable = WaterSurface.DamageableType.Lava;
				else if ((type & ContentFlags.Slime) != 0)
					waterSurface.damageable = WaterSurface.DamageableType.Slime;
				objCollider = waterSurface;
			}
			else
				objCollider = new StaticBody3D();

			if (isWater)
				objCollider.Name = "Water_" + indexId + "_collider";
			else
				objCollider.Name = "Polygon_" + indexId + "_collider";

			holder.AddChild(objCollider);
		}
		else if (isWater)
		{
			if (objCollider is WaterSurface)
				waterSurface = (WaterSurface)objCollider;
			else
			{
				waterSurface = new WaterSurface();
				if ((type & ContentFlags.Lava) != 0)
					waterSurface.damageable = WaterSurface.DamageableType.Lava;
				else if ((type & ContentFlags.Slime) != 0)
					waterSurface.damageable = WaterSurface.DamageableType.Slime;
				objCollider.AddChild(waterSurface);
				objCollider = waterSurface;
			}
		}

		if (!MapLoader.mapContentTypes.ContainsKey(objCollider))
			MapLoader.mapContentTypes.Add(objCollider, contentType);

		uint OwnerShapeId = objCollider.CreateShapeOwner(holder);
		bool gotValidShapes = false;
		for (int i = 0; i < brushes.Length; i++)
		{
			ConvexPolygonShape3D convexHull = GenerateBrushCollider(brushes[i]);
			if (convexHull == null)
				continue;

			gotValidShapes = true;
			//Fill Map BB
			Aabb box = convexHull.GetDebugMesh().GetAabb();
			MapLoader.mapBounds = MapLoader.mapBounds.Merge(box);
			objCollider.ShapeOwnerAddShape(OwnerShapeId, convexHull);
			if (isWater)
			{
				waterSurface.Boxes.Add(box);
				GenerateWaterFog(indexId + "_" + i, holder, box, waterSurface.damageable);
			}
		}

		//No a single shape was valid
		if (!gotValidShapes)
			return (0, null);

		SurfaceType surfaceType = new SurfaceType();
		surfaceType.Init(stype);

		if ((surfaceType.value & MaskTransparent) != 0)
			objCollider.CollisionLayer = (1 << GameManager.InvisibleBlockerLayer);
		else
			objCollider.CollisionLayer = (1 << GameManager.ColliderLayer);
		objCollider.InputRayPickable = false;

		if (isWater)
		{
			objCollider.CollisionLayer |= ((1 << GameManager.FogLayer) | (1 << GameManager.WaterLayer));
			MapLoader.waterSurfaces.Add(waterSurface);
			MapLoader.noMarks.Add(objCollider);
		}
		//If noMarks add it to the table
		else if ((surfaceType.value & NoMarks) != 0)
			MapLoader.noMarks.Add(objCollider);

		objCollider.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		if (isWater)
			objCollider.CollisionMask |= (1 << GameManager.PhysicCollisionLayer);

		if (!MapLoader.mapSurfaceTypes.ContainsKey(objCollider))
			MapLoader.mapSurfaceTypes.Add(objCollider, surfaceType);

		return (OwnerShapeId, objCollider);
	}

	public static ConvexPolygonShape3D GenerateBrushCollider(QBrush brush)
	{
		var brushPlanes = new Godot.Collections.Array<Plane>();
		List<Vector3> intersectPoint = new List<Vector3>();

		for (int i = 0; i < brush.numOfBrushSides; i++)
		{
			int planeIndex = MapLoader.brushSides[brush.brushSide + i].plane;
			brushPlanes.Add(MapLoader.planes[planeIndex]);
		}
		intersectPoint.AddRange(Geometry3D.ComputeConvexMeshPoints(brushPlanes));
		intersectPoint = RemoveDuplicatedVectors(intersectPoint);
		Vector3 normal = Vector3.Zero;
		if (!CanForm3DConvexHull(intersectPoint, ref normal))
		{
			GameManager.Print("GenerateGroupBrushCollider: Cannot Form 3DConvexHull " + brush.brushSide + " this was a waste of time", GameManager.PrintType.Warning);
			return null;
		}

		ConvexPolygonShape3D convexHull = new ConvexPolygonShape3D();
		convexHull.Points = intersectPoint.ToArray();

		return convexHull;
	}

	public static bool GenerateBrushCollider(QBrush brush, Node3D holder, CollisionObject3D objCollider = null, bool addRigidBody = false, uint extraContentFlag = 0)
	{
		bool isTrigger = false;
		//Remove brushed used for BSP Generations and for Details
		uint type = MapLoader.mapTextures[brush.shaderId].contentsFlags;

		if (((type & ContentFlags.Details) != 0) || ((type & ContentFlags.Structural) != 0))
		{
			GameManager.Print("GenerateBrushCollider: brushSide: " + brush.brushSide + " Not used for collisions, Content Type is: " + type);
			return false;
		}

		var brushPlanes = new Godot.Collections.Array<Plane>();
		List<Vector3> intersectPoint = new List<Vector3>();

		for (int i = 0; i < brush.numOfBrushSides; i++)
		{
			int planeIndex = MapLoader.brushSides[brush.brushSide + i].plane;
			brushPlanes.Add(MapLoader.planes[planeIndex]);
		}
		intersectPoint.AddRange(Geometry3D.ComputeConvexMeshPoints(brushPlanes));
		intersectPoint = RemoveDuplicatedVectors(intersectPoint);
		Vector3 normal = Vector3.Zero;
		if (!CanForm3DConvexHull(intersectPoint, ref normal))
		{
			GameManager.Print("GenerateBrushCollider: Cannot Form 3DConvexHull " + brush.brushSide + " this was a waste of time", GameManager.PrintType.Warning);
			return false;
		}

		ContentType contentType = new ContentType();
		contentType.Init(type | extraContentFlag);

		if ((contentType.value & MaskPlayerSolid) == 0)
			isTrigger = true;

		if (objCollider == null)
		{
			if (isTrigger)
				objCollider = new Area3D();
			else if (addRigidBody)
				objCollider = new AnimatableBody3D();
			else
				objCollider = new StaticBody3D();
			objCollider.Name = "Polygon_" + brush.brushSide + "_collider";
			holder.AddChild(objCollider);
		}
		objCollider.CollisionLayer = (1 << GameManager.ColliderLayer);
		objCollider.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		objCollider.InputRayPickable = false;

		CollisionShape3D mc = new CollisionShape3D();
		mc.Name = "brushSide: " + brush.brushSide;
		objCollider.AddChild(mc);

		if (!MapLoader.mapContentTypes.ContainsKey(objCollider))
			MapLoader.mapContentTypes.Add(objCollider, contentType);

		ConvexPolygonShape3D convexHull = new ConvexPolygonShape3D();
		convexHull.Points = intersectPoint.ToArray();
		mc.Shape = convexHull;

//		if ((contentType.value & ContentFlags.PlayerClip) == 0)
//			objCollider.layer = GameManager.InvisibleBlockerLayer;

		type = MapLoader.mapTextures[brush.shaderId].surfaceFlags;
		SurfaceType surfaceType = new SurfaceType();
		surfaceType.Init(type);

		if (!MapLoader.mapSurfaceTypes.ContainsKey(objCollider))
			MapLoader.mapSurfaceTypes.Add(objCollider, surfaceType);

//		if ((surfaceType.value & NoMarks) != 0)
//			MapLoader.noMarks.Add(mc);

		if ((surfaceType.value & MaskTransparent) != 0)
			objCollider.CollisionLayer = (1 << GameManager.InvisibleBlockerLayer);

//		if ((type & SurfaceFlags.NonSolid) != 0)
//			GameManager.Print("brushSide: " + brush.brushSide + " Surface Type is: " + type);

		return true;
	}

	public static ArrayMesh GenerateQuadMesh(float width, float height, float pivotX, float pivotY)
	{
		Vector3[] vertices = new Vector3[4];
		Vector2[] uvs = new Vector2[4];
		int[] indices = new int[6];
		var surfaceArray = new Godot.Collections.Array();
		surfaceArray.Resize((int)Mesh.ArrayType.Max);

		float x0 = -width * pivotX;
		float x1 = width * (1 - pivotX);
		float y0 = -height * pivotY;
		float y1 = height * (1 - pivotY);

		vertices[0] = new Vector3(x0, y0, 0);
		vertices[1] = new Vector3(x1, y0, 0);
		vertices[2] = new Vector3(x0, y1, 0);
		vertices[3] = new Vector3(x1, y1, 0);

		indices[0] = 2;
		indices[1] = 1;
		indices[2] = 0;
		indices[3] = 3;
		indices[4] = 1;
		indices[5] = 2;

		uvs[0] = new Vector2(0, 0);
		uvs[1] = new Vector2(1, 0);
		uvs[2] = new Vector2(0, 1);
		uvs[3] = new Vector2(1, 1);

		surfaceArray[VertexInd] = vertices.ToArray();
		surfaceArray[TexUVInd] = uvs.ToArray();
		surfaceArray[TriIndex] = indices.ToArray();

		ArrayMesh arrMesh = new ArrayMesh();
		arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
		return arrMesh;
	}
	public static void GenerateWaterFog(string Name, Node3D holder, Aabb box, WaterSurface.DamageableType type)
	{
		FogVolume Fog = new FogVolume();
		Fog.Name = "FogVolume_" + Name;
		holder.AddChild(Fog);

		Fog.Layers = GameManager.AllPlayerViewMask;
		Fog.Position = box.GetCenter();
		Fog.Shape = RenderingServer.FogVolumeShape.Box;
		Fog.Size = box.Size;
		switch (type)
		{
			default:
			case WaterSurface.DamageableType.None:
				Fog.Material = MaterialManager.waterFogMaterial;
				break;
			case WaterSurface.DamageableType.Lava:
				Fog.Material = MaterialManager.lavaFogMaterial;
			break;
			case WaterSurface.DamageableType.Slime:
				Fog.Material = MaterialManager.slimeFogMaterial;
			break;
		}
	}
	public static void GenerateVolumetricFog(int index, QBrush brush, Node3D holder, string textureName)
	{
		ConvexPolygonShape3D convexHull = GenerateBrushCollider(brush);
		if (convexHull == null)
			return;

		FogVolume Fog = new FogVolume();
		Fog.Name = "FogVolume_" + index + "_"+ textureName;
		holder.AddChild(Fog);

		Area3D fogArea = new Area3D();
		fogArea.Name = "FogArea_" + index;
		fogArea.CollisionLayer = (1 << GameManager.FogLayer);
		fogArea.CollisionMask = (1 << GameManager.PhysicCollisionLayer);
		fogArea.InputRayPickable = false;

		holder.AddChild(fogArea);

		CollisionShape3D mc = new CollisionShape3D();
		mc.Shape = convexHull;
		fogArea.AddChild(mc);

		Aabb box = convexHull.GetDebugMesh().GetAabb();
		Fog.Layers = GameManager.AllPlayerViewMask;
		Fog.Position = box.GetCenter();
		Fog.Shape = RenderingServer.FogVolumeShape.Box;
		Fog.Size = box.Size;
		Fog.Material = QShaderManager.GetFog(textureName, Fog.Size.Y);
		GameManager.Print("FOG: " + textureName + " Height " + Fog.Size.Y);
	}

	public static bool CanForm3DConvexHull(List<Vector3> points, ref Vector3 normal, float DISCARD_LIMIT = 0.00001f, bool retried = true)
	{
		int i;

		// Calculate a normal vector
		tryagain:
		if (points.Count < 4)
			return false;

		for (i = 0; i < points.Count; i++)
		{
			Vector3 v1 = points[1] - points[i];
			Vector3 v2 = points[2] - points[i];
			normal = v1.Cross(v2);

			// check that v1 and v2 were NOT collinear
			if (normal.LengthSquared() > 0)
				break;
			if (i == 0)
				i = 2;
		}

		//Check if we got a normal
		if (i == points.Count)
		{
			if (retried)
				return false;
			retried = true;
			points = RemoveDuplicatedVectors(points);
			goto tryagain;
		}

		// Check if all points lie on the plane
		for (i = 0; i < points.Count; i++)
		{
			Vector3 px = points[i] - points[0];
			float dotProduct = px.Dot(normal);

			if (Mathf.Abs(dotProduct) > DISCARD_LIMIT)
				return true;
		}
		
		normal = normal.Normalized();

		return false;
	}

	public static List<Vector3> GetExtrudedVerticesFromPoints(List<Vector3> points, Vector3 normal)
	{
		List<Vector3> vertices = new List<Vector3>(points.Count * 2);
		float depth = 0.002f;
		vertices.AddRange(points);
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 vertice = new Vector3(points[i].X - depth * normal.X, points[i].Y - depth * normal.Y, points[i].Z + depth * normal.Z);
			vertices.Add(vertice);
		}

		return vertices;
	}

	public static List<Vector3> RemoveDuplicatedVectors(List<Vector3> test)
	{
		List<Vector3> uniqueVector = new List<Vector3>();
		Vector3 previousPoint = Vector3.Zero;
		for (int i = 0; i < test.Count; i++)
		{
			bool isUnique = true;
			for (int j = i + 1; j < test.Count; j++)
			{ 
				if (FloatAprox(test[i].X, test[j].X) &&
					FloatAprox(test[i].Y, test[j].Y) &&
					FloatAprox(test[i].Z, test[j].Z))
						isUnique = false;
			}
			if (isUnique)
			{
				if (uniqueVector.Count > 0)
					uniqueVector = uniqueVector.OrderBy(n => (n - previousPoint).LengthSquared()).ToList();
				uniqueVector.Add(new Vector3(RoundUp4Decimals(test[i].X), RoundUp4Decimals(test[i].Y), RoundUp4Decimals(test[i].Z)));
				previousPoint = uniqueVector[uniqueVector.Count - 1];
			}
		}
		return uniqueVector;
	}
	public static bool FloatAprox(float f1, float f2)
	{
		float d = f1 - f2;

		if (d < -APROX_ERROR || d > APROX_ERROR)
			return false;
		return true;
	}
	public static float RoundUp4Decimals(float f)
	{
		float d = Mathf.CeilToInt(f * 10000) / 10000.0f;
		return d;
	}

	public static void AddSpriteToMultiMeshes(MultiMesh multiMesh, SpriteData sprite, Color color)
	{
		List<SpriteData> spriteDataList;
		int instanceNum;
		if (MultiMeshSprites.TryGetValue(multiMesh, out spriteDataList))
		{
			instanceNum = spriteDataList.Count;
			int threshold = (multiMesh.InstanceCount >> 1);
			if (instanceNum > threshold)
			{
				foreach (SpriteData spriteToDestroy in spriteDataList)
				{
					if (spriteToDestroy.readyToDestroy)
						continue;

					spriteToDestroy.readyToDestroy = true;
					spriteToDestroy.GlobalPosition = MapLoader.mapMinCoord * 2f;
					break;
				}
			}

			spriteDataList.Add(sprite);
			multiMesh.VisibleInstanceCount = instanceNum + 1;
			if (multiMesh.UseColors)
				multiMesh.SetInstanceColor(instanceNum, color);
			multiMesh.SetInstanceTransform(instanceNum, sprite.GlobalTransform);
		}
	}
	public static void AddNodeToMultiMeshes(MultiMesh multiMesh, Node3D owner, Color color)
	{
		Dictionary<Node3D, int> multiMeshSet;
		int instanceNum;
		if (MultiMeshes.TryGetValue(multiMesh, out multiMeshSet))
		{
			if (multiMeshSet.ContainsKey(owner))
				return;

			instanceNum = multiMeshSet.Count;
			int threshold = (multiMesh.InstanceCount >> 1);
			if (instanceNum > threshold)
			{
				foreach (Node3D node3D in multiMeshSet.Keys)
				{
					if (node3D.HasMeta("destroying"))
						continue;

					Node parent = node3D.GetParent();
					{
						Node child = node3D;
						while (parent != GameManager.Instance.TemporaryObjectsHolder)
						{
							child = parent;
							parent = child.GetParent();
						}
						parent = child;
					}
		
					DestroyAfterTime destroy = new DestroyAfterTime();
					parent.AddChild(destroy);
					destroy.Start();
					node3D.SetMeta("destroying", true);
					break;
				}
			}

			multiMeshSet.Add(owner, instanceNum);
			if (multiMesh.UseColors)
				multiMesh.SetInstanceColor(instanceNum, color);
			multiMesh.SetInstanceTransform(instanceNum, owner.GlobalTransform);
			multiMesh.VisibleInstanceCount = instanceNum + 1;
		}
	}
	public static void UpdateInstanceMultiMesh(MultiMesh multiMesh, Node3D owner)
	{
		Dictionary<Node3D, int> multiMeshSet;
		if (MultiMeshes.TryGetValue(multiMesh, out multiMeshSet))
		{
			int index;
			if (!multiMeshSet.TryGetValue(owner, out index))
				return;

			if (owner.IsVisibleInTree())
				multiMesh.SetInstanceTransform(index, owner.GlobalTransform);
			else //Move it out of the map
			{
				Transform3D min = new Transform3D(owner.Basis, MapLoader.mapMinCoord * 2f);
				multiMesh.SetInstanceTransform(index, min);
			}
		}
	}
	public static void UpdateInstanceMultiMesh(MultiMesh multiMesh, Node3D owner, Color color)
	{
		Dictionary<Node3D, int> multiMeshSet;
		if (MultiMeshes.TryGetValue(multiMesh, out multiMeshSet))
		{
			int index; 
			if (!multiMeshSet.TryGetValue(owner, out index))
				return;

			multiMesh.SetInstanceColor(index, color);
			if (owner.IsVisibleInTree())
				multiMesh.SetInstanceTransform(index, owner.GlobalTransform);
			else //Move it out of the map
			{
				Transform3D min = new Transform3D(owner.Basis, MapLoader.mapMinCoord * 2f);
				multiMesh.SetInstanceTransform(index, min);
			}
		}
	}
	public static void MultiMeshUpdateInstances(MultiMesh multiMesh)
	{
		if (MultiMeshesChanged.Contains(multiMesh))
			return;
		MultiMeshesChanged.Add(multiMesh);
	}

	public static void UpdateChangedMultiMeshes()
	{
		foreach(MultiMesh multiMesh in MultiMeshesChanged)
		{
			Dictionary<Node3D, int> multiMeshSet;
			if (MultiMeshes.TryGetValue(multiMesh, out multiMeshSet))
			{
				multiMesh.VisibleInstanceCount = multiMeshSet.Count;
				int i = 0;
				foreach (var instance in multiMeshSet)
				{
					Node3D node = instance.Key;
					multiMeshSet[node] = i;
					if (node.IsVisibleInTree())
						multiMesh.SetInstanceTransform(i, node.GlobalTransform);
					else
					{
						Transform3D min = new Transform3D(node.Basis, MapLoader.mapMinCoord * 2f);
						multiMesh.SetInstanceTransform(i, min);
					}
					i++;
				}
			}
		}
		MultiMeshesChanged.Clear();
	}


	public static void ProcessSprites(float deltaTime)
	{
		bool destroyTime = ((Engine.GetFramesDrawn() % 300) == 0);
		List<SpriteData> detroyDataList = new List<SpriteData>();
		int i = 0;
		foreach (var keyValuePair in MultiMeshSprites)
		{
			MultiMesh multiMesh = keyValuePair.Key;
			List<SpriteData> spriteDataList = keyValuePair.Value;
			detroyDataList.Clear();
			int oldCount = spriteDataList.Count;
			for(i = 0; i < oldCount; i++)
			{
				spriteDataList[i].Process(deltaTime);
				if ((destroyTime) && (spriteDataList[i].readyToDestroy))
					detroyDataList.Add(spriteDataList[i]);
			}
			bool forceUpdate = false;
			if (destroyTime)
			{
				for (i = 0; i < detroyDataList.Count; i++)
					detroyDataList[i].Destroy();

				multiMesh.VisibleInstanceCount = spriteDataList.Count;
				forceUpdate = (oldCount != multiMesh.VisibleInstanceCount);
			}

			for (i = 0; i < spriteDataList.Count; i++)
			{
				if ((forceUpdate) || (spriteDataList[i].update))
				{
					if (spriteDataList[i].update)
						spriteDataList[i].update = false;
					multiMesh.SetInstanceColor(i, spriteDataList[i].Modulate);
					multiMesh.SetInstanceTransform(i, spriteDataList[i].GlobalTransform);
				}
			}
		}
	}

}

```

./Assets/Scripts/Player/PlayerPostProcessing.cs:
```
using Godot;
using System;

public partial class PlayerPostProcessing : Node3D
{
	[Export]
	public Camera3D ViewPortCamera;
	[Export]
	public Camera3D NormalDepthCamera;
	[Export]
	public SubViewport ViewPort;
	[Export]
	public SubViewport NormalDepthViewPort;
	[Export]
	public PlayerHUD playerHUD;
	public uint ViewMask;
	public uint UIMask;

	public void InitPost(PlayerInfo p)
	{
		ViewPortCamera.CullMask = UIMask;
		NormalDepthCamera.CullMask = ViewMask | UIMask | (1 << GameManager.PlayerNormalDepthLayer);
		SetLocalViewPortToCamera(NormalDepthCamera, NormalDepthViewPort);
		playerHUD.Layers = UIMask;
		playerHUD.baseViewPortTexture = ViewPort.GetTexture();
		playerHUD.normalDepthViewPortTexture = NormalDepthViewPort.GetTexture();
		playerHUD.NormalDepthCamera = NormalDepthCamera;
		playerHUD.Init(p);
	}

	public void UpdateLayersPost()
	{
		ViewPortCamera.CullMask = UIMask;
		NormalDepthCamera.CullMask = ViewMask | UIMask | (1 << GameManager.PlayerNormalDepthLayer);
		playerHUD.Layers = UIMask;
		playerHUD.UpdateLayersHud(UIMask);
	}

	public void SetWaterEffect()
	{
		playerHUD.SetCameraReplacementeMaterial(MaterialManager.Instance.underWaterMaterial);
	}

	public void ResetEffects()
	{
		playerHUD.SetCameraReplacementeMaterial(null);
	}

	public void ChangeCurrentCamera(Camera3D camera, bool thirdPerson)
	{
		if (!camera.IsAncestorOf(NormalDepthCamera))
		{
			NormalDepthCamera.Reparent(camera);
			NormalDepthCamera.Transform = Transform3D.Identity;
		}
		NormalDepthCamera.CullMask = ViewMask | (1 << GameManager.PlayerNormalDepthLayer);
		if (!thirdPerson)
			NormalDepthCamera.CullMask |= UIMask;
	}

	public void SetLocalViewPortToCamera(Camera3D camera, Viewport viewport = null)
	{
		var CamRID = camera.GetCameraRid();
		Rid viewPortRID;
		if (viewport == null)
			viewport = ViewPort;
		viewPortRID = viewport.GetViewportRid();
		RenderingServer.ViewportAttachCamera(viewPortRID, CamRID);
	}

}
```

./Assets/Scripts/Player/Weapons/NailgunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class NailgunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .031f; } }
	public override float horizontalDispersion { get { return .035f; } }

	[Export]
	public string AttackProjectileName;

	public string onDeathSpawn = "BulletHit";
	public string decalMark = "ShotMark";

	public float maxRange = 400f;
	public float pushForce = 350;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.nailAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;

		}
	}

	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.nailAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.nailAmmo]);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.nailAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.nailAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.nailAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		//Hitscan attack
		Transform3D global = playerInfo.playerCamera.GlobalTransform;
		Vector3 d = global.ForwardVector();

		for (int i = 0; i < 10; i++)
		{
			Projectile nail = (Projectile)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(nail);
			nail.owner = playerInfo.playerThing;
			if (hasQuad)
				nail.EnableQuad();
			if (muzzleObject != null)
				nail.GlobalPosition = muzzleObject.GlobalPosition + d;
			else
				nail.GlobalPosition = global.Origin;
			nail.ignoreSelfLayer = playerInfo.playerLayer;
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			nail.SetForward(-d);
			nail.InvoqueSetTransformReset();
		}

		return true;
	}
}
```

./Assets/Scripts/Player/Weapons/GauntletWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;
public partial class GauntletWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .017f; } } // tan(2) / 2
	public override float horizontalDispersion { get { return .049f; } } // tan(5.6) / 2

	public float maxRange = 1f;

	[Export]
	public MultiAudioStream humStream;
	[Export]
	public string _humSound;
	[Export]
	public float HasteFireRate = 3;

	public float barrelSpeed = 10;
	public float hastebarrelSpeed = 11;
	private float currentRotSpeed = 0;

	private int lastHit = 0;
	protected override void OnUpdate(float deltaTime)
	{
		if (fireTime <= 0)
		{
			if (humStream.Playing)
				humStream.Stop();
		}
	}

	protected override void OnInit()
	{
		_hasteFireRate = HasteFireRate;
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		humStream.Stream = SoundManager.LoadSound(_humSound, true);
		playerInfo.playerPostProcessing.playerHUD.HideAmmo(true);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}

		if (fireTime <= 0)
		{
			if (hasQuad)
				SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

			humStream.Play();
		}

		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;

		fireTime = .15f;
		coolTimer = 0f;

		//Hitscan attack
		if (lastHit > 0)
			lastHit --;
		else if (lastHit <= 0)
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, (GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer) | (1 << GameManager.RagdollLayer))));
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				if (collider is Damageable damageable)
				{
					lastHit = (int)currentFireRate;
					if (hasQuad)
						damageable.Damage(GD.RandRange(DamageMin * GameManager.Instance.QuadMul, DamageMax * GameManager.Instance.QuadMul), DamageType.Melee, playerInfo.playerThing);
					else
						damageable.Damage(GD.RandRange(DamageMin, DamageMax), DamageType.Melee, playerInfo.playerThing);
					if (Sounds.Length > 0)
					{
						audioStream.Stream = Sounds[0];
						audioStream.Play();
					}
					return true;
				}

			}
		}

		return false;
	}
	protected override Quaternion RotateBarrel(float deltaTime)
	{
		if (fireTime > 0f)
		{
			float currenBarrelSpeed = barrelSpeed;
			if (playerInfo.haste)
				currenBarrelSpeed = hastebarrelSpeed;
			currentRotSpeed += currenBarrelSpeed * deltaTime;
			if (currentRotSpeed >= 360)
				currentRotSpeed -= 360;
		}
		return new Quaternion(Vector3.Left, currentRotSpeed);
	}
}
```

./Assets/Scripts/Player/Weapons/PlasmagunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class PlasmagunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .02f; } }
	public override float horizontalDispersion { get { return .02f; } }
	[Export]
	public string AttackProjectileName;
	public Vector3 spawnPos;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.cellsAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;
		}
	}
	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.cellsAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.cellsAmmo]);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.cellsAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.cellsAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.cellsAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		//Projectile attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();

			Projectile plasma = (Projectile)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(plasma);
			plasma.owner = playerInfo.playerThing;
			if (hasQuad)
				plasma.EnableQuad();
			if (muzzleObject != null)
				plasma.GlobalPosition = muzzleObject.GlobalPosition + d;
			else
				plasma.GlobalPosition = global.Origin;
			plasma.ignoreSelfLayer = playerInfo.playerLayer;
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			plasma.SetForward(-d);
			plasma.InvoqueSetTransformReset();
		}

		return true;
	}
}```

./Assets/Scripts/Player/Weapons/GrenadeLauncherWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class GrenadeLauncherWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .02f; } }
	public override float horizontalDispersion { get { return .02f; } }
	[Export]
	public string AttackProjectileName;
	[Export]
	public AnimationTree weaponAnimation;
	[Export]
	public float animationSpeed = 1;

	public Vector3 spawnPos;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.grenadesAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;
		}
	}
	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.grenadesAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.grenadesAmmo]);

		weaponAnimation.Active = true;
		weaponAnimation.Set("parameters/fire_shot/active", true);
		weaponAnimation.Set("parameters/TimeScale/scale", animationSpeed);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.grenadesAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.grenadesAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.grenadesAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		weaponAnimation.Set("parameters/fire_shot/request", (int)AnimationNodeOneShot.OneShotRequest.Fire);
		//Projectile attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();

			PhysicProjectile grenade = (PhysicProjectile)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(grenade);
			grenade.owner = playerInfo.playerThing;
			if (hasQuad)
				grenade.EnableQuad();
			if (muzzleObject != null)
				grenade.GlobalPosition = muzzleObject.GlobalPosition + d;
			else
				grenade.GlobalPosition = global.Origin;
			grenade.Init(playerInfo.playerLayer);
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			grenade.SetForward(d);
			Vector3 velocity = -d * 25;
			grenade.LinearVelocity = velocity;
			velocity = new Vector3((float)GD.RandRange(-20f, 20f), (float)GD.RandRange(5f, 10f), (float)GD.RandRange(-20f, 20f));
			grenade.AngularVelocity = velocity;
		}

		return true;
	}
}
```

./Assets/Scripts/Player/Weapons/ProxLauncherWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;
public partial class ProxLauncherWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .02f; } }
	public override float horizontalDispersion { get { return .02f; } }
	[Export]
	public string AttackProjectileName;
	[Export]
	public AnimationTree weaponAnimation;
	[Export]
	public float animationSpeed = 1;

	public Vector3 spawnPos;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.minesAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;
		}
	}
	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.minesAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.minesAmmo]);

		weaponAnimation.Active = true;
		weaponAnimation.Set("parameters/fire_shot/active", true);
		weaponAnimation.Set("parameters/TimeScale/scale", animationSpeed);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.minesAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.minesAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.minesAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		weaponAnimation.Set("parameters/fire_shot/request", (int)AnimationNodeOneShot.OneShotRequest.Fire);
		//Projectile attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();

			PhysicProjectile mine = (PhysicProjectile)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(mine);
			mine.owner = playerInfo.playerThing;
			if (hasQuad)
				mine.EnableQuad();
			if (muzzleObject != null)
				mine.GlobalPosition = muzzleObject.GlobalPosition + d;
			else
				mine.GlobalPosition = global.Origin;
			mine.Init(playerInfo.playerLayer);
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			mine.SetForward(d);
			Vector3 velocity = -d * 20;
			mine.LinearVelocity = velocity;
			velocity = new Vector3((float)GD.RandRange(-20f, 20f), (float)GD.RandRange(5f, 10f), (float)GD.RandRange(-20f, 20f));
			mine.AngularVelocity = velocity;
		}

		return true;
	}
}
```

./Assets/Scripts/Player/Weapons/MachineGunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class MachineGunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .049f; } } // tan(5.6) / 2
	public override float horizontalDispersion { get { return .049f; } } // tan(5.6) / 2

	public string caseName = "MachineGunAmmoCase";
	public string onDeathSpawn = "BulletHit";
	public string decalMark = "BulletMark";
	public float maxRange = 400f;

	public float barrelSpeed = 10;
	public float hastebarrelSpeed = 11;
	private float currentRotSpeed = 0;

	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.bulletsAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;

		}
	}

	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.bulletsAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.bulletsAmmo]);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.bulletsAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.bulletsAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.bulletsAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}
		
		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		//Hitscan attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer))));
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				Vector3 collision = (Vector3)hit["position"];
				Vector3 normal = (Vector3)hit["normal"];
				bool hitFx = true;
				if (collider is Damageable damageable)
				{
					if (hasQuad)
						damageable.Damage(GD.RandRange(DamageMin * GameManager.Instance.QuadMul, DamageMax * GameManager.Instance.QuadMul), DamageType.Bullet, playerInfo.playerThing);
					else
						damageable.Damage(GD.RandRange(DamageMin, DamageMax), DamageType.Bullet, playerInfo.playerThing);

					if (damageable.Bleed)
					{
						hitFx = false;
						Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
						Blood.GlobalPosition = collision + (normal * .05f);
					}
				}
				if (hitFx)
				{
					Node3D BulletHit = (Node3D)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletHit);
					BulletHit.Position = collision + (normal * .2f);
					BulletHit.SetForward(normal);
					BulletHit.Rotate(BulletHit.UpVector(), -Mathf.Pi * .5f);
					BulletHit.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				}

				if (Sounds.Length > 3)
					SoundManager.Create3DSound(collision, Sounds[GD.RandRange(3, Sounds.Length - 1)]);

				if (CheckIfCanMark(SpaceState, collider, collision))
				{
					SpriteController BulletMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletMark);
					BulletMark.GlobalPosition = collision + (normal * .05f);
					BulletMark.SetForward(normal);
					BulletMark.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (collider is Crusher)
						BulletMark.referenceNode = collider;
				}
			}
		}

		//Case Drop
		if (!string.IsNullOrEmpty(caseName))
		{
			RigidBody3D ammocase = (RigidBody3D)ThingsManager.thingsPrefabs[caseName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(ammocase);
			ammocase.Position = GlobalPosition;
			ammocase.Quaternion = new Quaternion(Vector3.Right, currentRotSpeed);
			ammocase.ApplyImpulse(new Vector3((float)GD.RandRange(-.2f, .02f), (float)GD.RandRange(.2f, .4f), (float)GD.RandRange(-.2f, .2f)));
		}
		return true;
	}
	protected override Quaternion RotateBarrel(float deltaTime)
	{
		if (fireTime > 0f)
		{
			float currenBarrelSpeed = barrelSpeed;
			if (playerInfo.haste)
				currenBarrelSpeed = hastebarrelSpeed;
			currentRotSpeed += currenBarrelSpeed * deltaTime;
			if (currentRotSpeed >= 360)
				currentRotSpeed -= 360;
		}
		return new Quaternion(Vector3.Left, currentRotSpeed);
	}
}
```

./Assets/Scripts/Player/Weapons/BFG10KWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class BFG10KWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .02f; } }
	public override float horizontalDispersion { get { return .02f; } }
	[Export]
	public string AttackProjectileName;
	public Vector3 spawnPos;
	[Export]
	public MultiAudioStream humStream;
	[Export]
	public string[] _humSounds;
	public AudioStream[] humSounds;

	private float chargeDelay = 0;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.bfgAmmo] < 40 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;
		}
	}

	protected override void OnPhysicsUpdate(float deltaTime)
	{
		if (chargeDelay > 0)
		{
			muzzleObject.Scale = Vector3.One * Mathf.Max(Mathf.Lerp(1, 0.1f, chargeDelay), 0);
			playerInfo.playerThing.avatar.MuzzleFlashSetScale(muzzleObject.Scale);
			chargeDelay -= deltaTime;
		}

		if (chargeDelay < 0)
		{
			chargeDelay = 0;

			playerInfo.Ammo[PlayerInfo.bfgAmmo] -= 40;
			playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.bfgAmmo]);

			if (GameOptions.UseMuzzleLight)
			{
				if (muzzleLight != null)
				{
					muzzleLight.Show();
					muzzleLight.LightEnergy = 1.0f;
					if (muzzleObject != null)
						if (!muzzleObject.Visible)
						{
							muzzleObject.Scale = Vector3.One;
							muzzleObject.Visible = true;
							playerInfo.playerThing.avatar.MuzzleFlashSetScale(Vector3.One);
							playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
						}
				}
			}

			humStream.Stream = humSounds[0];
			humStream.Play();

			if (Sounds.Length > 0)
				SoundManager.Create3DSound(GlobalPosition, Sounds[0]);

			if (hasQuad)
				SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

			playerInfo.playerThing.avatar.Attack();
			//Projectile attack
			{
				Transform3D global = playerInfo.playerCamera.GlobalTransform;
				Vector3 d = global.ForwardVector();

				Projectile bfgBall = (Projectile)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(bfgBall);
				bfgBall.owner = playerInfo.playerThing;
				if (hasQuad)
					bfgBall.EnableQuad();
				if (muzzleObject != null)
					bfgBall.GlobalPosition = muzzleObject.GlobalPosition + d;
				else
					bfgBall.GlobalPosition = global.Origin;
				bfgBall.ignoreSelfLayer = playerInfo.playerLayer;
				Vector2 r = GetDispersion();
				d += global.RightVector() * r.X + global.UpVector() * r.Y;
				d = d.Normalized();
				bfgBall.SetForward(-d);
				bfgBall.InvoqueSetTransformReset();
			}
		}
	}
	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.bfgAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.bfgAmmo]);

		humSounds = new AudioStream[_humSounds.Length];
		for (int i = 0; i < _humSounds.Length; i++)
			humSounds[i] = SoundManager.LoadSound(_humSounds[i], true);

		humStream.Stream = humSounds[0];
		humStream.Play();
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.bfgAmmo] < 40)
			return false;

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.Hide();
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Scale = new Vector3(.1f, .1f, .1f);
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetScale(muzzleObject.Scale);
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		chargeDelay = currentFireRate - .05f;

		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		humStream.Stream = humSounds[1];
		humStream.Play();

		return false;
	}
}```

./Assets/Scripts/Player/Weapons/ShotgunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class ShotgunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .049f; } } // tan(4) / 2
	public override float horizontalDispersion { get { return .062f; } } //tan(7.1) / 2

	public string caseName = "ShotgunShell";
	public string onDeathSpawn = "BulletHit";
	public string decalMark = "ShotMark";

	public float maxRange = 400f;
	public float pushForce = 350;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.shellsAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;

		}
	}

	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.shellsAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.shellsAmmo]);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.shellsAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.shellsAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.shellsAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		//Hitscan attack
		Transform3D global = playerInfo.playerCamera.GlobalTransform;
		Vector3 d = global.ForwardVector();

		for (int i = 0; i < 11; i++)
		{
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer))));
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				Vector3 collision = (Vector3)hit["position"];
				Vector3 normal = (Vector3)hit["normal"];
				bool hitFx = true;
				if (collider is Damageable damageable)
				{
					if (hasQuad)
						damageable.Damage(GD.RandRange(DamageMin * GameManager.Instance.QuadMul, DamageMax * GameManager.Instance.QuadMul), DamageType.Pellet, playerInfo.playerThing);
					else
						damageable.Damage(GD.RandRange(DamageMin, DamageMax), DamageType.Pellet, playerInfo.playerThing);

					if (damageable.Bleed)
					{
						hitFx = false;
						Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
						Blood.GlobalPosition = collision + (normal * .05f);
					}
				}
				if (hitFx)
				{
					Node3D BulletHit = (Node3D)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletHit);
					BulletHit.Position = collision + (normal * .2f);
					BulletHit.SetForward(normal);
					BulletHit.Rotate(BulletHit.UpVector(), -Mathf.Pi * .5f);
					BulletHit.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				}

				if (Sounds.Length > 3)
					SoundManager.Create3DSound(collision, Sounds[GD.RandRange(3, Sounds.Length - 1)]);

				if (CheckIfCanMark(SpaceState, collider, collision))
				{
					SpriteController BulletMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletMark);
					BulletMark.GlobalPosition = collision + (normal * .05f);
					BulletMark.SetForward(normal);
					BulletMark.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (collider is Crusher)
						BulletMark.referenceNode = collider;
				}
			}
		}

		//Case Drop
		if (!string.IsNullOrEmpty(caseName))
		{
			for (int i = 0; i < 2; i++)
			{
				RigidBody3D ammocase = (RigidBody3D)ThingsManager.thingsPrefabs[caseName].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(ammocase);
				ammocase.Position = GlobalPosition;
				ammocase.ApplyImpulse(new Vector3((float)GD.RandRange(-.2f, .02f), (float)GD.RandRange(.2f, .4f), (float)GD.RandRange(-.2f, .2f)));
			}
		}
		return true;
	}
}
```

./Assets/Scripts/Player/Weapons/RailgunWeapon.cs:
```
using Godot;
using System.Collections.Generic;
using ExtensionMethods;

public partial class RailgunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .005f; } }
	public override float horizontalDispersion { get { return .01f; } }

	public string onDeathSpawn = "RailTrail";
	public string explosionFx = "RailExplosion";
	public string decalMark = "RailMark";

	public float maxRange = 400f;
	public Color modulate;
	[Export]
	public MultiAudioStream humStream;
	[Export]
	public string _humSound;
	[Export]
	public float pushForce = 0f;

	public Color white = Colors.White;
	private List<MeshInstance3D> modulateMeshes;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.slugAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;

		}

		if (putAway)
			return;

		if (fireTime >= 0)
		{
			Color color = modulate.Lerp(white, fireTime);
			for (int i = 0; i < modulateMeshes.Count; i++)
				modulateMeshes[i].SetInstanceShaderParameter("modulate", color);
		}
	}

	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}

		humStream.Stream = SoundManager.LoadSound(_humSound, true);
		humStream.Play();

		modulate = playerInfo.playerThing.modulate;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.slugAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.slugAmmo]);

		modulateMeshes = GameManager.GetModulateMeshes(playerInfo.WeaponHand, fxMeshes);
		modulateMeshes.AddRange(playerInfo.playerThing.avatar.GetWeaponModulateMeshes());
		for (int i = 0; i < modulateMeshes.Count; i++)
			modulateMeshes[i].SetInstanceShaderParameter("modulate", modulate);

		List<MeshInstance3D> removeList = GameManager.GetModulateMeshes(muzzleObject, fxMeshes);
		removeList.AddRange(playerInfo.playerThing.avatar.GetWeaponModulateMeshes(true));

		for (int i = 0; i < modulateMeshes.Count; i++)
		{
			MeshInstance3D testMesh = modulateMeshes[i];
			if (removeList.Contains(testMesh))
				modulateMeshes.Remove(testMesh);
		}
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.slugAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.slugAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.slugAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		for (int i = 0; i < modulateMeshes.Count; i++)
			modulateMeshes[i].SetInstanceShaderParameter("modulate", white);
		//Hitscan attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer) | (1 << GameManager.RagdollLayer))));
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				Vector3 collision = (Vector3)hit["position"];
				Vector3 normal = (Vector3)hit["normal"];
				bool hitFx = true;
				if (collider is Damageable damageable)
				{
					Vector3 Distance = (collider.GlobalPosition - global.Origin);
					float lenght;
					Vector3 impulseDir = Distance.GetLenghtAndNormalize(out lenght);
					int Damage = GD.RandRange(DamageMin, DamageMax);
					Damage += Mathf.CeilToInt(Mathf.Lerp(0, DamageMax, lenght / maxRange));
					if (hasQuad)
						Damage *= GameManager.Instance.QuadMul;

					damageable.Impulse(impulseDir, pushForce);
					damageable.Damage(Damage, DamageType.Rail, playerInfo.playerThing);

					if (damageable.Bleed)
					{
						hitFx = false;
						Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
						Blood.GlobalPosition = collision + (normal * .05f);
					}
				}
				if (hitFx)
				{
					SpriteController RailHit = (SpriteController)ThingsManager.thingsPrefabs[explosionFx].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(RailHit);
					RailHit.Position = collision + (normal * .1f);
					RailHit.SetForward(normal);
					RailHit.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				}

				RailTrail railTrail = (RailTrail)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(railTrail);
				railTrail.Init(muzzleObject.GlobalPosition, collision, modulate);
				railTrail.Position = muzzleObject.GlobalPosition.Lerp(collision, 0.5f);
				railTrail.LookAt(collision);

				if (CheckIfCanMark(SpaceState, collider, collision))
				{
					SpriteController RailMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(RailMark);
					RailMark.GlobalPosition = collision + (normal * .05f);
					RailMark.SetForward(normal);
					RailMark.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (collider is Crusher)
						RailMark.referenceNode = collider;
					if (RailMark.GetChildCount() > 0)
					{
						Node child = RailMark.GetChild(0);
						if (child is Light3D light)
							light.LightColor = modulate;
					}
				}
			}
			else
			{
				RailTrail railTrail = (RailTrail)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(railTrail);
				railTrail.Init(muzzleObject.GlobalPosition, End, modulate);
				railTrail.Position = muzzleObject.GlobalPosition.Lerp(End, 0.5f);
				railTrail.LookAt(End);
			}

		}
		return true;
	}
}
```

./Assets/Scripts/Player/Weapons/ChainGunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class ChainGunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return vertDispersion[warmed]; } }
	public override float horizontalDispersion { get { return horDispersion[warmed]; } }

	public readonly float[] vertDispersion  = new float[2] { .066f, .11f };
	public readonly float[] horDispersion = new float[2] { .066f, .11f };

	public string caseName = "MachineGunAmmoCase";
	public string onDeathSpawn = "BulletHit";
	public string decalMark = "BulletMark";
	public float maxRange = 400f;

	public float warmTime = 1;
	public float[] barrelSpeed = new float[2] { 10, 12 };
	public float[] hastebarrelSpeed = new float[2] { 11, 12 };
	private float currentRotSpeed = 0;
	private int warmed = 0;
	private float[] fireRate;
	private float[] hasteFireRate;

	[Export]
	public MultiAudioStream humStream;
	[Export]
	public string _humSound;

	private bool timeToMuzzleLight = true;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.chainAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 4))
			{
				audioStream.Stream = Sounds[4];
				audioStream.Play();
			}
			putAway = true;
		}

		if (warmTime > 0)
		{
			warmTime -= deltaTime;
			if (warmTime < 0)
				warmed = 1;
		}

	}

	protected override void OnInit()
	{
		if (Sounds.Length > 5)
		{
			audioStream.Stream = Sounds[5];
			audioStream.Play();
		}

		humStream.Stream = SoundManager.LoadSound(_humSound, true);

		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.chainAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.chainAmmo]);

		fireRate = new float[2] { _fireRate, _hasteFireRate };
		hasteFireRate = new float[2] { _hasteFireRate, _hasteFireRate * .7f };
	}

	protected override void OnCoolDown()
	{
		warmed = 0;
		timeToMuzzleLight = true;
		humStream.Stop();
		if (Sounds.Length > 9)
		{
			audioStream.Stream = Sounds[9];
			audioStream.Play();
		}
	}

	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.chainAmmo] <= 0)
			return false;

		if (cooldown)
			return false;

		if (fireTime <= 0)
		{
			warmTime = 1;
			humStream.Play();
		}

		playerInfo.Ammo[PlayerInfo.chainAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.chainAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						if (timeToMuzzleLight)
						{
							if (hasQuad)
								SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));
							muzzleLight.LightEnergy = 1.0f;
							muzzleObject.Visible = true;
							playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
						}
						timeToMuzzleLight = !timeToMuzzleLight;
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = fireRate[warmed];
		if (playerInfo.haste)
			currentFireRate = hasteFireRate[warmed];
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;

		if (Sounds.Length > 3)
		{
			audioStream.Stream = Sounds[GD.RandRange(0,3)];
			audioStream.Play();
		}

		//Hitscan attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer))));
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				Vector3 collision = (Vector3)hit["position"];
				Vector3 normal = (Vector3)hit["normal"];
				int soundIndex = 6;
				bool hitFx = true;
				if (collider is Damageable damageable)
				{
					if (hasQuad)
						damageable.Damage(GD.RandRange(DamageMin * GameManager.Instance.QuadMul, DamageMax * GameManager.Instance.QuadMul), DamageType.Bullet, playerInfo.playerThing);
					else
						damageable.Damage(GD.RandRange(DamageMin, DamageMax), DamageType.Bullet, playerInfo.playerThing);

					if (damageable.Bleed)
					{
						hitFx = false;
						soundIndex = 7;
						Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
						Blood.GlobalPosition = collision + (normal * .05f);
					}
				}
				if (hitFx)
				{
					if (MapLoader.mapSurfaceTypes.TryGetValue(collider, out SurfaceType st))
					{
						if (st.MetalSteps)
							soundIndex = 8;
						else if (st.Flesh)
							soundIndex = 7;
					}

					Node3D BulletHit = (Node3D)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletHit);
					BulletHit.Position = collision + (normal * .2f);
					BulletHit.SetForward(normal);
					BulletHit.Rotate(BulletHit.UpVector(), -Mathf.Pi * .5f);
					BulletHit.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				}

				if (Sounds.Length > soundIndex)
					SoundManager.Create3DSound(collision, Sounds[soundIndex]);

				if (CheckIfCanMark(SpaceState, collider, collision))
				{
					SpriteController BulletMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletMark);
					BulletMark.GlobalPosition = collision + (normal * .05f);
					BulletMark.SetForward(normal);
					BulletMark.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (collider is Crusher)
						BulletMark.referenceNode = collider;
				}
			}
		}

		//Case Drop
		if (!string.IsNullOrEmpty(caseName))
		{
			RigidBody3D ammocase = (RigidBody3D)ThingsManager.thingsPrefabs[caseName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(ammocase);
			ammocase.Position = GlobalPosition;
			ammocase.Quaternion = new Quaternion(Vector3.Right, currentRotSpeed);
			ammocase.ApplyImpulse(new Vector3((float)GD.RandRange(-.2f, .02f), (float)GD.RandRange(.2f, .4f), (float)GD.RandRange(-.2f, .2f)));
		}
		return true;
	}
	protected override Quaternion RotateBarrel(float deltaTime)
	{
		if (fireTime > 0f)
		{
			float currenBarrelSpeed = barrelSpeed[warmed];
			if (playerInfo.haste)
				currenBarrelSpeed = hastebarrelSpeed[warmed];
			currentRotSpeed += currenBarrelSpeed * deltaTime;
			if (currentRotSpeed >= 360)
				currentRotSpeed -= 360;
		}
		return new Quaternion(Vector3.Left, currentRotSpeed);
	}
}
```

./Assets/Scripts/Player/Weapons/RocketLauncherWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class RocketLauncherWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .02f; } }
	public override float horizontalDispersion { get { return .02f; } }
	[Export]
	public string AttackProjectileName;
	public Vector3 spawnPos;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.rocketsAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;
		}
	}
	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.rocketsAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.rocketsAmmo]);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.rocketsAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.rocketsAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.rocketsAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;
		playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(true);

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		//Projectile attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();

			Projectile rocket = (Projectile)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(rocket);
			rocket.owner = playerInfo.playerThing;
			if (hasQuad)
				rocket.EnableQuad();
			if (muzzleObject != null)
				rocket.GlobalPosition = muzzleObject.GlobalPosition + d;
			else
				rocket.GlobalPosition = global.Origin;
			rocket.ignoreSelfLayer = playerInfo.playerLayer;
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			rocket.SetForward(-d);
			rocket.InvoqueSetTransformReset();
		}

		return true;
	}
}
```

./Assets/Scripts/Player/Weapons/LightningGunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class LightningGunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .02f; } }
	public override float horizontalDispersion { get { return .02f; } }

	public string onDeathSpawn = "LightningExplosion";
	public string decalMark = "LightningMark";
	public float maxRange = 24f;
	public Vector3 spawnPos;
	[Export]
	public Node3D boltOrigin;
	[Export]
	public LightningBolt lightningBolt;
	[Export]
	public MultiAudioStream humStream;
	[Export]
	public string[] _humSounds;
	public AudioStream[] humSounds;
	private Quaternion baseRotation;

	private Node3D avatarboltOrigin;
	private LightningBolt avatarLightningBolt;
	private Vector3 destination = Vector3.Zero;
	public enum CurrentHum
	{
		None,
		Idle,
		Fire
	}

	private CurrentHum currentHum = CurrentHum.None;
	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.lightningAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;
		}

		if (fireTime <= 0)
		{
			if (currentHum != CurrentHum.Idle)
			{
				humStream.Stream = humSounds[0];
				humStream.Play();
				currentHum = CurrentHum.Idle;
			}

			if (boltOrigin.Visible)
				boltOrigin.Hide();

			if (!putAway)
				if (avatarboltOrigin.Visible)
				{
					avatarboltOrigin.Hide();
					boltOrigin.Quaternion = baseRotation;
				}
		}
		else if (!putAway)
			avatarboltOrigin.LookAt(destination);

	}
	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}

		humSounds = new AudioStream[_humSounds.Length];
		for (int i = 0; i < _humSounds.Length; i++)
			humSounds[i] = SoundManager.LoadSound(_humSounds[i], true);

		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.lightningAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.lightningAmmo]);
		lightningBolt.SetArcsLayers(playerInfo.uiLayer);

		humStream.Stream = humSounds[0];
		humStream.Play();
		currentHum = CurrentHum.Idle;

		baseRotation = boltOrigin.Quaternion;

		avatarboltOrigin = new Node3D();
		avatarboltOrigin.Name = "BoltOrigin";
		avatarLightningBolt = (LightningBolt)ThingsManager.thingsPrefabs["LightningBolt"].Instantiate();
		avatarboltOrigin.AddChild(avatarLightningBolt);
		playerInfo.playerThing.avatar.AddLightningBolt(avatarboltOrigin);
	}
	public override bool Fire()
	{
		if (putAway)
			return false;

		if (playerInfo.playerThing.waterLever > 1)
		{
			if (playerInfo.playerThing.currentWaterSurface != null)
			{
				playerInfo.playerThing.currentWaterSurface.ElectroShockDischarge(playerInfo.playerThing);
				boltOrigin.Hide();
				avatarboltOrigin.Hide();
				return false;
			}
		}

		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.lightningAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.lightningAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.lightningAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}

		if (fireTime <= 0)
		{
			if (Sounds.Length > 0)
			{
				audioStream.Stream = Sounds[0];
				audioStream.Play();
			}

			if (hasQuad)
				SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

			if (currentHum != CurrentHum.Fire)
			{
				humStream.Stream = humSounds[1];
				humStream.Play();
				currentHum = CurrentHum.Fire;
			}
			boltOrigin.Show();
			avatarboltOrigin.Show();
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		fireTime = _fireRate + .05f;
		coolTimer = 0f;

		//Hitscan attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | (1 << GameManager.WaterLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer) | (1 << GameManager.RagdollLayer))));
			if (MapLoader.waterSurfaces.Count > 0)
				RayCast.CollideWithAreas = true;
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				Vector3 collision = (Vector3)hit["position"];
				Vector3 normal = (Vector3)hit["normal"];

				if (collider is Damageable damageable)
				{
					if (hasQuad)
						damageable.Damage(GD.RandRange(DamageMin * GameManager.Instance.QuadMul, DamageMax * GameManager.Instance.QuadMul), DamageType.Lightning, playerInfo.playerThing);
					else
						damageable.Damage(GD.RandRange(DamageMin, DamageMax), DamageType.Lightning, playerInfo.playerThing);

					if (damageable.Bleed)
					{
						Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
						Blood.GlobalPosition = collision + (normal * .05f);
					}
				}

				boltOrigin.LookAt(collision);
				lightningBolt.SetBoltMesh(boltOrigin.GlobalPosition, collision);
				avatarboltOrigin.LookAt(collision);
				avatarLightningBolt.SetBoltMesh(avatarboltOrigin.GlobalPosition, collision);
				destination = collision;

				Node3D LightningExplosion = (Node3D)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(LightningExplosion);
				LightningExplosion.Position = collision + (normal * .2f);
				LightningExplosion.SetForward(normal);
				LightningExplosion.Rotate(LightningExplosion.UpVector(), -Mathf.Pi * .5f);
				LightningExplosion.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));

				if (Sounds.Length > 3)
					SoundManager.Create3DSound(collision, Sounds[GD.RandRange(3, Sounds.Length - 1)]);

				if (CheckIfCanMark(SpaceState, collider, collision))
				{
					SpriteController ElectricMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(ElectricMark);
					ElectricMark.GlobalPosition = collision + (normal * .05f);
					ElectricMark.SetForward(normal);
					ElectricMark.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (collider is Crusher)
						ElectricMark.referenceNode = collider;
				}
			}
			else
			{
				boltOrigin.Quaternion = baseRotation;
				lightningBolt.SetBoltLenght(maxRange);
				avatarboltOrigin.LookAt(End);
				avatarLightningBolt.SetBoltLenght(maxRange);
				destination = End;
			}
		}
		return true;
	}
}```

./Assets/Scripts/Player/Weapons/HeavyMachineGunWeapon.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class HeavyMachineGunWeapon : PlayerWeapon
{
	public override float verticalDispersion { get { return .088f; } } // tan(10) / 2
	public override float horizontalDispersion { get { return .088f; } } // tan(10) / 2

	public string caseName = "MachineGunAmmoCase";
	public string onDeathSpawn = "BulletHit";
	public string decalMark = "BulletMark";
	public float maxRange = 400f;

	protected override void OnUpdate(float deltaTime)
	{
		if (playerInfo.Ammo[PlayerInfo.bulletsAmmo] <= 0 && fireTime < .1f)
		{
			if ((!putAway) && (Sounds.Length > 1))
			{
				audioStream.Stream = Sounds[1];
				audioStream.Play();
			}
			putAway = true;

		}
	}

	protected override void OnInit()
	{
		if (Sounds.Length > 2)
		{
			audioStream.Stream = Sounds[2];
			audioStream.Play();
		}
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmoType(PlayerInfo.bulletsAmmo);
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.bulletsAmmo]);
	}
	public override bool Fire()
	{
		if (LowerAmount > .2f)
			return false;

		//small offset to allow continous fire animation
		if (fireTime > 0.05f)
			return false;

		if (playerInfo.Ammo[PlayerInfo.bulletsAmmo] <= 0)
			return false;

		playerInfo.Ammo[PlayerInfo.bulletsAmmo]--;
		playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(playerInfo.Ammo[PlayerInfo.bulletsAmmo]);

		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				muzzleLight.LightEnergy = 1.0f;
				if (muzzleObject != null)
					if (!muzzleObject.Visible)
					{
						muzzleObject.Visible = true;
						playerInfo.playerThing.avatar.MuzzleFlashSetActive(true);
					}
			}
		}
		//maximum fire rate 20/s, unless you use negative number (please don't)
		float currentFireRate = _fireRate;
		if (playerInfo.haste)
			currentFireRate = _hasteFireRate;
		fireTime = currentFireRate + .05f;
		coolTimer = 0f;

		if (Sounds.Length > 0)
		{
			audioStream.Stream = Sounds[0];
			audioStream.Play();
		}

		if (hasQuad)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(quadSound));

		//Hitscan attack
		{
			Transform3D global = playerInfo.playerCamera.GlobalTransform;
			Vector3 d = global.ForwardVector();
			Vector2 r = GetDispersion();
			d += global.RightVector() * r.X + global.UpVector() * r.Y;
			d = d.Normalized();
			Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
			Vector3 End = Origin - d * maxRange;
			var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer))));
			var SpaceState = GetWorld3D().DirectSpaceState;
			var hit = SpaceState.IntersectRay(RayCast);
			if (hit.Count > 0)
			{
				CollisionObject3D collider = (CollisionObject3D)hit["collider"];
				Vector3 collision = (Vector3)hit["position"];
				Vector3 normal = (Vector3)hit["normal"];
				bool hitFx = true;
				if (collider is Damageable damageable)
				{
					if (hasQuad)
						damageable.Damage(GD.RandRange(DamageMin * GameManager.Instance.QuadMul, DamageMax * GameManager.Instance.QuadMul), DamageType.Bullet, playerInfo.playerThing);
					else
						damageable.Damage(GD.RandRange(DamageMin, DamageMax), DamageType.Bullet, playerInfo.playerThing);

					if (damageable.Bleed)
					{
						hitFx = false;
						Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
						Blood.GlobalPosition = collision + (normal * .05f);
					}
				}
				if (hitFx)
				{
					Node3D BulletHit = (Node3D)ThingsManager.thingsPrefabs[onDeathSpawn].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletHit);
					BulletHit.Position = collision + (normal * .2f);
					BulletHit.SetForward(normal);
					BulletHit.Rotate(BulletHit.UpVector(), -Mathf.Pi * .5f);
					BulletHit.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				}

				if (Sounds.Length > 3)
					SoundManager.Create3DSound(collision, Sounds[GD.RandRange(3, Sounds.Length - 1)]);

				if (CheckIfCanMark(SpaceState, collider, collision))
				{
					SpriteController BulletMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(BulletMark);
					BulletMark.GlobalPosition = collision + (normal * .05f);
					BulletMark.SetForward(normal);
					BulletMark.Rotate(normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (collider is Crusher)
						BulletMark.referenceNode = collider;
				}
			}
		}

		//Case Drop
		if (!string.IsNullOrEmpty(caseName))
		{
			RigidBody3D ammocase = (RigidBody3D)ThingsManager.thingsPrefabs[caseName].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(ammocase);
			ammocase.Position = GlobalPosition;
			ammocase.Quaternion = new Quaternion(Vector3.Right, (float)GD.RandRange(0, Mathf.Pi) - Mathf.Pi * .5f);
			ammocase.ApplyImpulse(new Vector3((float)GD.RandRange(-.2f, .02f), (float)GD.RandRange(.2f, .4f), (float)GD.RandRange(-.2f, .2f)));
		}
		return true;
	}
}
```

./Assets/Scripts/Player/PlayerHUD.cs:
```
using Godot;
using System;
using System.Collections.Generic;

public partial class PlayerHUD : MeshInstance3D
{
	[Export]
	public Texture2D painEffect;
	[Export]
	public Texture2D pickupEffect;
	[Export]
	public Node3D viewHeadContainer;
	[Export]
	public Node3D ArmorContainer;
	[Export]
	public Node3D AmmoContainer;
	[Export]
	public Node3D WeaponContainer;
	[Export]
	public Node3D viewHead;
	[Export]
	public AnimationTree headAnimation;
	[Export]
	public Label3D healthLabel;
	[Export]
	public Label3D armorLabel;
	[Export]
	public Label3D weaponLabel;
	[Export]
	public Label3D ammoLabel;
	[Export]
	public Sprite3D[] weaponIcon;
	[Export]
	public Sprite3D crossHair;
	[Export]
	public Sprite3D pickUpIcon;
	[Export]
	public Label3D pickUpText;
	[Export]
	public Sprite3D[] powerUpIcon;
	[Export]
	public Label3D[] powerUpText;
	[Export]
	public Label3D playerName;
	[Export]
	public Label3D deathsText;
	[Export]
	public Label3D fragsText;
	[Export]
	public Sprite3D holdableItemIcon;

	public PlayerInfo playerInfo;
	public ShaderMaterial baseCamera;
	public ShaderMaterial currentMaterial;
	public ViewportTexture baseViewPortTexture;
	public ViewportTexture normalDepthViewPortTexture;

	public Camera3D NormalDepthCamera;
	public Dictionary<ShaderMaterial, ViewMaterial> ReplacementMaterial = new Dictionary<ShaderMaterial, ViewMaterial>();
	public List<Node> NodeList = new List<Node>();

	private uint currentLayer;

	private int currentFx = 0;
	private bool hasQuad = false;
	private bool isRegenerating = false;
	private bool hasBattleSuit = false;
	private bool isInvisible = false;
	private bool swapColors = false;
	private bool faceAttack = false;

	private float spawnColorTime = 0;
	private float lookTime = 0;
	private float pickUpTime = 0;
	private float weaponTime = 0;

	private List<MeshInstance3D> modelsMeshes;
	private List<MeshInstance3D> fxMeshes;
	private List<Node3D> ammoContainers = new List<Node3D>();
	private int currentAmmoType = -1;

	private static string ammoModelPath = "powerups/ammo/";
	private static string armorModel = "powerups/armor/shard";
	private static string selectSprite = "GFX/2D/SELECT";
	private static string noAmmoSprite = "ICONS/NOAMMO";

	private Sprite3D[] noAmmoIcon;
	private Sprite3D selectIcon;
	private static readonly string[] weaponNames = { "Gauntlet", "Machinegun", "Shotgun", "Grenade Launcher", "Rocket Launcher", "Lightning Gun", "Railgun", "Plasma Gun", "BFG 10K", "Grapple Hook", "Nail Gun", "ChainGun", "Proximity Launcher", "Heavy Machine Gun" };
	private static readonly string[] weaponSprites = { "ICONS/ICONW_GAUNTLET", "ICONS/ICONW_MACHINEGUN", "ICONS/ICONW_SHOTGUN", "ICONS/ICONW_GRENADE", "ICONS/ICONW_ROCKET", "ICONS/ICONW_LIGHTNING", "ICONS/ICONW_RAILGUN", "ICONS/ICONW_PLASMA", "ICONS/ICONW_BFG", "ICONS/ICONW_GRAPPLE", "ICONS/NAILGUN128", "ICONS/CHAINGUN128", "ICONS/PROXMINE", "ICONS/WEAP_HMG" };
	private static readonly string[] ammoModels = { "machinegunam", "shotgunam", "grenadeam", "rocketam", "lightningam", "railgunam", "plasmaam", "bfgam", "nailgunam", "chaingunam", "proxmineam" };
	private static readonly string[] powerUpsSprites = { "ICONS/QUAD", "ICONS/HASTE", "ICONS/INVIS", "ICONS/REGEN", "ICONS/ENVIROSUIT", "ICONS/FLIGHT" };
	private static readonly string[] holdableItemsSprites = { "ICONS/TELEPORTER", "ICONS/MEDKIT" };

	//Fixed Icon Size
	private static int defaultIconSize = 32;
	public enum NumColor
	{
		Yellow,
		Red,
		White
	}

	private NumColor curretHealthColor = NumColor.Yellow;
	private NumColor curretAmmoColor = NumColor.Yellow;
	public enum HeadDir
	{
		Left,
		Center,
		Right
	}
	public HeadDir headState = HeadDir.Center;
	private float currentDir = 0;

	private Color YellowColor = new Color(0xEAA000FF);
	private Color RedColor = new Color(0xE92F2FFF);
	private Color WhiteColor = new Color(0xD5D5D5FF);
	public enum PowerUpType : int
	{
		Quad = 0,
		Haste = 1,
		Invis = 2,
		Regen = 3,
		EnviroSuit = 4,
		Flight = 5
	}

	public enum HoldableItemType : int
	{
		Teleporter = 0,
		Medkit = 1
	}

	private class PowerUpInfo
	{
		public PowerUpType type;
		public int displayTime;
	}

	private List<PowerUpInfo> currentPowerUps = new List<PowerUpInfo>();
	private List<int> currentWeapons = new List<int>();
	public void Init(PlayerInfo p)
	{
		baseCamera = (ShaderMaterial)MaterialManager.Instance.baseCameraMaterial.Duplicate(true);
		SetSurfaceOverrideMaterial(0, baseCamera);
		baseCamera.SetShaderParameter(MaterialManager.screenTexure, baseViewPortTexture);
		baseCamera.SetShaderParameter(MaterialManager.painTexure, painEffect);
		baseCamera.SetShaderParameter(MaterialManager.pickUpTexture, pickupEffect);
		currentLayer = Layers;
		currentMaterial = baseCamera;
		playerInfo = p;
		headAnimation.Active = true;
		//Load HUD Models
		MD3 model = ModelsManager.GetModel(armorModel, false);
		if (model != null)
			Mesher.GenerateModelFromMeshes(model, currentLayer, false, false, ArmorContainer, false, false, null, true, false, true, false);

		for (int i = 0; i < ammoModels.Length; i++)
		{
			Node3D container = new Node3D();
			container.Name = ammoModels[i];
			AmmoContainer.AddChild(container);
			model = ModelsManager.GetModel(ammoModelPath + ammoModels[i], false);
			if (model != null)
				Mesher.GenerateModelFromMeshes(model, currentLayer, false, false, container, false, false, null, true, false, true, false);
			container.Hide();
			ammoContainers.Add(container);
		}

		//Set Layers
		healthLabel.Layers = currentLayer;
		armorLabel.Layers = currentLayer;
		ammoLabel.Layers = currentLayer;
		crossHair.Layers = currentLayer;
		pickUpIcon.Layers = currentLayer;
		pickUpText.Layers = currentLayer;
		weaponLabel.Layers = currentLayer;
		holdableItemIcon.Layers = currentLayer;
		playerName.Layers = currentLayer;
		deathsText.Layers = currentLayer;
		fragsText.Layers = currentLayer;

		for (int i = 0; i < powerUpIcon.Length; i++)
			powerUpIcon[i].Layers = currentLayer;
		for (int i = 0; i < powerUpText.Length; i++)
			powerUpText[i].Layers = currentLayer;

		selectIcon = new Sprite3D();
		WeaponContainer.AddChild(selectIcon);
		selectIcon.DoubleSided = false;
		selectIcon.NoDepthTest = true;
		selectIcon.Layers = currentLayer;
		selectIcon.Texture = TextureLoader.GetTextureOrAddTexture(selectSprite, false, false);
		TextureLoader.AdjustIconSize(selectIcon, defaultIconSize);
		selectIcon.Hide();

		noAmmoIcon = new Sprite3D[weaponIcon.Length];
		for (int i = 0; i < weaponIcon.Length; i++)
		{
			weaponIcon[i].Layers = currentLayer;
			noAmmoIcon[i] = new Sprite3D();
			weaponIcon[i].AddChild(noAmmoIcon[i]);
			noAmmoIcon[i].Position += Vector3.Back * .001f;
			noAmmoIcon[i].DoubleSided = false;
			noAmmoIcon[i].NoDepthTest = true;
			noAmmoIcon[i].Layers = currentLayer;
			noAmmoIcon[i].Texture = TextureLoader.GetTextureOrAddTexture(noAmmoSprite, false, false);
			TextureLoader.AdjustIconSize(noAmmoIcon[i], defaultIconSize);
			noAmmoIcon[i].Hide();
		}
	}

	public void UpdateLayersHud(uint layers)
	{
		//Set Layers
		currentLayer = layers;
		healthLabel.Layers = layers;
		armorLabel.Layers = layers;
		ammoLabel.Layers = layers;
		crossHair.Layers = layers;
		pickUpIcon.Layers = layers;
		pickUpText.Layers = layers;
		weaponLabel.Layers = layers;
		holdableItemIcon.Layers = layers;
		playerName.Layers = layers;
		deathsText.Layers = layers;
		fragsText.Layers = layers;

		for (int i = 0; i < powerUpIcon.Length; i++)
			powerUpIcon[i].Layers = layers;
		for (int i = 0; i < powerUpText.Length; i++)
			powerUpText[i].Layers = layers;

		selectIcon.Layers = layers;
		for (int i = 0; i < weaponIcon.Length; i++)
		{
			weaponIcon[i].Layers = layers;
			noAmmoIcon[i].Layers = layers;
		}

		foreach (var child in NodeList)
		{
			if (child is MeshInstance3D mesh)
				mesh.Layers = layers;
		}
		List<MeshInstance3D> Childrens = GameManager.GetAllChildrensByType<MeshInstance3D>(ArmorContainer);
		foreach (MeshInstance3D mesh in Childrens)
			mesh.Layers = layers;

		Childrens = GameManager.GetAllChildrensByType<MeshInstance3D>(AmmoContainer);
		foreach (MeshInstance3D mesh in Childrens)
			mesh.Layers = layers;
	}

	public void ChangeCrossHairScale(int scale)
	{
		float spriteValue = (Mathf.Lerp(.4f, 1.0f, scale / 100.0f));
		Vector3 Scale = new Vector3(spriteValue, spriteValue, 1);
		crossHair.Scale = Scale;
	}

	public void ChangeCrossHairAlpha(int alpha)
	{
		crossHair.Modulate = new Color(1, 1, 1, alpha / 100f);
	}

	public void ChangeCrossHair(int crossHairIndex)
	{
		if (crossHairIndex > 100)
		{
			crossHairIndex -= 100;
			if (crossHairIndex < ThingsManager.largeCrosshairs.Count)
				crossHair.Texture = ThingsManager.largeCrosshairs[crossHairIndex];
			else
				crossHair.Texture = ThingsManager.defaultCrosshair;
		}
		else if (crossHairIndex < ThingsManager.smallCrosshairs.Count)
			crossHair.Texture = ThingsManager.smallCrosshairs[crossHairIndex];
		else
			crossHair.Texture = ThingsManager.defaultCrosshair;
	}

	public void ChangeModelScale(int scale)
	{
		float modelValue = (Mathf.Lerp(.4f, 1.0f, scale / 100.0f));
		Vector3 Scale = Vector3.One * modelValue;
		viewHeadContainer.Scale = Scale;
		ArmorContainer.Scale = Scale;
		AmmoContainer.Scale = Scale;
	}

	public void ChangeSpriteScale(int scale)
	{
		float spriteValue = (Mathf.Lerp(.4f, 1.0f, scale / 100.0f));
		Vector3 Scale = new Vector3(spriteValue, spriteValue, 1);
		WeaponContainer.Scale = Scale;
		pickUpIcon.Scale = Scale;
		holdableItemIcon.Scale = Scale;

		for (int i = 0; i < powerUpIcon.Length; i++)
			powerUpIcon[i].Scale = Scale;

		int textValue = Mathf.CeilToInt(Mathf.Lerp(40f, 120f, scale / 100.0f));
		healthLabel.FontSize = textValue;
		armorLabel.FontSize = textValue;
		ammoLabel.FontSize = textValue;

		for (int i = 0; i < powerUpIcon.Length; i++)
			powerUpText[i].FontSize = textValue;

		textValue = Mathf.CeilToInt(Mathf.Lerp(15f, 50f, scale / 100.0f));
		pickUpText.FontSize = textValue;
		weaponLabel.FontSize = textValue;
		playerName.FontSize = textValue;
		deathsText.FontSize = textValue;
		fragsText.FontSize = textValue;
	}

	public void InitHUD(MD3 headModel, Dictionary<string, string> meshToSkin)
	{
		if (NodeList.Count > 0)
		{
			for (int i = 0; i < NodeList.Count; i++)
				NodeList[i].QueueFree();
		}
		NodeList.Clear();

		if (headModel != null)
			Mesher.GenerateModelFromMeshes(headModel, currentLayer, false, false, viewHead, false, false, meshToSkin, true, false, true, false);
		modelsMeshes = GameManager.GetAllChildrensByType<MeshInstance3D>(viewHeadContainer);
		fxMeshes = GameManager.CreateFXMeshInstance3D(viewHeadContainer);
		NodeList = GameManager.GetAllChildrensByType<Node>(viewHead);
		headAnimation.Set("parameters/Look/pain_shot/active", true);
	}

	public void SetCameraReplacementeMaterial(ShaderMaterial shaderMaterial)
	{
		if (shaderMaterial == null) 
		{
			NormalDepthCamera.Visible = false;
			SetSurfaceOverrideMaterial(0, baseCamera);
			currentMaterial = baseCamera;
			return;
		}

		ViewMaterial viewMaterial;
		if (!ReplacementMaterial.TryGetValue(shaderMaterial, out viewMaterial))
		{
			viewMaterial = new ViewMaterial();
			viewMaterial.material = (ShaderMaterial)shaderMaterial.Duplicate(true);
			viewMaterial.material.SetShaderParameter(MaterialManager.painTexure, painEffect);
			viewMaterial.material.SetShaderParameter(MaterialManager.pickUpTexture, pickupEffect);
			bool needNormalDepth = false;
			var Results = RenderingServer.GetShaderParameterList(shaderMaterial.Shader.GetRid());
			foreach (var result in Results)
			{
				Variant nameVar;
				if (result.TryGetValue("name", out nameVar))
				{
					string name = (string)nameVar;
					if (name.Contains(MaterialManager.normalDepthTexture))
					{
						needNormalDepth = true;
						break;
					}
				}
			}
			viewMaterial.needNormalDepth = needNormalDepth;
			ReplacementMaterial.Add(shaderMaterial, viewMaterial);
		}

		SetSurfaceOverrideMaterial(0, viewMaterial.material);
		currentMaterial = viewMaterial.material;
		viewMaterial.material.SetShaderParameter(MaterialManager.screenTexure, baseViewPortTexture);
		if (viewMaterial.needNormalDepth)
		{
			NormalDepthCamera.Visible = true;
			viewMaterial.material.SetShaderParameter(MaterialManager.normalDepthTexture, normalDepthViewPortTexture);
		}
	}

	public void painFlashTime(float time)
	{
		currentMaterial.SetShaderParameter("pain_duration", time);
		currentMaterial.SetShaderParameter("pain_start_time", GameManager.CurrentTimeMsec);
		headAnimation.Set("parameters/Look/pain_shot/request", (int)AnimationNodeOneShot.OneShotRequest.Fire);
	}

	public void pickupFlashTime(float time)
	{
		currentMaterial.SetShaderParameter("pick_up_duration", time);
		currentMaterial.SetShaderParameter("pick_up_start_time", GameManager.CurrentTimeMsec);
	}

	public void SetAttackFace()
	{
		if (faceAttack)
			return;

		if (currentDir > 0)
		{
			if (headState != HeadDir.Left)
			{
				headState = HeadDir.Left;
				lookTime = .5f;
			}
		}
		else if (currentDir < 0)
		{
			if (headState != HeadDir.Right)
			{
				headState = HeadDir.Right;
				lookTime = .5f;
			}
		}
		else
		{
			if (headState == HeadDir.Center)
			{
				lookTime = .5f;
				return;
			}

			if (headState == HeadDir.Right)
			{
				currentDir = 1;
				headState = HeadDir.Left;
			}
			if (headState == HeadDir.Left)
			{
				currentDir = -1;
				headState = HeadDir.Right;
			}
			lookTime = .5f - lookTime;
		}
		faceAttack = true;
	}

	public void RemoveAllItems()
	{
		currentPowerUps = new List<PowerUpInfo>();
		currentWeapons = new List<int>();
		for (int i = 0; i < powerUpIcon.Length; i++)
			powerUpIcon[i].Hide();
		for (int i = 0; i < powerUpText.Length; i++)
			powerUpText[i].Hide();
		for (int i = 0; i < weaponIcon.Length; i++)
			weaponIcon[i].Hide();
		WeaponContainer.Hide();
		weaponLabel.Hide();
		holdableItemIcon.Hide();
	}


	public void RemovePowerUp(PowerUpType type)
	{
		int i;
		bool found = false;
		for (i = 0; i < currentPowerUps.Count; i++)
		{
			if (currentPowerUps[i].type == type)
			{
				currentPowerUps.RemoveAt(i);
				found = true;
				break;
			}
		}

		if (!found)
			return;

		for (i = 0; i < currentPowerUps.Count; i++)
		{
			powerUpIcon[i].Texture = TextureLoader.GetTextureOrAddTexture(powerUpsSprites[(int)currentPowerUps[i].type], false, false);
			TextureLoader.AdjustIconSize(powerUpIcon[i], defaultIconSize);
			powerUpText[i].Text = "" + currentPowerUps[i].displayTime;
		}

		for (; i < powerUpIcon.Length; i++)
		{
			powerUpIcon[i].Hide();
			powerUpText[i].Hide();
		}

	}
	public void UpdatePowerUpTime(PowerUpType type, int time)
	{
		int i;
		bool found = false;
		for (i = 0; i < currentPowerUps.Count; i++)
		{
			if (currentPowerUps[i].type == type)
			{
				found = true;
				break;
			}				
		}
		if (found)
			currentPowerUps[i].displayTime = time;
		else
		{
			PowerUpInfo powerUpInfo = new PowerUpInfo();
			powerUpInfo.type = type;
			powerUpInfo.displayTime = time;
			currentPowerUps.Add(powerUpInfo);
		}

		if (!found)
			currentPowerUps.Sort((a,b) => { if (a.displayTime > b.displayTime) return 1; else if (a.displayTime == b.displayTime) return 0; else return -1; });

		for (i = 0; i < currentPowerUps.Count; i++)
		{
			if (powerUpIcon[i].Visible == false)
				powerUpIcon[i].Show();
			if (powerUpText[i].Visible == false)
				powerUpText[i].Show();
			if (!found)
			{
				powerUpIcon[i].Texture = TextureLoader.GetTextureOrAddTexture(powerUpsSprites[(int)currentPowerUps[i].type], false, false);
				TextureLoader.AdjustIconSize(powerUpIcon[i], defaultIconSize);
			}
			powerUpText[i].Text = "" + currentPowerUps[i].displayTime;
		}
	}

	public void AddHoldableItem(PlayerThing.HoldableItem item)
	{

		switch (item)
		{
			default:
				return;
			break;
			case PlayerThing.HoldableItem.Teleporter:
				holdableItemIcon.Texture = TextureLoader.GetTextureOrAddTexture(holdableItemsSprites[(int)HoldableItemType.Teleporter], false, false);
				TextureLoader.AdjustIconSize(holdableItemIcon, defaultIconSize);
			break;
		}
		holdableItemIcon.Show();
	}

	public void RemoveHoldableItem()
	{
		holdableItemIcon.Hide();
	}

	public void AddWeapon(int weapon, int current = -1)
	{
		if (currentWeapons.Contains(weapon))
			return;

		if (WeaponContainer.Visible == false)
			WeaponContainer.Show();

		if (weaponLabel.Visible == false)
			weaponLabel.Show();

		WeaponContainer.Position = new Vector3(currentWeapons.Count * -0.175f, WeaponContainer.Position.Y, 0); 
		currentWeapons.Add(weapon);
		currentWeapons.Sort((a, b) => a.CompareTo(b));
		for (int i = 0; i < currentWeapons.Count; i++)
		{
			if (weaponIcon[i].Visible == false)
				weaponIcon[i].Show();

			noAmmoIcon[i].Visible = !playerInfo.playerControls.HasAmmo(currentWeapons[i]);

			if (currentWeapons[i] == current)
				selectIcon.Position = weaponIcon[i].Position;
			if (currentWeapons[i] == weapon)
			{
				if (current < 0)
					selectIcon.Position = weaponIcon[i].Position;
				weaponLabel.Text = weaponNames[weapon];
			}

			weaponIcon[i].Texture = TextureLoader.GetTextureOrAddTexture(weaponSprites[currentWeapons[i]], false, false);
			TextureLoader.AdjustIconSize(weaponIcon[i], defaultIconSize);
		}
		//In order to get near the screen
		selectIcon.Position += Vector3.Back * .001f;
		if (selectIcon.Visible == false)
			selectIcon.Show();
		weaponTime = 3f;
	}

	public void ChangeWeapon(int weapon)
	{
		if (WeaponContainer.Visible == false)
			WeaponContainer.Show();

		if (weaponLabel.Visible == false)
			weaponLabel.Show();

		for (int i = 0; i < currentWeapons.Count; i++)
		{
			noAmmoIcon[i].Visible = !playerInfo.playerControls.HasAmmo(currentWeapons[i]);
			if (currentWeapons[i] == weapon)
			{
				weaponLabel.Text = weaponNames[weapon];
				selectIcon.Position = weaponIcon[i].Position;
			}
		}
		//In order to get near the screen
		selectIcon.Position += Vector3.Back * .001f;
		if (selectIcon.Visible == false)
			selectIcon.Show();
		weaponTime = 3f;
	}

	public void CheckWeapon(float deltaTime)
	{
		if (weaponTime > 0)
			weaponTime -= deltaTime;

		if (weaponTime < 0)
		{
			weaponTime = 0;
			WeaponContainer.Hide();
			weaponLabel.Hide();
		}
	}

	public void CheckPickUp(float deltaTime)
	{
		if (pickUpTime > 0)
			pickUpTime -= deltaTime;

		if (pickUpTime < 0)
		{
			pickUpTime = 0;
			pickUpIcon.Hide();
			pickUpText.Hide();
		}

	}
	public void CheckNextHeadAnimation(float deltaTime)
	{
		if (lookTime > 0)
		{
			lookTime -= deltaTime;
			if (lookTime < 0)
				lookTime = 0;
			float value = Mathf.Clamp(2 * (0.5f - lookTime), 0, 1);
			switch (headState)
			{
				default:
				break;
				case HeadDir.Left:
					headAnimation.Set("parameters/Look/left_right/blend_position", -value + currentDir);
				break;
				case HeadDir.Right:
					headAnimation.Set("parameters/Look/left_right/blend_position", value + currentDir);
				break;
			}
		}
		else
		{
			int index;
			float oldDir = currentDir;
			currentDir = (float)headAnimation.Get("parameters/Look/left_right/blend_position");

			if (oldDir != currentDir)
			{
				lookTime = .5f;
				headState = HeadDir.Center;
				return;
			}

			if (currentDir > 0)
				index = GD.RandRange(-1, 0);
			else if (currentDir < 0)
				index = GD.RandRange(0, 1);
			else
				index = GD.RandRange(-1, 1);

			switch (index)
			{
				default:
					headState = HeadDir.Center;
				break;
				case -1:
					headState = HeadDir.Left;
				break;
				case 1:
					headState = HeadDir.Right;
				break;
			}
			lookTime = .5f;
			faceAttack = false;
		}
	}

	public void SetAmmoCoolDown(bool cooldown)
	{
		if (cooldown)
		{
			if (curretAmmoColor != NumColor.White)
			{
				curretAmmoColor = NumColor.White;
				ammoLabel.Modulate = WhiteColor;
			}
			return;
		}

		if (curretAmmoColor != NumColor.Yellow)
		{
			curretAmmoColor = NumColor.Yellow;
			ammoLabel.Modulate = YellowColor;
		}
	}

	public void ItemPickUp(string icon, string text)
	{
		pickUpIcon.Texture = TextureLoader.GetTextureOrAddTexture(icon, false, false);
		TextureLoader.AdjustIconSize(pickUpIcon, defaultIconSize);
		pickUpText.Text = text;
		pickUpTime = 1.5f;
		pickUpIcon.Show();
		pickUpText.Show();

		//Small Check in case we picked Up Ammo
		if (weaponTime > 0)
		{
			for (int i = 0; i < currentWeapons.Count; i++)
				noAmmoIcon[i].Visible = !playerInfo.playerControls.HasAmmo(currentWeapons[i]);
		}
	}

	public void HideAmmo(bool hideNum = false)
	{
		for (int i = 0; i < ammoContainers.Count; i++)
			ammoContainers[i].Hide();

		if ((hideNum) || (playerInfo.playerThing.Dead))
			ammoLabel.Hide();

		currentAmmoType = -1;
	}
	public void UpdateAmmoType(int type)
	{
		if (ammoContainers.Count > type)
		{
			ammoContainers[type].Show();
			currentAmmoType = type;
			if (ammoLabel.Visible == false)
				ammoLabel.Show();
		}
		SetAmmoCoolDown(false);
	}

	public void UpdateAmmo(int ammo, int type = -1)
	{
		if (type >= 0)
		{
			if (currentAmmoType !=  type)
				return;
		}

		string ammoText = "";
		if (ammo >= 0)
			ammoText = "" + ammo;
		ammoLabel.Text = ammoText;
	}
	public void UpdateArmor(int armor)
	{
		armorLabel.Text = "" + armor;
	}

	public void UpdateHealth(int hitpoint)
	{
		
		float currentPain = Mathf.Clamp(hitpoint / 100f, 0, 1);
		healthLabel.Text = "" + hitpoint;
		headAnimation.Set("parameters/Look/TimeScale/scale", currentPain);
		headAnimation.Set("parameters/Look/side_limit/add_amount", currentPain);
		headAnimation.Set("parameters/Look/up_limit/add_amount", 1 - currentPain);
		if (hitpoint < 0)
		{
			swapColors = false;
			if (curretHealthColor != NumColor.Red)
			{
				curretHealthColor = NumColor.Red;
				healthLabel.Modulate = RedColor;
			}
		}
		else if (hitpoint < 30)
			swapColors = true;
		else
		{
			swapColors = false;
			if (curretHealthColor == NumColor.Red)
			{
				curretHealthColor = NumColor.Yellow;
				healthLabel.Modulate = YellowColor;
			}
		}
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;

		if (swapColors)
		{
			spawnColorTime -= deltaTime;
			if (spawnColorTime <= 0)
			{
				spawnColorTime = .5f;
				if (curretHealthColor != NumColor.Red)
				{
					curretHealthColor = NumColor.Red;
					healthLabel.Modulate = RedColor;
				}
				else
				{
					curretHealthColor = NumColor.Yellow;
					healthLabel.Modulate = YellowColor;
				}
			}
		}

		if (hasQuad != playerInfo.quadDamage)
		{
			hasQuad = playerInfo.quadDamage;
			if (hasQuad)
				currentFx |= GameManager.QuadFX;
			else
				currentFx &= ~GameManager.QuadFX;
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}
		
		if (isRegenerating != playerInfo.regenerating)
		{
			isRegenerating = playerInfo.regenerating;
			if (isRegenerating)
				currentFx |= GameManager.RegenFX;
			else
				currentFx &= ~GameManager.RegenFX;
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		if (isInvisible != playerInfo.invis)
		{
			isInvisible = playerInfo.invis;
			if (isInvisible)
			{
				currentFx |= GameManager.InvisFX;
				GameManager.ChangeFx(modelsMeshes, GameManager.InvisFX, true, false);
			}
			else
			{
				currentFx &= ~GameManager.InvisFX;
				GameManager.ChangeFx(modelsMeshes, 0, true, false);
			}
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		if (hasBattleSuit != playerInfo.battleSuit)
		{
			hasBattleSuit = playerInfo.battleSuit;
			if (hasBattleSuit)
				currentFx |= GameManager.BattleSuitFX;
			else
				currentFx &= ~GameManager.BattleSuitFX;
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		CheckNextHeadAnimation(deltaTime);
		CheckPickUp(deltaTime);
		CheckWeapon(deltaTime);
	}
	public class ViewMaterial
	{
		public ShaderMaterial material;
		public bool needNormalDepth; 
	}
}
```

./Assets/Scripts/Player/PlayerCamera.cs:
```
using Godot;
using System;

public partial class PlayerCamera : Node3D
{
	[Export]
	public PlayerControls playerControls;
	[Export]
	public Camera3D ThirdPerson;
	[Export]
	public Camera3D ViewCamera;
	[Export]
	public PlayerPostProcessing playerPostProcessing;

	public Camera3D CurrentCamera;
	private Vector3 rotAngle = Vector3.Zero;
	public bool currentThirdPerson = false;

	public float yOffset = .85f;
	private float learpYOffset = .85f;
	private float interp = 0;

	// Called when the node enters the scene tree for the first time.
	public override void _Ready()
	{
		CurrentCamera = ViewCamera;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		if (playerControls.playerThing.Dead)
			return;

		float deltaTime = (float)delta;

		if (GameOptions.HeadBob && playerControls.bobActive && !currentThirdPerson)
			interp = Mathf.Lerp(interp, 1, deltaTime * 5);
		else
			interp = Mathf.Lerp(interp, 0, deltaTime * 6);

		Vector2 Bob = playerControls.currentBob * interp;

		if (learpYOffset != yOffset)
			learpYOffset = Mathf.Lerp(learpYOffset, yOffset, 10 * deltaTime);

		Position = new Vector3 (0, learpYOffset + Bob.Y, 0);
		rotAngle.X = playerControls.viewDirection.X;
		rotAngle.Z = Bob.X;
		RotationDegrees = rotAngle;
	}

	public void ChangeThirdPersonCamera(bool enable)
	{
		currentThirdPerson = enable;
		if (enable)
		{
			ThirdPerson.Visible = true;
			CurrentCamera = ThirdPerson;
			playerPostProcessing.ChangeCurrentCamera(CurrentCamera, currentThirdPerson);
			playerPostProcessing.SetLocalViewPortToCamera(ThirdPerson);
			playerControls.playerThing.avatar.ChangeLayer(GameManager.AllPlayerViewMask);
			return;
		}
		CurrentCamera = ViewCamera;
		playerPostProcessing.ChangeCurrentCamera(CurrentCamera, currentThirdPerson);
		playerPostProcessing.SetLocalViewPortToCamera(ViewCamera);
		ThirdPerson.Visible = false;
		playerControls.playerThing.avatar.ChangeLayer(GameManager.AllPlayerViewMask & ~((uint)(playerControls.playerInfo.viewLayer)));
	}
}
```

./Assets/Scripts/Player/PlayerWeapon.cs:
```
using Godot;
using System.Collections.Generic;
using ExtensionMethods;

public partial class PlayerWeapon : Node3D
{
	[Export]
	public Node3D Weapon = null;
	[Export]
	public Vector3 Offset = new Vector3(.2f, -.2f, -.14f);
	[Export]
	public float ReadyHeight = 0.75f;
	[Export]
	public MultiAudioStream audioStream;
	[Export]
	public string[] _sounds = new string[0];
	[Export]
	public ModelController[] models;

	public AudioStream[] Sounds = new AudioStream[0];

	[Export]
	public Node3D muzzleObject = null;
	[Export]
	public Node3D barrelObject = null;

	[Export]
	public bool useCrosshair = true;
	[Export]
	public bool fullAuto = true;
	[Export]
	public bool isMelee = false;

	public virtual float verticalDispersion { get { return .02f; } } //tan(2.3) / 2
	public virtual float horizontalDispersion { get { return .03f; } } //tan(3.4) / 2
	[Export]
	public int DamageMin = 5;
	[Export]
	public int DamageMax = 15;
	[Export]
	public float swapSpeed = 12f;
	[Export]
	public float kickSpeed = 6f;
	[Export]
	public float KickOffSet = .1f;
	[Export]
	public float KickBackTime = .1f;

	public Vector2 Sensitivity = new Vector2(.015f, .01f);
	public float rotateSpeed = 4f;
	public float maxTurn = 3f;

	Vector2 MousePosition;
	Vector2 oldMousePosition = Vector2.Zero;

	public PlayerInfo playerInfo = null;

	public float LowerOffset = -.4f;
	public float LowerAmount = 1f;
	public float KickAmount = 0f;
	public int Noise = 0;

	public bool putAway = false;
	public bool weaponReady = false;

	public bool cooldown = false;
	[Export]
	public bool useCooldown = false;
	[Export]
	public float muzzleLightTime = 5f;
	[Export]
	public float cooldownTime = 0f;

	[Export]
	public float _fireRate = .4f;
	public float _hasteFireRate = .28f;

	public float fireTime = 0f;
	public float faceTime = 1.5f;
	[Export]
	protected OmniLight3D muzzleLight;

	protected float coolTimer = 0f;

	private float interp = 0;
	private Vector3 oldPosition = Vector3.Down;
	private PhysicsPointQueryParameters3D PointIntersect;

	public string quadSound = "items/damage3";
	public List<MeshInstance3D> modelsMeshes = new List<MeshInstance3D>();
	public List<MeshInstance3D> fxMeshes;
	public bool hasQuad = false;
	public bool isRegenerating = false;
	public bool hasBattleSuit = false;
	public bool isInvisible = false;
	private int currentFx = 0;
	public override void _Ready()
	{
		Sounds = new AudioStream[_sounds.Length];
		for (int i = 0; i < _sounds.Length; i++)
			Sounds[i] = SoundManager.LoadSound(_sounds[i]);

		if (!GameOptions.UseMuzzleLight)
		{
//			if (muzzleLight != null)
//				muzzleLight.SetProcess(false);
		}

		PointIntersect = new PhysicsPointQueryParameters3D();
		PointIntersect.CollideWithAreas = true;
		PointIntersect.CollideWithBodies = false;
		PointIntersect.CollisionMask = (1 << GameManager.FogLayer);
		//Get Haste FireRate
		_hasteFireRate = _fireRate * .7f;
		Hide();
	}

	public void Init(PlayerInfo p)
	{
		playerInfo = p;
		playerInfo.WeaponHand.AddChild(this);
		playerInfo.WeaponHand.Position = Offset;

		if (Weapon == null)
			Weapon = this;

		for (int i = 0; i < models.Length; i++)
		{
			if (i == models.Length - 1)
				fxMeshes = GameManager.CreateFXMeshInstance3D(playerInfo.WeaponHand);

			ModelController model = models[i];
			model.currentLayer = p.uiLayer;
			model.currentState = GameManager.FuncState.Ready;
			model.Init();
			if (i < models.Length - 1)
				modelsMeshes.AddRange(GameManager.GetAllChildrensByType<MeshInstance3D>(model));
		}

		for (int i = 0; i < models.Length; i++)
		{
			ModelController model = models[i];
			model.Start();
		}

		//Ugly Hack but Gauntlet rotation is all messed up
		if (isMelee)
		{
			Node3D barrelTag = (Node3D)barrelObject.GetParent();
			if (models[0].Model.tagsIdbyName.TryGetValue("tag_barrel", out int tagId))
			{
				barrelTag.Position = models[0].Model.tagsbyId[tagId][0].origin;
				barrelTag.Quaternion = models[0].Model.tagsbyId[tagId][0].rotation;
			}
			muzzleObject.Position += barrelTag.Position;
			muzzleObject.Quaternion *= Quaternion.FromEuler(Vector3.Up * Mathf.Pi);
		}

		if (playerInfo.playerThing.avatar != null)
			playerInfo.playerThing.avatar.LoadWeapon(models, isMelee, barrelObject, muzzleObject);

		if (muzzleObject != null)
		{
			muzzleObject.Visible = false;
			if (muzzleLight != null)
			{
				muzzleLight.Reparent(muzzleObject);
				muzzleLight.Position = new Vector3(0, 0, .05f);
			}
		}

		if (useCrosshair)
		{
			Texture2D crossHair;
			int weaponIndex = p.playerControls.CurrentWeapon;
			int crossHairIndex = p.configData.CroosHair[weaponIndex];
			if (crossHairIndex > 100)
			{
				crossHairIndex -= 100;
				if (crossHairIndex < ThingsManager.largeCrosshairs.Count)
					crossHair = ThingsManager.largeCrosshairs[crossHairIndex];
				else
					crossHair = ThingsManager.defaultCrosshair;
			}
			else if (crossHairIndex < ThingsManager.smallCrosshairs.Count)
				crossHair = ThingsManager.smallCrosshairs[crossHairIndex];
			else
				crossHair = ThingsManager.defaultCrosshair;
			p.playerPostProcessing.playerHUD.crossHair.Texture = crossHair;
			p.playerPostProcessing.playerHUD.crossHair.Show();
		}
		else
			p.playerPostProcessing.playerHUD.crossHair.Hide();

		OnInit();
	}
	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		if (!Visible)
			Show();

		if (hasQuad != playerInfo.quadDamage) 
		{
			hasQuad = playerInfo.quadDamage;
			if (hasQuad)
				currentFx |= GameManager.QuadFX;
			else
				currentFx &= ~GameManager.QuadFX;
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		if (isRegenerating != playerInfo.regenerating)
		{
			isRegenerating = playerInfo.regenerating;
			if (isRegenerating)
				currentFx |= GameManager.RegenFX;
			else
				currentFx &= ~GameManager.RegenFX;
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		if (isInvisible != playerInfo.invis)
		{
			isInvisible = playerInfo.invis;
			if (isInvisible)
			{
				currentFx |= GameManager.InvisFX;
				GameManager.ChangeFx(modelsMeshes, GameManager.InvisFX, true, false);
			}
			else
			{
				currentFx &= ~GameManager.InvisFX;
				GameManager.ChangeFx(modelsMeshes, 0, true, false);
			}
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		if (hasBattleSuit != playerInfo.battleSuit)
		{
			hasBattleSuit = playerInfo.battleSuit;
			if (hasBattleSuit)
				currentFx |= GameManager.BattleSuitFX;
			else
				currentFx &= ~GameManager.BattleSuitFX;
			GameManager.ChangeFx(fxMeshes, currentFx, true);
		}

		float deltaTime = (float)delta;
		if (GameOptions.UseMuzzleLight)
		{
			if (muzzleLight != null)
			{
				if (muzzleLight.Visible)
				{
					muzzleLight.LightEnergy = Mathf.Max(Mathf.Lerp(muzzleLight.LightEnergy, 0, deltaTime * muzzleLightTime), 0);
					if (muzzleLight.LightEnergy <= 0.8f)
					{
						if (muzzleObject != null)
							if (muzzleObject.Visible)
							{
								muzzleObject.Visible = false;
								if (playerInfo.playerThing.avatar != null)
									playerInfo.playerThing.avatar.MuzzleFlashSetActive(false);
							}
					}
				}
			}
		}

		MousePosition.X = playerInfo.playerControls.Look.X + playerInfo.playerControls.playerVelocity.X;
		MousePosition.Y = playerInfo.playerControls.Look.Y + playerInfo.playerControls.playerVelocity.Y;

		ApplyRotation(GetRotation((MousePosition - oldMousePosition) * Sensitivity, deltaTime), deltaTime);
		oldMousePosition = oldMousePosition.Lerp(MousePosition, rotateSpeed * deltaTime);

		if (putAway)
		{
			if (playerInfo.playerThing.avatar != null)
				playerInfo.playerThing.avatar.UnloadWeapon();

			LowerAmount = Mathf.Lerp(LowerAmount, 1, deltaTime * swapSpeed);
			if (LowerAmount > .99f)
			{
				playerInfo.playerPostProcessing.playerHUD.HideAmmo();
				QueueFree();
			}
		}
		else
			LowerAmount = Mathf.Lerp(LowerAmount, 0, deltaTime * swapSpeed);
		LowerAmount = Mathf.Clamp(LowerAmount, 0, 1);
		if (!weaponReady)
		{
			if (LowerAmount < ReadyHeight)
				weaponReady = true;
		}

		if (fireTime > 0)
		{
			if (fullAuto)
				KickAmount = Mathf.Lerp(KickAmount, 1, deltaTime * kickSpeed);
			else if (fireTime < KickBackTime)
				KickAmount = Mathf.Lerp(KickAmount, 0, deltaTime * kickSpeed);
			else
				KickAmount = Mathf.Lerp(KickAmount, 1, deltaTime * kickSpeed);
		}
		else
			KickAmount = Mathf.Lerp(KickAmount, 0, deltaTime * kickSpeed);
		KickAmount = Mathf.Clamp(KickAmount, 0, 1);

		if (GameOptions.HeadBob && playerInfo.playerControls.bobActive)
			interp = Mathf.Lerp(interp, 1, deltaTime * 5);
		else
			interp = Mathf.Lerp(interp, 0, deltaTime * 6);
		interp = Mathf.Clamp(interp, 0, 1);

		Vector2 Bob = playerInfo.playerControls.currentBob * interp;

		Position = oldPosition.Lerp(new Vector3(KickOffSet * KickAmount, LowerOffset * LowerAmount + Bob.Y * .1f, Bob.X * .05f), Mathf.Clamp(10 * deltaTime, 0, 1));
		oldPosition = Position;
		OnUpdate(deltaTime);
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;

		if (fireTime <= 0f)
		{
			faceTime = 1.5f;
			if ((useCooldown) && (cooldown))
			{
				coolTimer += deltaTime;
				if (coolTimer >= cooldownTime)
				{
					coolTimer = 0;
					cooldown = false;
				}
			}
		}
		else
		{
			fireTime -= deltaTime;
			if (fireTime < 0.1f)
				playerInfo.playerPostProcessing.playerHUD.SetAmmoCoolDown(false);

			if (fireTime <= 0)
			{
				faceTime = 1.5f;
				coolTimer = 0;
				if (useCooldown)
				{
					cooldown = true;
					OnCoolDown();
				}
			}
			else
			{
				coolTimer += deltaTime;
				faceTime -= deltaTime;
				if (faceTime <= 0)
				{
					faceTime = 0.5f;
					playerInfo.playerPostProcessing.playerHUD.SetAttackFace();
				}
			}
		}
		OnPhysicsUpdate(deltaTime);
	}
	Quaternion GetRotation(Vector2 mouse, float delta)
	{
		mouse = mouse.LimitLength(maxTurn);

		Quaternion rotX = new Quaternion(Vector3.Forward, mouse.Y);
		Quaternion rotY = new Quaternion(Vector3.Up, mouse.X);

		if (barrelObject != null) 
		{
			Quaternion rotBarrel = RotateBarrel(delta).FastNormal();
			float speed = rotateSpeed * delta;
			barrelObject.Quaternion = barrelObject.Quaternion.Slerp(rotBarrel, speed);
			if (playerInfo.playerThing.avatar != null)
				playerInfo.playerThing.avatar.RotateBarrel(rotBarrel, speed);
		}

		Quaternion targetRot = rotX * rotY;

		return targetRot.Normalized();
	}

	void ApplyRotation(Quaternion targetRot, float deltaTime)
	{
		Quaternion = Quaternion.Slerp(targetRot, rotateSpeed * deltaTime);
	}

	protected virtual Quaternion RotateBarrel(float deltaTime)
	{
		return Quaternion.Identity;
	}
	protected virtual void OnUpdate(float deltaTime) { }

	protected virtual void OnPhysicsUpdate(float deltaTime) { }
	protected virtual void OnInit() { }
	protected virtual void OnCoolDown() { }
	public virtual bool Fire()
	{
		return false;
	}

	public override void _ExitTree()
	{
		playerInfo.playerControls.playerWeapon = null;
	}

	public Vector2 GetDispersion()
	{
		float t = 2 * Mathf.Pi * (float)GD.RandRange(0, 1f);
		float r = (float)GD.RandRange(0, 1f);// + (float)GD.RandRange(0, 1f);
//		if (r > 1)
//			r = 2 - r;

		Vector2 dispersion = new Vector2(r * Mathf.Cos(t) * horizontalDispersion, r * Mathf.Sin(t) * verticalDispersion);
		return dispersion;
	}
	public bool CheckIfCanMark(PhysicsDirectSpaceState3D SpaceState, CollisionObject3D collider, Vector3 collision)
	{
		if (collider is Damageable)
			return false;

		//Don't mark moving platforms
		if (collider is Crusher)
			return false;

		//Check if mapcollider are noMarks
		if (MapLoader.noMarks.Contains(collider))
			return false;
		
		//Check if collision in inside a fog Area
		PointIntersect.Position = collision;

		var hits = SpaceState.IntersectPoint(PointIntersect);
		if (hits.Count == 0)
			return true;

		return false;
	}
}
```

./Assets/Scripts/Player/PlayerInfo.cs:
```
using Godot;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
public partial class PlayerInfo : Node3D
{
	[Export]
	public PlayerControls playerControls;
	[Export]
	public PlayerCamera playerCamera;
	[Export]
	public MultiAudioStream audioStream;
	[Export]
	public PlayerThing playerThing;
	[Export]
	public PlayerPostProcessing playerPostProcessing;
	[Export]
	public Node3D WeaponHand;

	//Weapons and Ammo
	public int[] Ammo = new int[11] { 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; //bullets, shells, grenades, rockets, lightning, slugs, cells, bfgammo, nailammo, chainammo, proxammo
	public bool[] Weapon = new bool[14] { true, true, false, false, false, false, false, false, false, false, false, false, false, false }; //gauntlet, machinegun, shotgun, grenade launcher, rocket launcher, lightning gun, railgun, plasma gun, bfg10k, grapple, nailgun, chaingun, proxmine, heavymachinegun
	public int[] MaxAmmo = new int[11] { 200, 200, 200, 200, 200, 200, 200, 300, 25, 300, 200 };
	public int[] DefaultAmmo = new int[11] { 50, 10, 5, 5, 60, 10, 30, 100, 10, 100, 10 };
	//Const Weapon Nums
	public const int Gauntlet = 0;
	public const int MachineGun = 1;
	public const int Shotgun = 2;
	public const int GrenadeLauncher = 3;
	public const int RocketLauncher = 4;
	public const int LightningGun = 5;
	public const int Railgun = 6;
	public const int PlasmaGun = 7;
	public const int BFG10K = 8;
	public const int Grapple = 9;
	public const int NailGun = 10;
	public const int ChainGun = 11;
	public const int ProxLauncher = 12;
	public const int HeavyMachineGun = 13;


	//Const Ammo Nums
	public const int bulletsAmmo = 0;
	public const int shellsAmmo = 1;
	public const int grenadesAmmo = 2;
	public const int rocketsAmmo = 3;
	public const int lightningAmmo = 4;
	public const int slugAmmo = 5;
	public const int cellsAmmo = 6;
	public const int bfgAmmo = 7;
	public const int nailAmmo = 8;
	public const int chainAmmo = 9;
	public const int minesAmmo = 10;


	//PowerUps
	public bool godMode = false;
	public bool quadDamage = false;
	public bool battleSuit = false;
	public bool invis = false;
	public bool regenerating = false;
	public bool haste = false;
	public bool flight = false;

	public int MaxHealth = 100;
	public int MaxBonusHealth = 200;
	public int MaxArmor = 100;
	public int MaxBonusArmor = 200;
	[Export]
	public PackedScene[] WeaponPrefabs = new PackedScene[9];

	public uint viewLayer;
	public uint playerLayer;
	public uint uiLayer;
	public int localPlayerNum;

	public PlayerConfigData configData = new PlayerConfigData();
	public class PlayerConfigData
	{
		public string ModelName { get; set; } = "crash";										// Model Name.
		public string SkinName { get; set; } = "default";										// Skin Name.
		public int FOV { get; set; } = 90;														// View Camera FOV.
		public float[] MouseSensitivity { get; set; } = new float[2] { .5f, .5f };				// Mouse Sensitivity.
		public float[] StickSensitivity { get; set; } = new float[2] { 4f, 3f };				// Controller Stick Sensitivity.
		public bool InvertView { get; set; } = false;											// Y Axis View Invert Controls.
		public bool AutoHop { get; set; } = false;												// Allows player to just hold jump button to keep on bhopping perfectly.
		public bool BloodScreen { get; set; } = true;											// Show Visible Pain Feedback.
		public int[] CroosHair { get; set; } = new int[14] { 5, 5, 5, 5, 5, 5, 107, 5, 5, 5, 5, 5, 5, 5 };     //gauntlet, machinegun, shotgun, grenade launcher, rocket launcher, lightning gun, railgun, plasma gun, bfg10k, grapple, nailgun, chaingun, proxmine, heavymachinegun
		public int CroosHairAlpha { get; set; } = 25;											// CrossHair Alpha Value.
		public int CroosHairScale { get; set; } = 100;											// CrossHair Scale Value.
		public string ModulateColor { get; set; } = "#50a1cd";                                  // Modulate Color.
		public bool AutoSwap { get; set; } = true;												// Auto Swap if new weapon is picked
		public bool SafeSwap { get; set; } = true;												// When out of ammo always swap to safe weapon
		public int HUD2DScale { get; set; } = 100;												// HUD's Sprites Scale.
		public int HUD3DScale  { get; set; } = 100;												// HUD's Models Scale.
		public bool HUDShow { get; set; } = true;												// Show Hud.
	}

	public void SetPlayer(int playerNum)
	{
		localPlayerNum = playerNum;
		viewLayer = (uint)(1 << (GameManager.Player1ViewLayer + localPlayerNum));
		playerLayer = (uint)(1 << (GameManager.Player1Layer + localPlayerNum));
		playerThing.CollisionLayer = playerLayer;
		uiLayer = (uint)(1 << (GameManager.Player1UIViewLayer + localPlayerNum));
		playerCamera.ViewCamera.CullMask = viewLayer | uiLayer;
		playerCamera.ThirdPerson.CullMask = viewLayer;
		playerCamera.playerPostProcessing.ViewMask = viewLayer;
		playerCamera.playerPostProcessing.UIMask = uiLayer;
		playerCamera.playerPostProcessing.InitPost(this);
		for (int i = 0; i < Weapon.Length; i++)
		{
			if (Weapon[i])
				playerPostProcessing.playerHUD.AddWeapon(i);
		}
		LoadSavedConfigData();
	}

	public void UpdatePlayer(int playerNum)
	{
		localPlayerNum = playerNum;
		viewLayer = (uint)(1 << (GameManager.Player1ViewLayer + localPlayerNum));
		playerLayer = (uint)(1 << (GameManager.Player1Layer + localPlayerNum));
		playerThing.CollisionLayer = playerLayer;
		uiLayer = (uint)(1 << (GameManager.Player1UIViewLayer + localPlayerNum));
		playerCamera.ViewCamera.CullMask = viewLayer | uiLayer;
		playerCamera.ThirdPerson.CullMask = viewLayer;
		playerCamera.playerPostProcessing.ViewMask = viewLayer;
		playerCamera.playerPostProcessing.UIMask = uiLayer;
		playerCamera.playerPostProcessing.UpdateLayersPost();
		//Change UI Weapon Layer
		List<MeshInstance3D> Childrens = GameManager.GetAllChildrensByType<MeshInstance3D>(WeaponHand);
		foreach (MeshInstance3D mesh in Childrens)
			mesh.Layers = uiLayer;

		if (playerThing.avatar == null)
			return;

		if (playerCamera.currentThirdPerson)
			playerControls.playerThing.avatar.ChangeLayer(GameManager.AllPlayerViewMask);
		else
			playerControls.playerThing.avatar.ChangeLayer(GameManager.AllPlayerViewMask & ~((uint)(playerControls.playerInfo.viewLayer)));
	}

	public void Reset()
	{
		Ammo = new int[11] { 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		Weapon = new bool[14] { true, true, false, false, false, false, false, false, false, false, false, false, false, false };
		MaxAmmo = new int[11] { 200, 200, 200, 200, 200, 200, 200, 300, 200, 300, 200 };

		godMode = false;
		quadDamage = false;
		battleSuit = false;
		invis = false;
		regenerating = false;
		haste = false;
		flight = false;

		playerPostProcessing.ResetEffects();

		playerThing.currentWaterSurface = null;
		playerThing.underWater = false;
		playerThing.waterLever = 0;
		playerThing.inDamageable = WaterSurface.DamageableType.None;
		playerThing.hitpoints = 100;
		playerThing.armor = 0;

		playerThing.dropPowerUps = true;

		playerThing.painTime = 0;
		playerThing.quadTime = 0;
		playerThing.hasteTime = 0;
		playerThing.invisTime = 0;
		playerThing.regenTime = 0;
		playerThing.regenFXTime = 0;
		playerThing.enviroSuitTime = 0;
		playerThing.flightTime = 0;
		playerThing.flightSoundTime = 0;
		playerThing.lastDamageTime = 0;

		playerThing.lastAttacker = null;
		playerThing.holdableItem = PlayerThing.HoldableItem.None;

		playerControls.impulseVector = Vector3.Zero;
		playerControls.CurrentWeapon = -1;
		playerControls.SwapWeapon = -1;

		for (int i = 0; i < Weapon.Length; i++)
		{
			if (Weapon[i])
				playerPostProcessing.playerHUD.AddWeapon(i);
		}
	}

	public bool LoadSavedConfigData()
	{
		bool loaded = false;
		string configFile = Directory.GetCurrentDirectory() + "/PlayersConfigs/" + playerThing.playerName + ".cfg";
		if (File.Exists(configFile))
		{
			string jsonString = File.ReadAllText(configFile);
			try
			{
				configData = JsonSerializer.Deserialize(jsonString, SourceGenerationContext.Default.PlayerConfigData);
				loaded = true;
			}
			catch (JsonException)
			{
				configData = new PlayerConfigData();
			}
			if (loaded)
			{
				playerThing.modelName = configData.ModelName;
				playerThing.skinName = configData.SkinName;

				if ((configData.FOV < 30) || (configData.FOV > 130))
					configData.FOV = 90;
				playerCamera.ViewCamera.Fov = configData.FOV;

				if (configData.CroosHair.Length < 14)
					configData.CroosHair = new int[14] { 5, 5, 5, 5, 5, 5, 107, 5, 5, 5, 5, 5, 5, 5 };

				for (int i = 0; i < configData.CroosHair.Length; i++)
				{
					int CrossHair = configData.CroosHair[i];
					if (CrossHair > 50)
						CrossHair -= 100;

					if ((CrossHair < 0) || (CrossHair > 50))
						CrossHair = 5;
				}

				if ((configData.CroosHairAlpha < 0) || (configData.CroosHairAlpha > 100))
					configData.CroosHairAlpha = 25;
				playerPostProcessing.playerHUD.ChangeCrossHairAlpha(configData.CroosHairAlpha);

				if ((configData.CroosHairScale < 10) || (configData.CroosHairScale > 100))
					configData.CroosHairAlpha = 100;
				playerPostProcessing.playerHUD.ChangeCrossHairScale(configData.CroosHairScale);

				Color modulate;
				try
				{
					modulate = new Color(configData.ModulateColor);
				}
				catch (Exception e)
				{
					modulate = new Color("#50a1cd");
				}
				modulate.R = Mathf.Max(0.1f, modulate.R);
				modulate.G = Mathf.Max(0.1f, modulate.G);
				modulate.B = Mathf.Max(0.1f, modulate.B);
				playerThing.modulate = modulate;

				if ((configData.HUD2DScale < 10) || (configData.HUD2DScale > 100))
					configData.HUD2DScale = 100;
				playerPostProcessing.playerHUD.ChangeSpriteScale(configData.HUD2DScale);

				if ((configData.HUD3DScale < 10) || (configData.HUD3DScale > 100))
					configData.HUD3DScale = 100;
				playerPostProcessing.playerHUD.ChangeModelScale(configData.HUD3DScale);

				if (!configData.HUDShow)
					playerPostProcessing.playerHUD.UpdateLayersHud(1 << GameManager.UINotVisibleLayer);
			}
		}
		return loaded;
	}
	public void SaveConfigData()
	{
		string configFile = Directory.GetCurrentDirectory() + "/PlayersConfigs/" + playerThing.playerName + ".cfg";
		FileStream errorFile = File.Open(configFile, FileMode.Create, System.IO.FileAccess.ReadWrite);
		if (File.Exists(configFile))
		{
			errorFile.Seek(0, SeekOrigin.Begin);
			byte[] writeData = JsonSerializer.SerializeToUtf8Bytes(configData, SourceGenerationContext.Default.PlayerConfigData);
			errorFile.Write(writeData);
			errorFile.Close();
		}
	}
}
```

./Assets/Scripts/Player/PlayerControls.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class PlayerControls : InterpolatedNode3D
{
	[Export]
	public PlayerInfo playerInfo;
	[Export]
	public PlayerThing playerThing;

	public PlayerWeapon playerWeapon;
	[Export]
	public PlayerCamera playerCamera;
	[Export]
	public AnimationTree weaponPositionAnimation;
	public SeparationRayShape3D feetRay;

	public CapsuleShape3D	collider;
	public CapsuleShape3D damageCollider;

	private Vector2 centerHeight = new Vector2(0.5f, 0.2f);	// character controller center height, x standing, y crouched
	private Vector2 height = new Vector2(1.6f, 1.1f);		// character controller height, x standing, y crouched
	private float camerasHeight = .05f;
	private float ccHeight = .05f;

	public Vector2 viewDirection = new Vector2(0, 0);

	public Vector3 lastGlobalPosition = new Vector3(0, 0, 0);

	public Vector3 impulseVector = Vector3.Zero;

	public Vector3 jumpPadVel = Vector3.Zero;

	// Movement stuff
	public const float crouchSpeed = 3.0f;					// Crouch speed
	public const float walkSpeed = 5.0f;					// Walk speed
	public const float runSpeed = 10.0f;					// Run speed
	public const float swimSpeed = 7.0f;					// Swim speed
	private float oldSpeed = 0;								// Previous move speed
	public float fallSpeed = 0;								// Acumulated fallSpeed

	public float moveSpeed;									// Ground move speed
	public const float runAcceleration = 14.0f;				// Ground accel
	public const float runDeacceleration = 10.0f;			// Deacceleration that occurs when running on the ground
	public const float waterAcceleration = 8.0f;			// Water accel
	public const float airAcceleration = 2.0f;				// Air accel
	public const float airDecceleration = 2.0f;				// Deacceleration experienced when ooposite strafing
	public const float airControl = 0.3f;					// How precise air control is
	public const float sideStrafeAcceleration = 50.0f;		// How fast acceleration occurs to get up to sideStrafeSpeed when
	public const float sideStrafeSpeed = 1.0f;				// What the max speed to generate when side strafing
	public const float jumpSpeed = 8.0f;					// The speed at which the character's up axis gains when hitting jump
	public const float fallSpeedLimit = -22f;				// The max fallSpeed without taking damage, modified to Quake Live value

	public Vector3 playerVelocity = Vector3.Zero;
	private Vector2 deadZone = Vector2.Zero;

	public bool WhishJump { get { return wishJump; } }

	private bool wishRestart = false;
	private bool wishJump = false;
	private bool wishSink = false;
	private bool wishFire = false;
	private bool wishActivate = false;
	private bool controllerIsGrounded = true;
	private bool controllerWasGrounded = true;
	private bool onLadder = false;
	private float deathTime = 0;
	private const float respawnDelay = 1.7f;

	private int lastJumpIndex = PlayerModel.LowerAnimation.Jump;
	private bool applyFallDamage = true;

	//Head/Weapon Bob
	public const float vBob = .005f;
	public const float hBob = .05f;
	public bool bobActive;
	public Vector2 currentBob = Vector2.Zero;

	public Vector2 Look = Vector2.Zero;
	struct currentMove
	{
		public float forwardSpeed;
		public float sidewaysSpeed;
	}

	private currentMove cMove;

	public int CurrentWeapon = -1;
	public int SwapWeapon = -1;

	public MoveType currentMoveType = MoveType.Run;
	public enum MoveType
	{
		Crouch,
		Walk,
		Run
	}

	public PlayerThing.FootStepType footStep = PlayerThing.FootStepType.Normal;

	public PlayerInput playerInput;
	public struct PlayerInput
	{
		private readonly int _Device;
		public int Device { get { return _Device; } }

		private readonly string _Start;
		public string Start { get { return _Start; } }
		private readonly string _Move_Forward;
		public string Move_Forward { get { return _Move_Forward; } }

		private readonly string _Move_Back;
		public string Move_Back { get { return _Move_Back; } }
		private readonly string _Move_Left;
		public string Move_Left { get { return _Move_Left; } }
		private readonly string _Move_Right;
		public string Move_Right { get { return _Move_Right; } }
		private readonly string _Action_Fire;
		public string Action_Fire { get { return _Action_Fire; } }
		private readonly string _Action_Jump;
		public string Action_Jump { get { return _Action_Jump; } }
		private readonly string _Action_Crouch;
		public string Action_Crouch { get { return _Action_Crouch; } }
		private readonly string _Action_Run;
		public string Action_Run { get { return _Action_Run; } }
		private readonly string _Action_Item;
		public string Action_Item { get { return _Action_Item; } }
		private readonly string _Action_CameraSwitch;
		public string Action_CameraSwitch { get { return _Action_CameraSwitch; } }
		private readonly string _Action_WeaponSwitch_Up;
		public string Action_WeaponSwitch_Up { get { return _Action_WeaponSwitch_Up; } }
		private readonly string _Action_WeaponSwitch_Down;
		public string Action_WeaponSwitch_Down { get { return _Action_WeaponSwitch_Down; } }
		public PlayerInput(int num)
		{
			_Device = num;
			_Start = "Start_" + num;
			_Move_Forward = "Move_Forward_" + num;
			_Move_Back = "Move_Back_" + num;
			_Move_Left = "Move_Left_" + num;
			_Move_Right = "Move_Right_" + num;
			_Action_Fire = "Action_Fire_" + num;
			_Action_Jump = "Action_Jump_" + num;
			_Action_Crouch = "Action_Crouch_" + num;
			_Action_Run = "Action_Run_" + num;
			_Action_Item = "Action_Item_" + num;
			_Action_CameraSwitch = "Action_CameraSwitch_" + num;
			_Action_WeaponSwitch_Up = "Action_WeaponSwitch_Up_" + num;
			_Action_WeaponSwitch_Down = "Action_WeaponSwitch_Down_" + num;
		}
	}

	private Vector3 rotAngle = Vector3.Zero;

	public override void _Ready()
	{
		moveSpeed = runSpeed;
		currentMoveType = MoveType.Run;
		weaponPositionAnimation.Active = true;
		weaponPositionAnimation.Set("parameters/fall_shot/active", true);
	}

	public void Init(int contollerNum)
	{
		playerInput = new PlayerInput(contollerNum);
	}

	public override void _Input(InputEvent @event)
	{
		if (GameManager.Paused)
			return;

		if (@event is InputEventJoypadButton)
		{
			if (Input.IsActionJustPressed(playerInput.Start))
			{
				int Joy = playerInput.Device - 1;
				deadZone = new Vector2(Input.GetJoyAxis(Joy, JoyAxis.RightY), Input.GetJoyAxis(Joy, JoyAxis.RightX));
			}
		}

		if (playerInput.Device != GameManager.ControllerType.MouseKeyboard)
			return;

		if (GameManager.Console.visible)
			return;

		if (@event is InputEventMouseMotion eventMouseMotion)
		{
			Look = eventMouseMotion.Relative;
			viewDirection.Y -= Look.X * playerInfo.configData.MouseSensitivity[0];
			viewDirection.X -= Look.Y * playerInfo.configData.MouseSensitivity[1] * (playerInfo.configData.InvertView ? -1: 1);
		}
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;
		bool consoleOpen = false;

		if (playerThing.Dead)
		{
			if (playerCamera != null)
				bobActive = false;

			if (deathTime < respawnDelay)
				deathTime += deltaTime;
			else if (playerThing.interpolatedTransform == null)
			{
				if (wishRestart)
					return;
				if (Input.IsActionJustPressed(playerInput.Action_Jump) || Input.IsActionJustPressed(playerInput.Action_Fire))
					wishRestart = true;
			}
			return;
		}

		if (playerInput.Device != GameManager.ControllerType.MouseKeyboard)
		{
			int Joy = playerInput.Device - 1;
			float Y = Input.GetJoyAxis(Joy, JoyAxis.RightX);
			float X = Input.GetJoyAxis(Joy, JoyAxis.RightY);
			if (Mathf.Abs(Y) > deadZone.Y)
				Y = Y - Mathf.Sign(Y) * deadZone.Y;
			else
				Y = 0;
			if (Mathf.Abs(X) > deadZone.X)
				X = X - Mathf.Sign(X) * deadZone.X;
			else
				X = 0;
			viewDirection.Y -= (Y) * playerInfo.configData.StickSensitivity[0];
			viewDirection.X -= (X) * playerInfo.configData.StickSensitivity[1] * (playerInfo.configData.InvertView ? -1: 1);
		}
		else if (GameManager.Console.visible)
			consoleOpen = true;

		if (viewDirection.Y < -180)
			viewDirection.Y += 360;
		if (viewDirection.Y > 180)
			viewDirection.Y -= 360;

		//restricted up/down looking angle
		if (viewDirection.X < -85)
			viewDirection.X = -85;
		if (viewDirection.X > 85)
			viewDirection.X = 85;

		rotAngle.Y = viewDirection.Y;
		playerInfo.RotationDegrees = rotAngle;

		if (!playerThing.ready)
			return;

		controllerIsGrounded = playerThing.IsOnFloor();
		playerThing.avatar.isGrounded = controllerIsGrounded;

		if (consoleOpen)
			return;

		if (Input.IsActionJustPressed(playerInput.Action_CameraSwitch))
			playerCamera.ChangeThirdPersonCamera(!playerCamera.currentThirdPerson);

		playerThing.avatar.ChangeView(viewDirection, deltaTime);
		playerThing.avatar.CheckLegTurn(playerCamera.GlobalTransform.ForwardVector());

		//Player can only crounch if it is grounded
		if ((Input.IsActionJustPressed(playerInput.Action_Crouch)) && (controllerIsGrounded))
		{
			if (oldSpeed == 0)
				oldSpeed = moveSpeed;
			moveSpeed = crouchSpeed;
			currentMoveType = MoveType.Crouch;
			ChangeHeight(false);
		}
		else if (Input.IsActionJustReleased(playerInput.Action_Crouch))
		{
			if (oldSpeed != 0)
				moveSpeed = oldSpeed;
			if (moveSpeed == walkSpeed)
				currentMoveType = MoveType.Walk;
			else
				currentMoveType = MoveType.Run;
			ChangeHeight(true);
			oldSpeed = 0;
		}
		else //CheckRun
		{
			if (GameOptions.runToggle)
			{
				if (Input.IsActionJustReleased(playerInput.Action_Run))
				{
					if (moveSpeed == walkSpeed)
					{
						moveSpeed = runSpeed;
						currentMoveType = MoveType.Run;
					}
					else
					{
						moveSpeed = walkSpeed;
						currentMoveType = MoveType.Walk;
					}
				}
			}
			else
			{
				if (Input.IsActionPressed(playerInput.Action_Run))
				{
					moveSpeed = runSpeed;
					currentMoveType = MoveType.Run;
				}
				else
				{
					moveSpeed = walkSpeed;
					currentMoveType = MoveType.Walk;
				}
			}
		}

		bool doGoundChecks = false;
		PlayerThing.FootStepType currentFootStep = PlayerThing.FootStepType.None;
		//Movement Checks
		if (playerThing.waterLever > 0)
		{
			if (playerThing.waterLever < 2)
				doGoundChecks = true;
			else
			{
				if (controllerIsGrounded)
					playerThing.avatar.TurnLegs((int)currentMoveType, cMove.sidewaysSpeed, cMove.forwardSpeed, deltaTime);
				else
					playerThing.avatar.Swim();
				wishJump = Input.IsActionPressed(playerInput.Action_Jump);

				if (wishJump)
					wishSink = false;
				else
					wishSink = Input.IsActionPressed(playerInput.Action_Crouch);
			}
		}
		else
			doGoundChecks = true;

		if (doGoundChecks)
		{
			if (currentMoveType != MoveType.Crouch)
				QueueJump();
			if (controllerIsGrounded)
			{
				if (!controllerWasGrounded)
					AnimateLegsOnLand();
				else if (playerThing.avatar.enableOffset)
					playerThing.avatar.TurnLegs((int)currentMoveType, cMove.sidewaysSpeed, cMove.forwardSpeed, deltaTime);
				if (wishJump)
					AnimateLegsOnJump();
				else
				{
					KinematicCollision3D lastCollision = playerThing.GetLastSlideCollision();
					if (lastCollision != null)
					{
						CollisionObject3D collisionObject = (CollisionObject3D)lastCollision.GetCollider();
						if (MapLoader.mapSurfaceTypes.TryGetValue(collisionObject, out SurfaceType st))
						{
							if (playerThing.waterLever == 1)
								currentFootStep = PlayerThing.FootStepType.Splash;
							else if (st.NoSteps)
								currentFootStep = PlayerThing.FootStepType.None;
							else if (st.MetalSteps)
								currentFootStep = PlayerThing.FootStepType.Clank;
							else if (st.Flesh)
								currentFootStep = PlayerThing.FootStepType.Flesh;
							else
								currentFootStep = footStep;

							if (st.NoFallDamage)
								applyFallDamage = false;
							if (st.Ladder)
								onLadder = true;
						}

					}
				}

			}
			else if (!onLadder)
			{
				KinematicCollision3D lastCollision = playerThing.GetLastSlideCollision();
				if (lastCollision != null)
				{
					CollisionObject3D collisionObject = (CollisionObject3D)lastCollision.GetCollider();
					if (MapLoader.mapSurfaceTypes.TryGetValue(collisionObject, out SurfaceType st))
					{
						if (st.Ladder)
							onLadder = true;
					}
				}
				if (onLadder)
					playerThing.avatar.TurnLegs((int)currentMoveType, cMove.sidewaysSpeed, cMove.forwardSpeed, deltaTime);
				else
					playerThing.avatar.TurnLegsOnJump(cMove.sidewaysSpeed, deltaTime);
			}
		}

		if ((GlobalPosition - lastGlobalPosition).LengthSquared() > .0001f)
		{
			bobActive = true;
			if ((controllerIsGrounded) && (currentMoveType == MoveType.Run))
				playerThing.PlayStepSound(currentFootStep);
		}
		else
			bobActive = false;

		currentBob = GetBob();

		if (Input.IsActionPressed(playerInput.Action_Fire))
			wishFire = true;

		if (Input.IsActionPressed(playerInput.Action_Item))
			wishActivate = true;

		//swap weapon
		if (playerWeapon == null)
		{
			if (SwapWeapon == -1)
			{
				if (playerInfo.configData.SafeSwap)
					SwapToBestSafeWeapon();
				else
					SwapToBestWeapon();
			}

			if (SwapWeapon > -1)
			{
				CurrentWeapon = SwapWeapon;
				playerWeapon = (PlayerWeapon)playerInfo.WeaponPrefabs[CurrentWeapon].Instantiate();
				playerWeapon.Init(playerInfo);
				playerInfo.playerPostProcessing.playerHUD.ChangeWeapon(CurrentWeapon);
				SwapWeapon = -1;
			}
		}

		CheckMouseWheelWeaponChange();

		if (playerInput.Device == GameManager.ControllerType.MouseKeyboard)
			CheckWeaponChangeByIndex();
	}

	public void CheckCrash()
	{
		if (fallSpeed > fallSpeedLimit)
		{
			playerThing.PlayModelSound("land1", false, false);
			fallSpeed = 0;
			applyFallDamage = true;
			return;
		}
		if (fallSpeed > -30)
		{
			if (applyFallDamage)
				playerThing.Damage(5, DamageType.Land);
			weaponPositionAnimation.Set("parameters/TimeScale/scale", 1.4f);
			weaponPositionAnimation.Set("parameters/depth/add_amount", .75f);
		}
		else
		{
			if (applyFallDamage)
				playerThing.Damage(10, DamageType.Fall);
			weaponPositionAnimation.Set("parameters/TimeScale/scale", 1f);
			weaponPositionAnimation.Set("parameters/depth/add_amount", 1f);
		}
		applyFallDamage = true;
		weaponPositionAnimation.Set("parameters/fall_shot/request", (int)AnimationNodeOneShot.OneShotRequest.Fire);
		fallSpeed = 0;
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;

		if (playerThing.Dead)
		{
			if (wishRestart)
			{
				wishRestart = false;
				deathTime = 0;
				viewDirection = Vector2.Zero;

				if (playerWeapon != null)
				{
					playerWeapon.QueueFree();
					playerWeapon = null;
				}

				playerInfo.Reset();
				playerThing.InitPlayer();
				return;
			}

			// Reset the gravity velocity
			float gravityAccumulator = GameManager.Instance.gravity;
			if (playerThing.waterLever > 0)
				gravityAccumulator = GameManager.Instance.waterDeadFall;
			playerVelocity = Vector3.Down * gravityAccumulator;
			ApplyMove(deltaTime);
			return;
		}

		if (!playerThing.ready)
			return;

		bool doGoundChecks = false;
		//Movement Checks
		if (playerThing.waterLever > 0)
		{
			if (playerThing.waterLever > 1)
				WaterMove(deltaTime);
			else
				doGoundChecks = true;
		}
		else
			doGoundChecks = true;

        if (doGoundChecks)
        {
			if (onLadder)
				LadderMove(deltaTime);
			else if (controllerIsGrounded)
			{
				GroundMove(deltaTime);
				if (!controllerWasGrounded)
					CheckCrash();
			}
			else
				AirMove(deltaTime);
		}

		controllerWasGrounded = controllerIsGrounded;
		//apply move
		ApplyMove(deltaTime);

		//dampen jump pad impulse
		if (jumpPadVel.LengthSquared() > 0)
		{
			if (playerInfo.flight && wishJump)
			{
				playerVelocity.Y = jumpPadVel.Y;
				if (playerVelocity.Y > GameManager.Instance.flightAccel)
					playerVelocity.Y = GameManager.Instance.flightAccel;
				jumpPadVel = Vector3.Zero;
			}
			else
			{
				jumpPadVel.Y -= (GameManager.Instance.gravity * deltaTime);
				if (jumpPadVel.Y < 0)
				{
					fallSpeed = jumpPadVel.Y;
					if (controllerIsGrounded)
						jumpPadVel = Vector3.Zero;
				}
			}
		}

		if (wishFire)
		{
			wishFire = false;
			if (playerWeapon == null)
				return;

			if (!playerWeapon.weaponReady)
				return;

			if (playerWeapon.Fire())
			{
				playerThing.avatar.Attack();
			}
		}

		if (wishActivate)
		{
			wishActivate = false;
			switch (playerThing.holdableItem)
			{
				default:
				case PlayerThing.HoldableItem.None:
				break;
				case PlayerThing.HoldableItem.Teleporter:
					playerThing.holdableItem = PlayerThing.HoldableItem.None;
					playerInfo.playerPostProcessing.playerHUD.RemoveHoldableItem();
					SpawnerManager.SpawnToLocation(playerThing);
				break;
			}
		}
	}

	void ApplyMove(float deltaTime)
	{
		if ((playerThing.Dead == false) && (impulseVector.LengthSquared() > 0))
		{
			if ((controllerIsGrounded) && (impulseVector.Y > 0))
			{
				impulseVector.Y -= -GameManager.Instance.gravity * deltaTime;
				if (impulseVector.Y < 0)
					impulseVector.Y = 0;
			}
			playerVelocity += impulseVector;
			impulseVector = Vector3.Zero;
		}

		playerThing.Velocity = (playerVelocity + jumpPadVel);
		lastGlobalPosition = GlobalPosition;
		playerThing.MoveAndSlide();
		if (onLadder)
		{
			//Need to check if player is still on a ladder
			int count = playerThing.GetSlideCollisionCount();
			bool foundLadder = false;
			for (int i = 0; i < count; i++)
			{
				KinematicCollision3D slideCollision = playerThing.GetSlideCollision(i);
				if (slideCollision == null)
					continue;

				CollisionObject3D collisionObject = (CollisionObject3D)slideCollision.GetCollider();
				if (MapLoader.mapSurfaceTypes.TryGetValue(collisionObject, out SurfaceType st))
				{
					if (st.Ladder)
					{
						foundLadder = true;
						break;
					}
				}
			}
			onLadder = foundLadder;
		}
	}
	private void SetMovementDir()
	{
		Vector2 Move = Input.GetVector(playerInput.Move_Left, playerInput.Move_Right, playerInput.Move_Forward, playerInput.Move_Back);
		if ((GameManager.Console.visible) && (playerInput.Device == GameManager.ControllerType.MouseKeyboard))
			Move = Vector2.Zero;

		cMove.forwardSpeed = Move.Y;
		cMove.sidewaysSpeed = Move.X;
	}

	public void ChangeHeight(bool Standing)
	{
		float newCenter = centerHeight.Y;
		float newHeight = height.Y;

		if (Standing)
		{
			newCenter = centerHeight.X;
			newHeight = height.X;
		}
		playerThing.Torso.Position = new Vector3(0, newCenter, 0);
		playerThing.damageShape.Position = new Vector3(0, newCenter, 0);

		collider.Height = newHeight;
		damageCollider.Height = newHeight - .1f; ;
		//Don't move camera on thirdperson
		if (playerCamera.currentThirdPerson)
			playerCamera.yOffset = .85f;
		else
			playerCamera.yOffset = 2 * newCenter + camerasHeight;
	}


	private void QueueJump()
	{
		if ((playerInfo.configData.AutoHop) || (playerInfo.flight))
		{
			wishJump = Input.IsActionPressed(playerInput.Action_Jump);
			return;
		}

		if (Input.IsActionJustPressed(playerInput.Action_Jump) && !wishJump)
			wishJump = true;
		if (Input.IsActionJustReleased(playerInput.Action_Jump))
			wishJump = false;
	}

	private Vector2 GetBob()
	{
		Vector2 bob;
		float speed = playerVelocity.Length();
		float moveSpeed = walkSpeed;
		if (moveSpeed != walkSpeed)
			moveSpeed = runSpeed;
		bob.X = Mathf.Cos(GameManager.CurrentTimeMsec * moveSpeed) * hBob * speed;
		if (currentMoveType == MoveType.Crouch)
			bob.X *= 5;

		bob.Y = Mathf.Sin(GameManager.CurrentTimeMsec * moveSpeed) * vBob * speed;
		if (currentMoveType == MoveType.Crouch)
			bob.Y *= 5;

		return bob;
	}

	private void WaterMove(float deltaTime)
	{
		Vector3 wishdir;
		float curreAcel;

		playerVelocity.Y *= ApplyFriction(0.6f, deltaTime);

		SetMovementDir();

		wishdir = new Vector3(cMove.sidewaysSpeed, 0, cMove.forwardSpeed);
		if (wishdir.LengthSquared() == 0)
		{
			if (!wishJump)
				wishdir.Y = -1;
		}
		else
			wishdir.Y = -cMove.forwardSpeed * viewDirection.X / 90;
		wishdir = playerInfo.Transform.Basis * wishdir;
		float wishspeed;
		wishdir = wishdir.GetLenghtAndNormalize(out wishspeed);
		wishspeed *= swimSpeed;

		//Check if Haste
		if (playerInfo.haste)
			wishspeed *= 1.3f;

		curreAcel = Accelerate(wishdir, wishspeed, waterAcceleration, deltaTime);
		playerVelocity.Y += curreAcel * wishdir.Y;
		if (wishJump)
			playerVelocity.Y += 1f;
		else if (wishSink)
			playerVelocity.Y -= 1f;
	}

	private void LadderMove(float deltaTime)
	{
		Vector3 wishdir;
		float friction = 1.0f;

		ApplyFriction(friction, deltaTime);

		SetMovementDir();

		wishdir = new Vector3(cMove.sidewaysSpeed, 0, cMove.forwardSpeed);
		if (wishdir.LengthSquared() == 0)
			wishdir.Y = 0;
		else
			wishdir.Y = -cMove.forwardSpeed * viewDirection.X / 90;
		wishdir = playerInfo.Transform.Basis * wishdir;
		float wishspeed;
		wishdir = wishdir.GetLenghtAndNormalize(out wishspeed);
		wishspeed *= moveSpeed;

		//Check if Haste
		if (playerInfo.haste)
			wishspeed *= 1.3f;

		Accelerate(wishdir, wishspeed, runAcceleration, deltaTime, runSpeed);
		playerVelocity.Y = wishdir.Y * runSpeed;
	}
	private void GroundMove(float deltaTime)
	{
		Vector3 wishdir;
		float friction = 0;

		// Do not apply friction if the player is queueing up the next jump
		if (!wishJump)
			friction = 1.0f;
		if (playerThing.waterLever > 0)
			friction = 0.75f;

		ApplyFriction(friction, deltaTime);

		SetMovementDir();

		wishdir = new Vector3(cMove.sidewaysSpeed, 0, cMove.forwardSpeed);
		wishdir = playerInfo.Transform.Basis * wishdir;
		float wishspeed;
		wishdir = wishdir.GetLenghtAndNormalize(out wishspeed);
		wishspeed *= moveSpeed;

		//Check if Haste
		if (playerInfo.haste)
			wishspeed *= 1.3f;

		Accelerate(wishdir, wishspeed, runAcceleration, deltaTime, runSpeed);

		// Reset the gravity velocity
		playerVelocity.Y = -GameManager.Instance.gravity * deltaTime;
		if (playerInfo.flight && wishJump)
			playerVelocity.Y = GameManager.Instance.gravity * deltaTime;
		else if ((controllerIsGrounded) && (wishJump))
		{
			float currentJumpSpeed = jumpSpeed;
			if (playerThing.waterLever > 0)
				currentJumpSpeed *= friction;
			playerVelocity.Y = currentJumpSpeed;
			wishJump = false;
		}
	}

	private float ApplyFriction(float t, float deltaTime)
	{
		Vector3 vec = playerVelocity;
		float speed;
		float newspeed;
		float control;
		float drop;

		vec.Y = 0.0f;
		speed = vec.Length();
		drop = 0.0f;

		if (playerThing.waterLever < 2)
		{
			control = speed < runDeacceleration ? runDeacceleration : speed;
			drop = control * GameManager.Instance.friction * deltaTime * t;
		}
		if (playerThing.waterLever > 0)
			drop += speed * GameManager.Instance.waterFriction * playerThing.waterLever * deltaTime * t;

		newspeed = speed - drop;

		if (newspeed < 0)
			newspeed = 0;
		if (speed > 0)
			newspeed /= speed;

		playerVelocity.X *= newspeed;
		playerVelocity.Z *= newspeed;
		return newspeed;
	}
	private float Accelerate(Vector3 wishdir, float wishspeed, float accel, float deltaTime, float wishaccel = 0)
	{
		float addspeed;
		float accelspeed;
		float currentspeed;
		bool autohop = false;
		currentspeed = playerVelocity.Dot(wishdir);
		addspeed = wishspeed - currentspeed;
		if (addspeed <= 0)
			return 0;
		if (wishaccel == 0)
			wishaccel = wishspeed;
		else if (playerInfo.configData.AutoHop && wishJump)
			autohop = true;

		accelspeed = accel * deltaTime * wishaccel;
		if (accelspeed > addspeed)
			accelspeed = addspeed;

		if (autohop)
			accelspeed *= .9f;

		playerVelocity.X += accelspeed * wishdir.X;
		playerVelocity.Z += accelspeed * wishdir.Z;
		return accelspeed;
	}

	private void AirMove(float deltaTime)
	{
		Vector3 wishdir;
		float accel;

		SetMovementDir();

		wishdir = new Vector3(cMove.sidewaysSpeed, 0, cMove.forwardSpeed);
		wishdir = playerInfo.Transform.Basis * wishdir;
		float wishspeed;
		wishdir = wishdir.GetLenghtAndNormalize(out wishspeed);
		wishspeed *= moveSpeed;

		//Check if Haste
		if (playerInfo.haste)
			wishspeed *= 1.3f;

		//Aircontrol
		float wishspeed2 = wishspeed;
		if (playerVelocity.Dot(wishdir) < 0)
			accel = airDecceleration;
		else
			accel = airAcceleration;
		// If the player is ONLY strafing left or right
		if ((cMove.forwardSpeed == 0) && (cMove.sidewaysSpeed != 0))
		{
			if (wishspeed > sideStrafeSpeed)
				wishspeed = sideStrafeSpeed;
			accel = sideStrafeAcceleration;
		}

		Accelerate(wishdir, wishspeed, accel, deltaTime);
		if (airControl > 0)
			AirControl(wishdir, wishspeed2, deltaTime);

		// Apply gravity
		if (jumpPadVel.LengthSquared() > 0)
			playerVelocity.Y = 0;
		else
		{
			if (playerInfo.flight && wishJump)
			{
				playerVelocity.Y += GameManager.Instance.flightAccel * deltaTime;
				if (playerVelocity.Y > GameManager.Instance.flightAccel)
					playerVelocity.Y = GameManager.Instance.flightAccel;
			}
			else
			{
				if (playerInfo.flight && (playerVelocity.Y > 0))
					playerVelocity.Y = 0;
				playerVelocity.Y -= GameManager.Instance.gravity * deltaTime;
				fallSpeed = playerVelocity.Y;
			}
		}
	}

	private void AirControl(Vector3 wishdir, float wishspeed, float deltaTime)
	{
		float zspeed;
		float speed;
		float dot;
		float k;

		// Can't control movement if not moving forward or backward
		if ((cMove.forwardSpeed == 0) || (Mathf.Abs(wishspeed) < 0.001))
			return;
		zspeed = playerVelocity.Y;
		playerVelocity.Y = 0;
		playerVelocity = playerVelocity.GetLenghtAndNormalize(out speed);

		dot = playerVelocity.Dot(wishdir);
		k = 32;
		k *= airControl * dot * dot * deltaTime;

		// Change direction while slowing down
		if (dot > 0)
		{
			playerVelocity.X = playerVelocity.X * speed + wishdir.X * k;
			playerVelocity.Y = playerVelocity.Y * speed + wishdir.Y * k;
			playerVelocity.Z = playerVelocity.Z * speed + wishdir.Z * k;

			playerVelocity = playerVelocity.Normalized();
		}

		playerVelocity.X *= speed;
		playerVelocity.Y = zspeed; // Note this line
		playerVelocity.Z *= speed;
	}

	public void AnimateLegsOnLand()
	{
		if (lastJumpIndex == PlayerModel.LowerAnimation.Jump)
			playerThing.avatar.lowerAnimation = PlayerModel.LowerAnimation.Land;
		else
			playerThing.avatar.lowerAnimation = PlayerModel.LowerAnimation.LandBack;
	}

	public void AnimateLegsOnJump()
	{
		if (cMove.forwardSpeed <= 0)
			lastJumpIndex = PlayerModel.LowerAnimation.Jump;
		else
			lastJumpIndex = PlayerModel.LowerAnimation.JumpBack;

		playerThing.avatar.lowerAnimation = lastJumpIndex;
		playerThing.avatar.enableOffset = false;
		playerThing.PlayModelSound("jump1", true, false);
	}

	public bool HasAmmo(int weapon)
	{
		switch (weapon)
		{
			default:
				return false;

			case PlayerInfo.Gauntlet:
				break;
			case PlayerInfo.HeavyMachineGun:
			case PlayerInfo.MachineGun:
				if (playerInfo.Ammo[PlayerInfo.bulletsAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.Shotgun:
				if (playerInfo.Ammo[PlayerInfo.shellsAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.GrenadeLauncher:
				if (playerInfo.Ammo[PlayerInfo.grenadesAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.RocketLauncher:
				if (playerInfo.Ammo[PlayerInfo.rocketsAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.LightningGun:
				if (playerInfo.Ammo[PlayerInfo.lightningAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.Railgun:
				if (playerInfo.Ammo[PlayerInfo.slugAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.PlasmaGun:
				if (playerInfo.Ammo[PlayerInfo.cellsAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.BFG10K:
				if (playerInfo.Ammo[PlayerInfo.bfgAmmo] < 40)
					return false;
				break;

			case PlayerInfo.NailGun:
				if (playerInfo.Ammo[PlayerInfo.nailAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.ChainGun:
				if (playerInfo.Ammo[PlayerInfo.chainAmmo] <= 0)
					return false;
				break;

			case PlayerInfo.ProxLauncher:
				if (playerInfo.Ammo[PlayerInfo.minesAmmo] <= 0)
					return false;
				break;

		}
		return true;
	}
	public bool TrySwapWeapon(int weapon)
	{
		if (CurrentWeapon == weapon || SwapWeapon != -1)
			return false;

		if (weapon < 0 || weapon >= playerInfo.Weapon.Length)
			return false;

		if (!playerInfo.Weapon[weapon])
			return false;

		if (!HasAmmo(weapon))
			return false;

		if (playerWeapon != null)
		{
			if (!playerWeapon.weaponReady)
				return false;

			playerWeapon.putAway = true;
		}

		SwapWeapon = weapon;
		return true;
	}
	public void SwapToBestSafeWeapon()
	{
		if (TrySwapWeapon(PlayerInfo.BFG10K)) return;
		if (TrySwapWeapon(PlayerInfo.ChainGun)) return;
		if (TrySwapWeapon(PlayerInfo.PlasmaGun)) return;
		if (TrySwapWeapon(PlayerInfo.HeavyMachineGun)) return;
		if (TrySwapWeapon(PlayerInfo.LightningGun)) return;
		if (TrySwapWeapon(PlayerInfo.NailGun)) return;
		if (TrySwapWeapon(PlayerInfo.Shotgun)) return;
		if (TrySwapWeapon(PlayerInfo.MachineGun)) return;
		if (TrySwapWeapon(PlayerInfo.Railgun)) return;
		if (TrySwapWeapon(PlayerInfo.ProxLauncher)) return;
		if (TrySwapWeapon(PlayerInfo.RocketLauncher)) return;
		if (TrySwapWeapon(PlayerInfo.GrenadeLauncher)) return;
		if (TrySwapWeapon(PlayerInfo.Gauntlet)) return;
	}
	public void SwapToBestWeapon()
	{
		if (TrySwapWeapon(PlayerInfo.BFG10K)) return;
		if (TrySwapWeapon(PlayerInfo.ChainGun)) return;
		if (TrySwapWeapon(PlayerInfo.PlasmaGun)) return;
		if (TrySwapWeapon(PlayerInfo.HeavyMachineGun)) return;
		if (TrySwapWeapon(PlayerInfo.Railgun)) return;
		if (TrySwapWeapon(PlayerInfo.LightningGun)) return;
		if (TrySwapWeapon(PlayerInfo.RocketLauncher)) return;
		if (TrySwapWeapon(PlayerInfo.ProxLauncher)) return;
		if (TrySwapWeapon(PlayerInfo.GrenadeLauncher)) return;
		if (TrySwapWeapon(PlayerInfo.NailGun)) return;
		if (TrySwapWeapon(PlayerInfo.Shotgun)) return;
		if (TrySwapWeapon(PlayerInfo.MachineGun)) return;
		if (TrySwapWeapon(PlayerInfo.Gauntlet)) return;
	}
	public void CheckMouseWheelWeaponChange()
	{
		if (Input.IsActionJustPressed(playerInput.Action_WeaponSwitch_Up))
		{
			bool gotWeapon = false;
			for (int NextWeapon = CurrentWeapon + 1; NextWeapon < 14; NextWeapon++)
			{
				gotWeapon = TrySwapWeapon(NextWeapon);
				if (gotWeapon)
					break;
			}
			if (!gotWeapon)
			{
				if (TrySwapWeapon(PlayerInfo.MachineGun))
					return;
				TrySwapWeapon(PlayerInfo.Gauntlet);
			}
		}
		else if (Input.IsActionJustPressed(playerInput.Action_WeaponSwitch_Down))
		{
			bool gotWeapon = false;
			for (int NextWeapon = CurrentWeapon - 1; NextWeapon >= 0; NextWeapon--)
			{
				gotWeapon = TrySwapWeapon(NextWeapon);
				if (gotWeapon)
					break;
			}
			if (!gotWeapon)
			{
				for (int NextWeapon = 13; NextWeapon >= 0; NextWeapon--)
				{
					gotWeapon = TrySwapWeapon(NextWeapon);
					if (gotWeapon)
						break;
				}
			}
		}
	}

	public void CheckWeaponChangeByIndex()
	{
		for (int i = 0; i < 10; i++)
		{
			if (Input.IsActionJustPressed("Action_WeaponSwitch_"+i))
			{
				TrySwapWeapon(i);
				break;
			}
		}
	}

}
```

./Assets/Scripts/Player/PlayerScore.cs:
```
using Godot;
using System;

public partial class PlayerScore : Node3D
{
	[Export]
	public Label3D PlayerName;
	[Export]
	public Label3D Kills;
	[Export]
	public Label3D Deaths;
	[Export]
	public Label3D Impressive;
	[Export]
	public Label3D Gauntlet;
	[Export]
	public Label3D Excellent;
	[Export]
	public Label3D LifeTime;
	public override void _Ready()
	{

	}

}
```

./Assets/Scripts/Player/GameOptions.cs:
```
using Godot;
public static class GameOptions
{
	public static float MainVolume = 1.0f;
	public static float BGMVolume = 1.0f;
	public static float SFXVolume = 1.0f;

	public static float hudBrightness = 0.9f;
	public static float ambientLight = 0.8f;
	public static bool aspectRatioCorrection = true;


//	public static Sprite crosshair = null;
	public static int crosshairIndex = 4;
	public static float crossHairAlpha = .4f;

	public static bool dynamicMusic = true;
	public static bool runToggle = true;
	public static bool UseMuzzleLight = true;
	public static bool HeadBob = true;
}```

./Assets/Scripts/Player/PlayerThing.cs:
```
using Godot;
using System.Collections.Generic;
using ExtensionMethods;

public partial class PlayerThing : CharacterBody3D, Damageable
{
	[Export]
	public Color modulate;
	[Export]
	public CollisionShape3D Torso;
	[Export]
	public CollisionShape3D Feet;
	[Export]
	public PlayerInfo playerInfo;
	[Export]
	public PlayerControls playerControls;
	[Export]
	public MultiAudioStream audioStream;
	[Export]
	public MultiAudioStream stepAudioStream;

	public PlayerViewPort playerViewPort;

	public InterpolatedTransform interpolatedTransform;
	public string modelName = "crash";
	public string skinName = "default";

	public static string drowningSound = "player/gurp";
	public static string wearOffSound = "items/wearoff";
	public static string regenSound = "items/regen";
	public static string protectSound = "items/protect3";
	public static string flySound = "items/flight";

	private static readonly string[] normalStep = { "player/footsteps/step1", "player/footsteps/step2", "player/footsteps/step3", "player/footsteps/step4" };
	private static readonly string[] clankStep = { "player/footsteps/clank1", "player/footsteps/clank2", "player/footsteps/clank3", "player/footsteps/clank4" };
	private static readonly string[] splashStep = { "player/footsteps/splash1", "player/footsteps/splash2", "player/footsteps/splash3", "player/footsteps/splash4" };
	private static readonly string[] bootStep = { "player/footsteps/boot1", "player/footsteps/boot2", "player/footsteps/boot3", "player/footsteps/boot4" };
	private static readonly string[] mechStep = { "player/footsteps/mech1", "player/footsteps/mech2", "player/footsteps/mech3", "player/footsteps/mech4" };
	private static readonly string[] fleshStep = { "player/footsteps/flesh1", "player/footsteps/flesh2", "player/footsteps/flesh3", "player/footsteps/flesh4" };
	private static readonly string[] energyStep = { "player/footsteps/energy1", "player/footsteps/energy2", "player/footsteps/energy3", "player/footsteps/energy4" };

	private string currentModel;
	private string currentSkin;
	[Export]
	public Node3D player;
	public PlayerModel avatar;

	private Area3D damageArea;
	public CollisionShape3D damageShape;
	public int Hitpoints { get { return hitpoints; } }
	public bool Dead { get { return hitpoints <= 0; } }
	public bool Bleed { get { return true; } }

	public string playerName 
	{ 
		get { return _playerName; }
		set
		{
			_playerName = value;
			playerInfo.playerPostProcessing.playerHUD.playerName.Text = value;
		}
	}
	private string _playerName = "Unnamed Player";

	public BloodType BloodColor { get { return BloodType.Red; } }

	public int hitpoints = 100;
	public int armor = 0;
	public int waterLever = 0;
	public int frags = 0;
	public int deaths = 0;

	public WaterSurface currentWaterSurface = null;

	public float painTime = 0f;
	public float quadTime = 0f;
	public float hasteTime = 0f;
	public float invisTime = 0f;
	public float regenTime = 0f;
	public float regenFXTime = 0f;
	public float enviroSuitTime = 0f;
	public float flightTime = 0f;
	public float flightSoundTime = 0f;

	public float lastDamageTime = 0f;

	public float environmentDamageTime = 0f;
	public float drownTime = 0f;

	private float stepTime = -1;

	public int drownDamage = 0;

	public bool underWater = false;
	public WaterSurface.DamageableType inDamageable = WaterSurface.DamageableType.None;
	public bool finished = false;
	public bool dropPowerUps = true;
	public Node3D lastAttacker = null;
	public bool ready { get { return currentState == GameManager.FuncState.Start; } }
	private float handicap = 1;
	public enum HoldableItem
	{
		None = 0,
		Teleporter = 1,
		Medkit = 2
	}
	public HoldableItem holdableItem = HoldableItem.None;

	public enum FootStepType
	{
		None,
		Normal,
		Clank,
		Splash,
		Boot,
		Mech,
		Flesh,
		Energy
	}

	private int skipFrames = 3;

	public GameManager.FuncState currentState = GameManager.FuncState.None;
	public override void _Ready()
	{
		playerControls.feetRay = (SeparationRayShape3D)Feet.Shape;

		damageArea = new Area3D();
		damageArea.Name = "Damage Area";
		damageArea.CollisionLayer = (1 << GameManager.WalkTriggerLayer);
		damageArea.CollisionMask = (1 << GameManager.ColliderLayer);

		AddChild(damageArea);
		damageArea.BodyEntered += OnBodyEntered;

		playerControls.damageCollider = new CapsuleShape3D();
		playerControls.damageCollider.Radius = .45f;
		playerControls.damageCollider.Height = 1.5f;

		damageShape = new CollisionShape3D();
		damageShape.Shape = playerControls.damageCollider;
		damageArea.AddChild(damageShape);

		playerControls.collider = (CapsuleShape3D)Torso.Shape;
		currentState = GameManager.FuncState.Ready;
	}
	public void InitPlayer()
	{
		CollisionLayer = playerInfo.playerLayer;
		CollisionMask |= GameManager.TakeDamageMask;
		interpolatedTransform = new InterpolatedTransform();
		interpolatedTransform.Name = "PlayerInterpolatedTransform";
		player.AddChild(interpolatedTransform);
		interpolatedTransform.SetSource(player);
		interpolatedTransform.SetInterpolationReset(playerControls);

		avatar = new PlayerModel();
		interpolatedTransform.AddChild(avatar);
		playerControls.footStep = FootStepType.Normal;
		avatar.LoadPlayer(ref modelName, ref skinName, (GameManager.AllPlayerViewMask & ~((uint)(playerInfo.viewLayer))), playerControls);
		if ((currentModel != modelName) || (currentSkin != skinName))
		{
			playerInfo.configData.ModelName = modelName;
			playerInfo.configData.SkinName = skinName;
			playerInfo.SaveConfigData();
		}
		currentModel = modelName;
		currentSkin = skinName;
		SpawnerManager.SpawnToLocation(this);
		playerControls.ChangeHeight(true);
		playerControls.feetRay.Length = .8f;

		if (playerControls.playerWeapon == null)
			playerControls.SwapToBestWeapon();

		playerInfo.playerPostProcessing.playerHUD.UpdateHealth(hitpoints);
		playerInfo.playerPostProcessing.playerHUD.UpdateArmor(armor);
		playerControls.playerCamera.ChangeThirdPersonCamera(false);
		currentState = GameManager.FuncState.Ready;
	}
	public void PlayModelSound(string soundName, bool byModel = true, bool overWriteSound = true)
	{
		if ((!overWriteSound) && (audioStream.Playing))
			return;

		if (byModel)
			soundName = "player/" + currentModel + "/" + soundName;
		else
			soundName = "player/" + soundName;
		audioStream.Stream = SoundManager.LoadSound(soundName);
		audioStream.Play();
	}

	public void PlayStepSound(FootStepType footstepType) 
	{
		if (stepTime > 0)
			return;

		switch(footstepType)
		{
			default:
			case FootStepType.None:
				return;
			break;
			case FootStepType.Normal:
				stepAudioStream.Stream = SoundManager.LoadSound(normalStep[GD.RandRange(0, 3)]);
			break;
			case FootStepType.Clank:
				stepAudioStream.Stream = SoundManager.LoadSound(clankStep[GD.RandRange(0, 3)]);
			break;
			case FootStepType.Splash:
				stepAudioStream.Stream = SoundManager.LoadSound(splashStep[GD.RandRange(0, 3)]);
			break;
			case FootStepType.Boot:
				stepAudioStream.Stream = SoundManager.LoadSound(bootStep[GD.RandRange(0, 3)]);
			break;
			case FootStepType.Mech:
				stepAudioStream.Stream = SoundManager.LoadSound(mechStep[GD.RandRange(0, 3)]);
			break;
			case FootStepType.Flesh:
				stepAudioStream.Stream = SoundManager.LoadSound(fleshStep[GD.RandRange(0, 3)]);
			break;
			case FootStepType.Energy:
				stepAudioStream.Stream = SoundManager.LoadSound(energyStep[GD.RandRange(0, 3)]);
			break;
		}
		stepAudioStream.Play();
		if (hasteTime > 0)
			stepTime = .25f;
		else
			stepTime = .32f;
	}
	public void Impulse(Vector3 direction, float force)
	{
		if (!ready)
			return;

		float length = force / GameManager.Instance.playerMass;
		Vector3 impulse = direction * length;

		playerControls.impulseVector += impulse;
	}
	public void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null)
	{
		if (!ready)
		{
			if (damageType != DamageType.Telefrag)
				return;

			if (currentState != GameManager.FuncState.Ready)
				return;

			//If damageType is Telefrag, and player hasn't spawn yet then we need to move this player, otherwise both will spawn to the same place
			//this could happen just after loading a new map
			SpawnerManager.SpawnToLocation(this);
		}

		if (Dead)
			return;

		if ((damageType != DamageType.Environment) && (damageType != DamageType.Crusher) && (damageType != DamageType.Telefrag) && (damageType != DamageType.Trigger))
			amount = Mathf.RoundToInt(amount * handicap * GameManager.Instance.PlayerDamageReceive);

		if (playerInfo.battleSuit)
		{
			if (damageType == DamageType.Environment)
				amount = 0;
			else if ((damageType != DamageType.Crusher) && (damageType != DamageType.Telefrag) && (damageType != DamageType.Trigger))
			{
				if (damageType == DamageType.Explosion)
					amount = 0;
				else if (damageType == DamageType.Land)
				{
					amount = 0;
					PlayModelSound("pain100_1");
				}
				else if (damageType == DamageType.Fall)
				{
					amount = 0;
					PlayModelSound("fall1");
				}
				else
					amount = (amount >> 2);
				SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(protectSound));
			}
		}

		if (playerInfo.godMode)
		{
			if ((damageType != DamageType.Crusher) && (damageType != DamageType.Telefrag) && (damageType != DamageType.Trigger))
				amount = 0;
		}

		if (amount <= 0)
		{
			if ((damageType == DamageType.Crusher) || (damageType == DamageType.Telefrag) || (damageType == DamageType.Trigger))
				amount = 1000;
			else
				return;
		}

		if (armor > 0)
		{
			int subjectiveToMega = Mathf.Min(Mathf.Max(armor - 100, 0), amount);
			int subjectiveToNormal = Mathf.Min(armor, amount - subjectiveToMega);
			int absorbed = Mathf.Max(subjectiveToMega / 2 + subjectiveToNormal / 3, 1);

			armor -= absorbed;
			amount -= absorbed;
		}

		hitpoints -= amount;

		//Cap Negative Damage
		if (hitpoints < -99)
			hitpoints = -99;

		float painFlash = Mathf.Lerp(1, 2.5f, Mathf.Clamp(amount / 60, 0, 1));
		if (attacker == this)
			painFlash /= 2;

		if (playerInfo.configData.BloodScreen)
			playerInfo.playerPostProcessing.playerHUD.painFlashTime(painFlash);

		if (hitpoints <= 0)
		{
			CollisionLayer = (1 << GameManager.RagdollLayer);
			CollisionMask &= ~GameManager.TakeDamageMask;
			if (playerControls.playerWeapon != null)
				playerControls.playerWeapon.putAway = true;

			playerControls.playerCamera.ChangeThirdPersonCamera(true);

			DropWeaponsAndPowerUps();
			playerInfo.playerPostProcessing.playerHUD.RemoveAllItems();

			if (hitpoints <= GameManager.Instance.gibHealth)
			{
				float deathRatio = GameManager.Instance.currentDeathRatio;
				if (GameManager.currentMusic != GameManager.MusicType.Dynamic)
				{
					GameManager.Instance.GetDeathRatioAndReset(true);
					deathRatio = GameManager.Instance.currentDeathRatio;
				}
				if ((deathRatio > 1) || (damageType == DamageType.Telefrag))
				{
					if (damageType != DamageType.Generic)
						GameManager.Instance.PlayAnnouncer(GameManager.Instance.announcer + "holy_shit");
				}
				avatar.Gib(dropPowerUps);
			}
			else
			{
				if (damageType == DamageType.Drown)
					PlayModelSound("drown");
				else
					PlayModelSound("death" + GD.RandRange(1, 3));
				avatar.Die();
			}
			playerControls.feetRay.Length = 1.6f;
			currentState = GameManager.FuncState.None;
			deaths++;
			playerInfo.playerPostProcessing.playerHUD.deathsText.Text = "-" + deaths;
			if (attacker != this)
			{
				if (attacker == null)
					attacker = lastAttacker;

				if (attacker is PlayerThing agressor)
				{
					handicap = Mathf.Clamp(handicap - .05f, .5f, 2);
					agressor.handicap = Mathf.Clamp(agressor.handicap + .05f, .5f, 2);
					agressor.frags++;
					agressor.playerInfo.playerPostProcessing.playerHUD.fragsText.Text = "+" + agressor.frags;
					GameManager.Instance.CheckDeathCount(agressor.frags);
				}
			}
			ScoreBoard.Instance.RefreshScore();
		}
		else if (damageType == DamageType.Drown)
			SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(drowningSound + GD.RandRange(1, 2)));
		else if (painTime <= 0f)
		{
			if (damageType == DamageType.Land)
				PlayModelSound("pain100_1");
			else if (damageType == DamageType.Fall)
				PlayModelSound("fall1");
			else
			{
				if (hitpoints > 75)
					PlayModelSound("pain100_1");
				else if (hitpoints > 50)
					PlayModelSound("pain75_1");
				else if (hitpoints > 25)
					PlayModelSound("pain50_1");
				else
					PlayModelSound("pain25_1");
			}

			painTime = 1f;
			avatar.currentScale = Vector3.One * 1.1f;
			avatar.SetPain(true, painFlash);
		}

		if (attacker != this)
		{
			if (attacker is PlayerThing)
			{
				lastAttacker = attacker;
				lastDamageTime = 3;
			}
			else if (lastAttacker != null)
				lastDamageTime = 3;
		}

		playerInfo.playerPostProcessing.playerHUD.UpdateHealth(hitpoints);
		playerInfo.playerPostProcessing.playerHUD.UpdateArmor(armor);
	}
	public void JumpPadDest(Vector3 destination)
	{
		if (!ready)
			return;

		Vector3 position = GlobalPosition;
		Vector3 horizontalVelocity = destination - position;
		float height = destination.Y - (position.Y - playerControls.feetRay.Length);

		if (height <= 0)
		{
			playerControls.jumpPadVel = Vector3.Zero;
			return;
		}

		float time = Mathf.Sqrt((2 * height) / GameManager.Instance.gravity);
		float verticalVelocity = time * GameManager.Instance.gravity;

		horizontalVelocity.Y = 0;
		float dist;
		horizontalVelocity = horizontalVelocity.GetLenghtAndNormalize(out dist);
		float forward = dist / time;
		horizontalVelocity = horizontalVelocity * forward;
		playerControls.jumpPadVel = horizontalVelocity;
		playerControls.jumpPadVel.Y = verticalVelocity;
		playerControls.playerVelocity = Vector3.Zero;
		playerControls.fallSpeed = 0;
		playerControls.AnimateLegsOnJump();
	}

	public void DropNothingOnDeath()
	{
		dropPowerUps = false;
	}


	public void DropWeaponsAndPowerUps()
	{
		List<string> itemsToDrop = new List<string>();
		Dictionary<string, int> itemQuantity = new Dictionary<string, int>();

		if (quadTime > 0)
		{
			itemsToDrop.Add("item_quad");
			itemQuantity.Add("item_quad", Mathf.CeilToInt(quadTime));
		}
		quadTime = 0;

		if (hasteTime > 0)
		{
			itemsToDrop.Add("item_haste");
			itemQuantity.Add("item_haste", Mathf.CeilToInt(hasteTime));
		}
		hasteTime = 0;

		if (regenTime > 0)
		{
			itemsToDrop.Add("item_regen");
			itemQuantity.Add("item_regen", Mathf.CeilToInt(regenTime));
		}
		regenTime = 0;

		if (invisTime > 0)
		{
			itemsToDrop.Add("item_invis");
			itemQuantity.Add("item_invis", Mathf.CeilToInt(invisTime));
		}
		invisTime = 0;

		if (enviroSuitTime > 0)
		{
			itemsToDrop.Add("item_enviro");
			itemQuantity.Add("item_enviro", Mathf.CeilToInt(enviroSuitTime));
		}
		enviroSuitTime = 0;

		if (flightTime > 0)
		{
			itemsToDrop.Add("item_flight");
			itemQuantity.Add("item_flight", Mathf.CeilToInt(flightTime));
		}
		flightTime = 0;

		switch (playerControls.CurrentWeapon)
		{
			default:
				break;
			case PlayerInfo.MachineGun:
				itemsToDrop.Add("weapon_machinegun");
			break;
			case PlayerInfo.Shotgun:
				itemsToDrop.Add("weapon_shotgun");
			break;
			case PlayerInfo.GrenadeLauncher:
				itemsToDrop.Add("weapon_grenadelauncher");
			break;
			case PlayerInfo.RocketLauncher:
				itemsToDrop.Add("weapon_rocketlauncher");
			break;
			case PlayerInfo.LightningGun:
				itemsToDrop.Add("weapon_lightning");
			break;
			case PlayerInfo.Railgun:
				itemsToDrop.Add("weapon_railgun");
			break;
			case PlayerInfo.PlasmaGun:
				itemsToDrop.Add("weapon_plasmagun");
			break;
			case PlayerInfo.BFG10K:
				itemsToDrop.Add("weapon_bfg");
			break;
			case PlayerInfo.NailGun:
				itemsToDrop.Add("weapon_nailgun");
			break;
			case PlayerInfo.ChainGun:
				itemsToDrop.Add("weapon_chaingun");
			break;
			case PlayerInfo.ProxLauncher:
				itemsToDrop.Add("weapon_prox_launcher");
			break;
			case PlayerInfo.HeavyMachineGun:
				itemsToDrop.Add("weapon_hmg");
			break;
		}

		for (int i = 0; i < itemsToDrop.Count; i++)
		{
			string currentItem = itemsToDrop[i];

			if (dropPowerUps == false)
			{
				if (ThingsManager.uniqueGamePlayThings.Contains(currentItem))
				{
					if (ThingsManager.uniqueThingsOnMap.TryGetValue(currentItem, out ThingController masterThing))
						masterThing.RespawnNow();
				}
				continue;
			}

			RigidBody3D dropItem = (RigidBody3D)ThingsManager.thingsPrefabs[ThingsManager.ItemDrop].Instantiate();
			if (dropItem != null)
			{
				GameManager.Instance.TemporaryObjectsHolder.AddChild(dropItem);
				dropItem.GlobalPosition = ThingsManager.ItemLocationDropToFloor(GlobalPosition + Vector3.Up);
				Vector3 velocity = new Vector3((float)GD.RandRange(-20f, 20f), (float)GD.RandRange(5f, 10f), (float)GD.RandRange(-20f, 20f));
				dropItem.LinearVelocity = velocity;
			}

			ThingController thingObject = (ThingController)ThingsManager.thingsPrefabs[currentItem].Instantiate();
			if (thingObject != null)
			{
				if (dropItem != null)
				{
					thingObject.parent = dropItem;
					dropItem.AddChild(thingObject);
				}
				else
				{
					GameManager.Instance.TemporaryObjectsHolder.AddChild(thingObject);
					thingObject.GlobalPosition = ThingsManager.ItemLocationDropToFloor(GlobalPosition + Vector3.Up);
				}
				thingObject.itemName = currentItem;
				thingObject.SetRespawnTime(-1);
				if (itemQuantity.TryGetValue(currentItem, out int amount))
					thingObject.itemPickup.amount = amount;

				if (ThingsManager.uniqueGamePlayThings.Contains(currentItem))
				{
					thingObject.uniqueItem = true;
					if (itemQuantity.ContainsKey(currentItem))
					{
						if (ThingsManager.uniqueThingsOnMap.TryGetValue(currentItem, out ThingController masterThing))
							thingObject.itemPickup.amount = masterThing.itemPickup.amount;
					}
				}
			}
		}
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		if (!ready)
			return;

		if (Dead)
			return;

		float deltaTime = (float)delta;
		bool newTick = GameManager.NewTickSeconds;

		//Step
		if (stepTime > 0f)
			stepTime -= deltaTime;

		//Pain
		if (painTime > 0f)
		{
			painTime -= deltaTime;
			avatar.currentScale = Vector3.One * Mathf.Lerp(1, avatar.currentScale.X, painTime);
		}
		else if (painTime < 0f)
		{
			painTime = 0;
			avatar.currentScale = Vector3.One;
			avatar.SetPain(false);
		}

		//Last Attacker
		if (lastDamageTime > 0f)
			lastDamageTime -= deltaTime;
		if (lastDamageTime < 0f)
		{
			lastDamageTime = 0;
			lastAttacker = null;
		}
			
		//Quad
		if (quadTime > 0f)
		{
			if (newTick)
			{
				if (quadTime < 4f)
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(wearOffSound));
				playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Quad, Mathf.FloorToInt(quadTime));
			}
			quadTime -= deltaTime;
		}
		else if (quadTime < 0f) 
		{
			quadTime = 0;
			playerInfo.quadDamage = false;
			playerInfo.playerPostProcessing.playerHUD.RemovePowerUp(PlayerHUD.PowerUpType.Quad);
			if (GameManager.Instance.gameConfig.GameType == GameManager.GameType.QuadHog)
			{
				if (ThingsManager.uniqueThingsOnMap.TryGetValue("item_quad", out ThingController masterThing))
					masterThing.RespawnNow();
			}
		}

		//Haste
		if (hasteTime > 0f)
		{
			if (newTick)
			{
				if (hasteTime < 4f)
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(wearOffSound));
				playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Haste, Mathf.FloorToInt(hasteTime));
			}
			hasteTime -= deltaTime;
		}
		else if (hasteTime < 0f)
		{
			hasteTime = 0;
			playerInfo.haste = false;
			playerInfo.playerPostProcessing.playerHUD.RemovePowerUp(PlayerHUD.PowerUpType.Haste);
		}

		//Regen
		if (regenTime > 0f)
		{
			if (newTick)
			{
				if (regenTime < 4f)
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(wearOffSound));
				if (hitpoints < playerInfo.MaxBonusHealth)
				{
					hitpoints += 5;
					if (hitpoints > playerInfo.MaxBonusHealth)
						hitpoints = playerInfo.MaxBonusHealth;
					regenFXTime = 0.5f;
					playerInfo.regenerating = true;
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(regenSound));
				}
				playerInfo.playerPostProcessing.playerHUD.UpdateHealth(hitpoints);
				playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Regen, Mathf.FloorToInt(regenTime));
			}
			regenTime -= deltaTime;
		}
		else if (regenTime < 0f)
		{
			regenTime = 0;
			playerInfo.haste = false;
			playerInfo.playerPostProcessing.playerHUD.RemovePowerUp(PlayerHUD.PowerUpType.Regen);
		}

		if (regenFXTime > 0f)
		{
			regenFXTime -= deltaTime;
		}
		else if(regenFXTime < 0f)
		{
			regenFXTime = 0;
			playerInfo.regenerating = false;
		}

		//Invisibility
		if (invisTime > 0f)
		{
			if (newTick)
			{
				if (invisTime < 4f)
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(wearOffSound));
				playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Invis, Mathf.FloorToInt(invisTime));
			}
			invisTime -= deltaTime;
		}
		else if (invisTime < 0f)
		{
			invisTime = 0;
			playerInfo.invis = false;
			playerInfo.playerPostProcessing.playerHUD.RemovePowerUp(PlayerHUD.PowerUpType.Invis);
		}

		//Battle Suit
		if (enviroSuitTime > 0f)
		{
			if (newTick)
			{
				if (enviroSuitTime < 4f)
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(wearOffSound));
				playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.EnviroSuit, Mathf.FloorToInt(enviroSuitTime));
			}
			enviroSuitTime -= deltaTime;
		}
		else if (enviroSuitTime < 0f)
		{
			enviroSuitTime = 0;
			playerInfo.battleSuit = false;
			playerInfo.playerPostProcessing.playerHUD.RemovePowerUp(PlayerHUD.PowerUpType.EnviroSuit);
		}

		//Flight
		if (flightTime > 0f)
		{
			if (newTick)
			{
				if (flightTime < 4f)
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(wearOffSound));
				playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Flight, Mathf.FloorToInt(flightTime));
			}

			if (playerControls.WhishJump)
			{
				if ((Engine.GetFramesDrawn() % 7) == 0)
				{
					Node3D Puff = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Puff].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(Puff);
					Puff.GlobalPosition = GlobalPosition;
				}
				if (flightSoundTime < 0f)
				{
					flightSoundTime = .75f;
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(flySound));
				}
			}

			flightSoundTime -= deltaTime;
			flightTime -= deltaTime;
		}
		else if (flightTime < 0f)
		{
			flightSoundTime = 0;
			flightTime = 0;
			playerInfo.flight = false;
			playerInfo.playerPostProcessing.playerHUD.RemovePowerUp(PlayerHUD.PowerUpType.Flight);
		}

		if (inDamageable != WaterSurface.DamageableType.None)
		{
			environmentDamageTime -= deltaTime;
			if (environmentDamageTime < 0f)
			{
				if (inDamageable == WaterSurface.DamageableType.Lava)
					Damage(30, DamageType.Environment);
				else
					Damage(14, DamageType.Environment);
				environmentDamageTime = 1;
			}
		}
		//Lava CoolDown
		else if (environmentDamageTime > 0)
		{
			environmentDamageTime -= deltaTime;
			if (environmentDamageTime < 0f)
				environmentDamageTime = 0;
		}

		if (waterLever > 1)
		{
			if (drownTime > 0)
				drownTime -= deltaTime;
			if (drownTime < 0f)
			{
				drownDamage += 2;
				Damage(drownDamage, DamageType.Drown);
				drownTime = 1;
			}

		}
		else if (drownTime != 0)
		{
			drownTime = 0;
			drownDamage = 0;
		}

	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		//skip frames are used to easen up collision detection after respawn
		if (currentState == GameManager.FuncState.Ready)
		{
			if (skipFrames > 0)
			{
				skipFrames--;
				if (skipFrames == 0)
				{
					currentState = GameManager.FuncState.Start;
					skipFrames = 3;
				}
			}
		}
	}

	void OnBodyEntered(Node3D other)
	{
		if (other is Crusher crusher)
			crusher.Crush(this);
	}

}
```

./Assets/Scripts/Player/PlayerModel.cs:
```
using Godot;
using System.IO;
using System.Collections.Generic;
using ExtensionMethods;

public partial class PlayerModel : RigidBody3D, Damageable
{
	public int rotationFPS = 15;
	public int lowerRotationFPS = 7;

	private MD3 head;
	private MD3 upper;
	private MD3 lower;
	private MD3 weapon;

	public int upperAnimation = UpperAnimation.Stand;
	public int lowerAnimation = LowerAnimation.Idle;

	private int airFrames = 0;
	private const int readyToLand = 25;
	private uint currentLayer;
	public bool enableOffset = true;

	public Vector3 currentScale { get { return _currentScale; } set { _currentScale = value; Scale = _currentScale; } }
	private Vector3 _currentScale = Vector3.One;
	public bool isGrounded { get { return _isGrounded; } set { if ((!_isGrounded) && (!value)) { airFrames++; if (airFrames > readyToLand) airFrames = readyToLand; } else airFrames = 0; _isGrounded = value; } }

	private bool _isGrounded = true;
	private List<ModelAnimation> upperAnim = new List<ModelAnimation>();
	private List<ModelAnimation> lowerAnim = new List<ModelAnimation>();

	private Dictionary<string, string> meshToSkin = new Dictionary<string, string>();
	private int upper_tag_torso = 0;
	private int lower_tag_torso = 0;
	private int upper_tag_head = 0;
	private int upper_tag_weapon = 0;

	private MeshProcessed lowerModel;
	private MeshProcessed upperModel;
	private MeshProcessed headModel;
	private MeshProcessed weaponModel;

	private ModelAnimation nextUpper;
	private ModelAnimation nextLower;

	private ModelAnimation currentUpper;
	private ModelAnimation currentLower;

	private int nextFrameUpper;
	private int nextFrameLower;

	private int currentFrameUpper;
	private int currentFrameLower;

	private bool loaded = false;
	private bool ragDoll = false;
	private bool ownerDead = false;
	private bool destroyWeapon = false;
	private bool deadWater = false;
	private bool isMeleeWeapon = false;
	public class ModelAnimation
	{
		public int index;
		public int startFrame;
		public int endFrame;
		public int loopingFrames;
		public int fps;
		public string strName;
		public int nextFrame = 1;
		public ModelAnimation(int index)
		{
			this.index = index;
		}
	}

	public static class UpperAnimation
	{
		public const int Death1 = 0;
		public const int Dead1 = 1;
		public const int Death2 = 2;
		public const int Dead2 = 3;
		public const int Death3 = 4;
		public const int Dead3 = 5;
		public const int Gesture = 6;
		public const int Attack = 7;
		public const int Melee = 8;
		public const int Drop = 9;
		public const int Raise = 10;
		public const int Stand = 11;
		public const int Stand2 = 12;
	}
	public static class LowerAnimation
	{
		public const int Death1 = 0;
		public const int Dead1 = 1;
		public const int Death2 = 2;
		public const int Dead2 = 3;
		public const int Death3 = 4;
		public const int Dead3 = 5;
		public const int WalkCR = 6;
		public const int Walk = 7;
		public const int Run = 8;
		public const int RunBack = 9;
		public const int Swim = 10;
		public const int Jump = 11;
		public const int Land = 12;
		public const int JumpBack = 13;
		public const int LandBack = 14;
		public const int Idle = 15;
		public const int IdleCR = 16;
		public const int Turn = 17;
		public const int WalkCRBack = 18;
		public const int Fall = 19;
		public const int WalkBack = 20;
		public const int FallBack = 21;
	}

	public int currentMoveType = MoveType.Run;
	private int nextMoveType = MoveType.Run;

	public static class MoveType
	{
		public const int Crouch = 0;
		public const int Walk = 1;
		public const int Run = 2;
	}

	private const int TotalAnimation = 29;
	private const string defaultModel = "sarge";
	private const string defaultSkin = "default";

	private Node3D upperBody;
	private Node3D headBody;
	private Node3D barrel;
	private Node3D muzzleFlash;

	private Node3D lowerNode;

	private Node3D playerModel;
	private Node3D tagHeadNode;
	private Node3D weaponNode;

	private float upperLerpTime = 0;
	private float upperCurrentLerpTime = 0;
	private float lowerLerpTime = 0;
	private float lowerCurrentLerpTime = 0;
	private bool createRagdollColliders = false;

	private Quaternion QuaternionZero = new Quaternion(0, 0, 0, 0);
	private Quaternion turnTo = new Quaternion(0, 0, 0, 0);
	private List<MeshInstance3D> modelsMeshes = new List<MeshInstance3D>();
	private List<MeshInstance3D> playerAndWeaponsMeshes = new List<MeshInstance3D>();
	private List<MeshInstance3D> fxMeshes = new List<MeshInstance3D>();
	private int hitpoints;
	private List<MultiMeshData> multiMeshDataList = new List<MultiMeshData>();
	private Dictionary<MeshInstance3D, ShaderMaterial> painMaterial = new Dictionary<MeshInstance3D, ShaderMaterial>();
	private static readonly string gibSound = "player/gibsplt1";

	//Needed to keep impulse once it turn into ragdoll
	private PlayerControls playerControls;
	private float impulseDampening = 4f;
	public int Hitpoints { get { return hitpoints; } }
	public bool Dead { get { return hitpoints <= 0; } }
	public bool Bleed { get { return true; } }
	public BloodType BloodColor { get { return BloodType.Red; } }

	protected OmniLight3D FxLight;

	private bool hasQuad = false;
	private bool isRegenerating = false;
	private bool hasBattleSuit = false;
	private bool isInvisible = false;
	private int currentFx = 0;
	public override void _Ready()
	{
		FxLight = new OmniLight3D();
		FxLight.Visible = false;
		FxLight.LightCullMask = GameManager.AllPlayerViewMask;
		FxLight.Layers = GameManager.AllPlayerViewMask;
		AddChild(FxLight);
		FxLight.Position = Vector3.Up;
		FxLight.LightColor = new Color(0.2f, 0.2f, 1);

		CollisionLayer = (1 << GameManager.RagdollLayer);
		CollisionMask = ((1 << GameManager.ColliderLayer) | (1 << GameManager.InvisibleBlockerLayer));
		Freeze = true;
		Mass = GameManager.Instance.playerMass;
		GravityScale = 2.5f;

		CenterOfMassMode = CenterOfMassModeEnum.Custom;
		CenterOfMass = Vector3.Down * .5f;

		hitpoints = -GameManager.Instance.gibHealth;
	}

	public override void _IntegrateForces(PhysicsDirectBodyState3D state)
	{
		if (!ownerDead)
			return;

		float speed = state.LinearVelocity.LengthSquared();
		if (speed > GameManager.Instance.terminalLimit)
			state.LinearVelocity = state.LinearVelocity.Normalized() * GameManager.Instance.terminalVelocity;

	}

	public override void _PhysicsProcess(double delta)
	{
		if (!ownerDead)
			return;

		if (createRagdollColliders)
		{
			GenerateRagDollCollider();
			createRagdollColliders = false;
		}

	}
	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		if (!loaded)
			return;

		float deltaTime = (float)delta;

		if (ragDoll)
		{
			UpdateMultiMesh();
			return;
		}

		if (turnTo.LengthSquared() > 0)
			playerModel.Quaternion = playerModel.Quaternion.Slerp(turnTo, rotationFPS * deltaTime);

		{
			bool deadUpperReady = false;
			bool deadLowerReady = false;

			nextUpper = upperAnim[upperAnimation];
			nextLower = lowerAnim[lowerAnimation];

			if (nextUpper.index == currentUpper.index)
			{
				nextFrameUpper = currentFrameUpper + 1;
				if (nextFrameUpper >= currentUpper.endFrame)
				{
					switch (nextUpper.index)
					{
						default:
							nextUpper = upperAnim[upperAnimation];
							nextFrameUpper = nextUpper.startFrame;
							break;
						case UpperAnimation.Death1:
						case UpperAnimation.Death2:
						case UpperAnimation.Death3:
								nextFrameUpper = upperAnim[upperAnimation + 1].startFrame;
								deadUpperReady = true;
							break;
						case UpperAnimation.Raise:
						case UpperAnimation.Melee:
						case UpperAnimation.Attack:
							if (isMeleeWeapon)
								upperAnimation = UpperAnimation.Stand2;
							else
								upperAnimation = UpperAnimation.Stand;

							nextUpper = upperAnim[upperAnimation];
							nextFrameUpper = nextUpper.startFrame;
							break;
						case UpperAnimation.Drop:
							nextFrameUpper = currentUpper.endFrame;
							if (destroyWeapon)
								DestroyWeapon();
							break;
					}
				}
			}
			else
				nextFrameUpper = nextUpper.startFrame;

			if (nextLower.index == currentLower.index)
			{
				nextFrameLower = currentFrameLower + currentLower.nextFrame;
				//Need to check if correct end frame depending on start frame
				if (((currentLower.nextFrame > 0)
				 && (nextFrameLower >= currentLower.endFrame)) ||
				 ((currentLower.nextFrame < 0)
				 && (nextFrameLower <= currentLower.endFrame)))
				{
					switch (nextLower.index)
					{
						default:

							break;
						case LowerAnimation.Death1:
						case LowerAnimation.Death2:
						case LowerAnimation.Death3:
							deadLowerReady = true;
							break;
						case LowerAnimation.Jump:
						case LowerAnimation.JumpBack:
							lowerAnimation = LowerAnimation.Idle;
							enableOffset = true;
							break;
						case LowerAnimation.Land:
						case LowerAnimation.LandBack:
							lowerAnimation += 7;
							enableOffset = true;
							break;
						case LowerAnimation.Turn:
						case LowerAnimation.Fall:
						case LowerAnimation.FallBack:
							if (isGrounded)
							{
								if (turnTo.LengthSquared() > 0)
								{
									playerModel.Quaternion = turnTo;
									turnTo = QuaternionZero;
								}
								lowerAnimation = LowerAnimation.Idle;
							}
							break;
					}
					if (deadLowerReady)
						nextFrameLower = lowerAnim[lowerAnimation + 1].startFrame;
					else
					{
						nextLower = lowerAnim[lowerAnimation];
						nextFrameLower = currentLower.startFrame;
					}
				}
			}
			else
				nextFrameLower = nextLower.startFrame;

			if (deadUpperReady && deadLowerReady)
			{
				ChangeToRagDoll();
				return;
			}

			Quaternion upperTorsoRotation = upper.tagsbyId[upper_tag_torso][currentFrameUpper].rotation.Slerp(upper.tagsbyId[upper_tag_torso][nextFrameUpper].rotation, upperCurrentLerpTime).FastNormal();
			Quaternion upperHeadRotation = upper.tagsbyId[upper_tag_head][currentFrameUpper].rotation.Slerp(upper.tagsbyId[upper_tag_head][nextFrameUpper].rotation, upperCurrentLerpTime).FastNormal();
			Quaternion lowerTorsoRotation = lower.tagsbyId[lower_tag_torso][currentFrameLower].rotation.Slerp(lower.tagsbyId[lower_tag_torso][nextFrameLower].rotation, lowerCurrentLerpTime).FastNormal();
			Quaternion weaponRotation = upper.tagsbyId[upper_tag_weapon][currentFrameUpper].rotation.Slerp(upper.tagsbyId[upper_tag_weapon][nextFrameUpper].rotation, upperCurrentLerpTime).FastNormal();

			Vector3 localOrigin = lower.tagsbyId[lower_tag_torso][currentFrameLower].localOrigin.Lerp(lower.tagsbyId[lower_tag_torso][nextFrameLower].localOrigin, lowerCurrentLerpTime);
			Vector3 upperTorsoOrigin = upper.tagsbyId[upper_tag_torso][currentFrameUpper].origin.Lerp(upper.tagsbyId[upper_tag_torso][nextFrameUpper].origin, upperCurrentLerpTime);
			Vector3 upperHeadOrigin = upper.tagsbyId[upper_tag_head][currentFrameUpper].origin.Lerp(upper.tagsbyId[upper_tag_head][nextFrameUpper].origin, upperCurrentLerpTime);
			Vector3 lowerTorsoOrigin = lower.tagsbyId[lower_tag_torso][currentFrameLower].origin.Lerp(lower.tagsbyId[lower_tag_torso][nextFrameLower].origin, lowerCurrentLerpTime);
			Vector3 weaponOrigin = upper.tagsbyId[upper_tag_weapon][currentFrameUpper].origin.Lerp(upper.tagsbyId[upper_tag_weapon][nextFrameUpper].origin, upperCurrentLerpTime);

			{
				Vector3 currentOffset = lowerTorsoRotation * upperTorsoOrigin;
				Quaternion currentRotation = lowerTorsoRotation * upperTorsoRotation;

				for (int i = 0; i < upper.meshes.Count; i++)
				{
					MD3Mesh currentMesh = upper.meshes[i];

					for (int j = 0; j < currentMesh.numVertices; j++)
					{
						Vector3 newVertex = currentRotation * currentMesh.verts[currentFrameUpper][j].Lerp(currentMesh.verts[nextFrameUpper][j], upperCurrentLerpTime);
						newVertex += currentOffset;
						Vector3 newNormal = currentMesh.normals[currentFrameUpper][j].Lerp(currentMesh.normals[nextFrameUpper][j], upperCurrentLerpTime);
						upperModel.data[i].meshDataTool.SetVertex(j, newVertex);
						upperModel.data[i].meshDataTool.SetVertexNormal(j, newNormal);
					}
					upperModel.data[i].arrMesh.ClearSurfaces();
					upperModel.data[i].meshDataTool.CommitToSurface(upperModel.data[i].arrMesh);
				}
				upperBody.Position = lowerTorsoOrigin;

				Quaternion baseRotation = lowerTorsoRotation;
				currentOffset = baseRotation * upperHeadOrigin;
				currentRotation = baseRotation * upperHeadRotation;

				tagHeadNode.Position = currentOffset;
				tagHeadNode.Basis = new Basis(currentRotation);

				currentOffset = baseRotation * weaponOrigin;
				currentRotation = baseRotation * weaponRotation;

				weaponNode.Position = currentOffset;
				weaponNode.Basis = new Basis(currentRotation);

				playerModel.Position = localOrigin;

				currentOffset = upperTorsoRotation * upperTorsoOrigin;
				currentRotation = upperTorsoRotation;

				for (int i = 0; i < lower.meshes.Count; i++)
				{
					MD3Mesh currentMesh = lower.meshes[i];

					for (int j = 0; j < currentMesh.numVertices; j++)
					{
						Vector3 newVertex = currentRotation * currentMesh.verts[currentFrameLower][j].Lerp(currentMesh.verts[nextFrameLower][j], lowerCurrentLerpTime);
						newVertex += currentOffset;
						Vector3 newNormal = currentMesh.normals[currentFrameLower][j].Lerp(currentMesh.normals[nextFrameLower][j], lowerCurrentLerpTime);
						lowerModel.data[i].meshDataTool.SetVertex(j, newVertex);
						lowerModel.data[i].meshDataTool.SetVertexNormal(j, newNormal);

					}
					lowerModel.data[i].arrMesh.ClearSurfaces();
					lowerModel.data[i].meshDataTool.CommitToSurface(lowerModel.data[i].arrMesh);
				}
			}

			upperLerpTime = nextUpper.fps * deltaTime;
			lowerLerpTime = nextLower.fps * deltaTime;

			upperCurrentLerpTime += upperLerpTime;
			lowerCurrentLerpTime += lowerLerpTime;

			if (upperCurrentLerpTime >= 1.0f)
			{
				upperCurrentLerpTime -= 1.0f;
				currentUpper = nextUpper;
				currentFrameUpper = nextFrameUpper;
				//If new weapon check if invisible and apply accordingly
				if (nextFrameUpper == (upperAnim[UpperAnimation.Raise].startFrame + 1))
					if ((currentFx & GameManager.InvisFX) != 0)
						GameManager.ChangeFx(playerAndWeaponsMeshes, GameManager.InvisFX, false, false);
			}

			if (lowerCurrentLerpTime >= 1.0f)
			{
				lowerCurrentLerpTime -= 1.0f;
				currentLower = nextLower;
				currentFrameLower = nextFrameLower;
			}
		}

		if (hasQuad != playerControls.playerInfo.quadDamage)
		{
			hasQuad = playerControls.playerInfo.quadDamage;
			if ((currentFx & GameManager.InvisFX) == 0)
				FxLight.Visible = hasQuad;
			if (hasQuad)
				currentFx |= GameManager.QuadFX;
			else
				currentFx &= ~GameManager.QuadFX;
			GameManager.ChangeFx(fxMeshes, currentFx);
		}

		if (isRegenerating != playerControls.playerInfo.regenerating)
		{
			isRegenerating = playerControls.playerInfo.regenerating;
			if (isRegenerating)
				currentFx |= GameManager.RegenFX;
			else
				currentFx &= ~GameManager.RegenFX;
			GameManager.ChangeFx(fxMeshes, currentFx);
		}

		if (isInvisible != playerControls.playerInfo.invis)
		{
			isInvisible = playerControls.playerInfo.invis;
			if (isInvisible)
			{
				currentFx |= GameManager.InvisFX;
				FxLight.Visible = false;
				GameManager.ChangeFx(playerAndWeaponsMeshes, GameManager.InvisFX, false, false);
			}
			else
			{
				currentFx &= ~GameManager.InvisFX;
				FxLight.Visible = hasQuad;
				GameManager.ChangeFx(playerAndWeaponsMeshes, 0, false, false);
			}
			GameManager.ChangeFx(fxMeshes, currentFx);
		}

		if (hasBattleSuit != playerControls.playerInfo.battleSuit)
		{
			hasBattleSuit = playerControls.playerInfo.battleSuit;
			if (hasBattleSuit)
				currentFx |= GameManager.BattleSuitFX;
			else
				currentFx &= ~GameManager.BattleSuitFX;
			GameManager.ChangeFx(fxMeshes, currentFx);
		}
	}

	public void ForceChangeView(Quaternion dir)
	{
		if (ownerDead)
			return;

		playerModel.Quaternion = dir;
		headBody.Quaternion = Quaternion.Identity;
		upperBody.Quaternion = Quaternion.Identity;
		turnTo = QuaternionZero;
	}

	public void ChangeView(Vector2 viewDirection, float deltaTime)
	{
		if (ownerDead)
			return;

		//In order to keep proper animation and not offset it by looking at target, otherwise head could go Exorcist-like
		if (!enableOffset)
			return;

		float vView = -viewDirection.X;
		float hView = viewDirection.Y - Mathf.RadToDeg(playerModel.Quaternion.GetEuler().Y);

		headBody.Quaternion = headBody.Quaternion.Slerp(Quaternion.FromEuler(new Vector3(0, Mathf.DegToRad(hView), Mathf.DegToRad(Mathf.Clamp(vView, -50f, 30f)))), rotationFPS * deltaTime);
		int vAngle = (int)Mathf.Round((vView) / (360) * 32) % 32;
		int hAngle = (int)Mathf.Round((hView) / (360) * 32) % 32;

		upperBody.Quaternion = upperBody.Quaternion.Slerp(Quaternion.FromEuler(new Vector3(0, Mathf.DegToRad(11.25f * hAngle), Mathf.DegToRad(7.5f * vAngle))), rotationFPS * deltaTime);

	}

	public void CheckLegTurn(Vector3 direction)
	{
		if (ownerDead)
			return;

		Vector3 forward = playerModel.ForwardVector();
		int angle = (int)Mathf.Round((Mathf.Atan2(direction.X, direction.Z)) / (Mathf.Pi * 2) * 8) % 8;
		Quaternion dir = Quaternion.FromEuler(new Vector3(0f, Mathf.DegToRad(angle * 45f), 0f));

		angle = (int)Mathf.Round(((Mathf.Atan2((forward.Z * direction.X) - (direction.Z * forward.X), (forward.X * direction.X) + (forward.Z * direction.Z)))) / (Mathf.Pi * 2) * 8) % 8;
		if (angle != 0)
		{
			turnTo = dir;
			if ((lowerAnimation == LowerAnimation.Idle) && (isGrounded))
				lowerAnimation = LowerAnimation.Turn;
		}
	}
	public void Attack()
	{
		if (ownerDead)
			return;
		if (isMeleeWeapon)
			upperAnimation = UpperAnimation.Melee;
		else
			upperAnimation = UpperAnimation.Attack;
	}

	private void GenerateRagDollCollider()
	{
		CollisionShape3D collisionShape = new CollisionShape3D();

		int currentDeathUpper = upperAnim[upperAnimation + 1].startFrame;
		int currentDeathLower = lowerAnim[lowerAnimation + 1].startFrame;

		Quaternion upperTorsoRotation = upper.tagsbyId[upper_tag_torso][currentDeathUpper].rotation;
		Quaternion upperHeadRotation = upper.tagsbyId[upper_tag_head][currentDeathUpper].rotation;
		Quaternion lowerTorsoRotation = lower.tagsbyId[lower_tag_torso][currentDeathLower].rotation;

		Vector3 localOrigin = lower.tagsbyId[lower_tag_torso][currentDeathLower].localOrigin;
		Vector3 upperTorsoOrigin = upper.tagsbyId[upper_tag_torso][currentDeathUpper].origin;
		Vector3 upperHeadOrigin = upper.tagsbyId[upper_tag_head][currentDeathUpper].origin;
		Vector3 lowerTorsoOrigin = lower.tagsbyId[lower_tag_torso][currentDeathLower].origin;

		collisionShape.Quaternion = playerModel.Quaternion;
		collisionShape.Position = localOrigin;

		ConvexPolygonShape3D modelColliderShape = new ConvexPolygonShape3D();
		List<Vector3> modelPoints = new List<Vector3>();
		{
			Vector3 currentOffset = lowerTorsoRotation * upperTorsoOrigin;
			Quaternion currentRotation = lowerTorsoRotation * upperTorsoRotation;

			for (int i = 0; i < upper.meshes.Count; i++)
			{
				MD3Mesh currentMesh = upper.meshes[i];
				List<Vector3> verts = new List<Vector3>();
				for (int j = 0; j < currentMesh.numVertices; j++)
				{
					Vector3 newVertex = currentRotation * currentMesh.verts[currentDeathUpper][j];
					newVertex += currentOffset + lowerTorsoOrigin;
					verts.Add(newVertex);
				}
				modelPoints.AddRange(verts);
			}

			Quaternion baseRotation = lowerTorsoRotation;
			currentOffset = baseRotation * upperHeadOrigin;
			currentRotation = baseRotation * upperHeadRotation;

			for (int i = 0; i < head.meshes.Count; i++)
			{

				Vector3[] faces = headModel.data[i].arrMesh.GetFaces();
				Quaternion rotation = currentRotation;
				for (int j = 0; j < faces.Length; j++)
				{
					faces[j] = rotation * faces[j];
					faces[j] += currentOffset + lowerTorsoOrigin;
				}
				modelPoints.AddRange(faces);
			}

			currentOffset = upperTorsoRotation * upperTorsoOrigin;
			currentRotation = upperTorsoRotation;

			for (int i = 0; i < lower.meshes.Count; i++)
			{
				MD3Mesh currentMesh = lower.meshes[i];
				List<Vector3> verts = new List<Vector3>();
				for (int j = 0; j < currentMesh.numVertices; j++)
				{
					Vector3 newVertex = currentRotation * currentMesh.verts[currentDeathLower][j];
					newVertex += currentOffset;
					verts.Add(newVertex);
				}
				modelPoints.AddRange(verts);
			}
		}
		modelColliderShape.Points = modelPoints.ToArray();
		collisionShape.Shape = modelColliderShape;
		//JOLT require Node to be added after all the shapes have been adeed:
		AddChild(collisionShape);

		playerControls.playerThing.CollisionLayer = (1 << GameManager.PhysicCollisionLayer);
		if (playerControls.playerThing.waterLever > 0)
			deadWater = true;

		if (turnTo.LengthSquared() > 0)
		{
			playerModel.Quaternion = turnTo;
			turnTo = QuaternionZero;
		}

		Reparent(GameManager.Instance.TemporaryObjectsHolder);
		Freeze = false;
		LinearVelocity = playerControls.impulseVector * .8f;
		SetPhysicsProcess(false);

	}

	private void ChangeToRagDoll()
	{
		int currentDeathUpper = nextFrameUpper;
		int currentDeathLower = nextFrameLower;

		Quaternion upperTorsoRotation = upper.tagsbyId[upper_tag_torso][currentDeathUpper].rotation;
		Quaternion upperHeadRotation = upper.tagsbyId[upper_tag_head][currentDeathUpper].rotation;
		Quaternion lowerTorsoRotation = lower.tagsbyId[lower_tag_torso][currentDeathLower].rotation;

		Vector3 localOrigin = lower.tagsbyId[lower_tag_torso][currentDeathLower].localOrigin;
		Vector3 upperTorsoOrigin = upper.tagsbyId[upper_tag_torso][currentDeathUpper].origin;
		Vector3 upperHeadOrigin = upper.tagsbyId[upper_tag_head][currentDeathUpper].origin;
		Vector3 lowerTorsoOrigin = lower.tagsbyId[lower_tag_torso][currentDeathLower].origin;

		Vector3 currentOffset = lowerTorsoRotation * upperTorsoOrigin;
		Quaternion currentRotation = lowerTorsoRotation * upperTorsoRotation;

		upperBody.QueueFree();
		MeshProcessed upperRagDoll = Mesher.GenerateModelFromMeshes(upper, meshToSkin, GameManager.AllPlayerViewMask, true, currentDeathUpper);
		upperRagDoll.node.Name = "upper_body";
		playerModel.AddChild(upperRagDoll.node);
		upperRagDoll.node.Quaternion = currentRotation;
		upperRagDoll.node.Position = currentOffset + lowerTorsoOrigin;
		SetMultiMesh(upperRagDoll, upperRagDoll.node);

		Quaternion baseRotation = lowerTorsoRotation;
		currentOffset = baseRotation * upperHeadOrigin;
		currentRotation = baseRotation * upperHeadRotation;

		MeshProcessed headRagDoll = Mesher.GenerateModelFromMeshes(head, meshToSkin, GameManager.AllPlayerViewMask, true);
		headRagDoll.node.Name = "head";
		playerModel.AddChild(headRagDoll.node);
		headRagDoll.node.Position = currentOffset + lowerTorsoOrigin;
		headRagDoll.node.Basis = new Basis(currentRotation);
		SetMultiMesh(headRagDoll, headRagDoll.node);

		currentOffset = upperTorsoRotation * upperTorsoOrigin;
		lowerModel.node.QueueFree();

		MeshProcessed lowerRagDoll = Mesher.GenerateModelFromMeshes(lower, meshToSkin, GameManager.AllPlayerViewMask, true, currentDeathLower);
		lowerRagDoll.node.Name = "lower_body";
		lowerNode = lowerRagDoll.node;
		lowerNode.Position = localOrigin + currentOffset;
		playerModel.AddChild(lowerRagDoll.node);
		SetMultiMesh(lowerRagDoll, lowerRagDoll.node);

		playerControls.playerThing.avatar = null;
		playerControls.playerThing.interpolatedTransform.QueueFree();
		playerControls.playerThing.interpolatedTransform = null;
		Sleeping = false;
		ragDoll = true;
	}

	public void Die()
	{
		//Need to reset the torso and head view
		headBody.Basis = new Basis(Quaternion.Identity);
		upperBody.Basis = new Basis(Quaternion.Identity);
		lowerNode.Basis = new Basis(Quaternion.Identity);
		int deathNum = 2 * GD.RandRange(0, 2);
		upperAnimation = deathNum;
		lowerAnimation = deathNum;

		currentFx = 0;
		FxLight.Visible = false;
		GameManager.ChangeFx(fxMeshes, currentFx);

		ownerDead = true;
		createRagdollColliders = true;
	}

	public void Gib(bool throwBodyParts = true)
	{
		int init = GD.RandRange(0, 1);
		SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(gibSound));

		if (throwBodyParts)
		{
			for (; init < ThingsManager.gibsParts.Length; init++)
			{
				RigidBody3D gipPart = (RigidBody3D)ThingsManager.thingsPrefabs[ThingsManager.gibsParts[init]].Instantiate();
				if (gipPart != null)
				{
					GameManager.Instance.TemporaryObjectsHolder.AddChild(gipPart);
					gipPart.GlobalPosition = GlobalPosition;
					Vector3 velocity = new Vector3((float)GD.RandRange(-20f, 20f), (float)GD.RandRange(5f, 10f), (float)GD.RandRange(-20f, 20f));
					gipPart.LinearVelocity = velocity;
					gipPart.AngularVelocity = velocity;
				}
				//Never throw brains and skull
				if (init == 0)
					init++;
			}
		}

		SetProcess(false);
		SetPhysicsProcess(false);
		if (ragDoll)
			QueueFree();
		else
		{
			currentFx = 0;
			FxLight.Visible = false;
			GameManager.ChangeFx(fxMeshes, currentFx);
			playerControls.playerThing.avatar = null;
			playerControls.playerThing.interpolatedTransform.QueueFree();
			playerControls.playerThing.interpolatedTransform = null;
		}
	}

	public void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null)
	{
		if (!ragDoll)
			return;

		//Already Gibbed
		if (hitpoints <= 0)
			return;

		hitpoints -= amount;

		//Cap Negative Damage
		if (hitpoints < -99)
			hitpoints = -99;

		if (hitpoints <= 0)
			Gib();
	}
	public void Impulse(Vector3 direction, float force)
	{

	}
	public void TurnLegsOnJump(float sideMove, float deltaTime)
	{
		Quaternion rotate = Quaternion.Identity;

		if (airFrames < readyToLand)
			return;

		if (sideMove > 0)
			rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(-30f));
		else if (sideMove < 0)
			rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(30f));

		lowerNode.Quaternion = lowerNode.Quaternion.Slerp(rotate, lowerRotationFPS * deltaTime);
	}

	public void Swim()
	{
		lowerNode.Quaternion = Quaternion.Identity;
		lowerAnimation = LowerAnimation.Swim;
	}

	public void TurnLegs(int moveType, float sideMove, float forwardMove, float deltaTime)
	{
		if (ownerDead)
			return;

		nextMoveType = moveType;

		Quaternion rotate = Quaternion.Identity;
		Quaternion rollRotate = Quaternion.Identity;
		if (forwardMove < 0)
		{
			switch (nextMoveType)
			{
				default:
				case MoveType.Run:
					lowerAnimation = LowerAnimation.Run;
					break;
				case MoveType.Walk:
					lowerAnimation = LowerAnimation.Walk;
					break;
				case MoveType.Crouch:
					lowerAnimation = LowerAnimation.WalkCR;
					break;
			}
			if (sideMove > 0)
			{
				rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(-30f));
				rollRotate = new Quaternion(playerModel.RightVector(), Mathf.DegToRad(-5f));
			}
			else if (sideMove < 0)
			{
				rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(30f));
				rollRotate = new Quaternion(playerModel.RightVector(), Mathf.DegToRad(5f));
			}
		}
		else if (forwardMove > 0)
		{
			switch (nextMoveType)
			{
				default:
				case MoveType.Run:
					lowerAnimation = LowerAnimation.RunBack;
					break;
				case MoveType.Walk:
					lowerAnimation = LowerAnimation.WalkBack;
					break;
				case MoveType.Crouch:
					lowerAnimation = LowerAnimation.WalkCRBack;
					break;
			}
			if (sideMove > 0)
			{
				rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(30f));
				rollRotate = new Quaternion(playerModel.RightVector(), Mathf.DegToRad(5f));
			}
			else if (sideMove < 0)
			{
				rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(-30f));
				rollRotate = new Quaternion(playerModel.RightVector(), Mathf.DegToRad(-5f));
			}
		}
		else if (sideMove != 0)
		{
			switch (nextMoveType)
			{
				default:
				case MoveType.Run:
					lowerAnimation = LowerAnimation.Run;
					break;
				case MoveType.Walk:
					lowerAnimation = LowerAnimation.Walk;
					break;
				case MoveType.Crouch:
					lowerAnimation = LowerAnimation.WalkCR;
					break;
			}
			if (sideMove > 0)
			{
				rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(-50f));
				rollRotate = new Quaternion(playerModel.RightVector(), Mathf.DegToRad(-10f));
			}
			else if (sideMove < 0)
			{
				rotate = new Quaternion(playerModel.UpVector(), Mathf.DegToRad(50f));
				rollRotate = new Quaternion(playerModel.RightVector(), Mathf.DegToRad(10f));
			}
		}
		else if ((lowerAnimation != LowerAnimation.Turn) && (lowerAnimation != LowerAnimation.Land) && (lowerAnimation != LowerAnimation.LandBack))
		{
			if (nextMoveType == MoveType.Crouch)
				lowerAnimation = LowerAnimation.IdleCR;
			else
				lowerAnimation = LowerAnimation.Idle;
		}
		lowerNode.Quaternion = lowerNode.Quaternion.Slerp(rotate, lowerRotationFPS * deltaTime);
		Quaternion = Quaternion.Slerp(rollRotate, lowerRotationFPS * deltaTime);
	}
	public void MuzzleFlashSetScale(Vector3 scale)
	{
		if (muzzleFlash == null)
			return;

		muzzleFlash.Scale = scale;
	}
	public void MuzzleFlashSetActive(bool active)
	{
		if (muzzleFlash == null)
			return;

		muzzleFlash.Visible = active;
	}

	public void RotateBarrel(Quaternion rotation, float speed)
	{
		if (barrel == null)
			return;
		barrel.Quaternion = barrel.Quaternion.Slerp(rotation, speed);
	}

	public void LoadWeapon(ModelController[] newWeaponList, bool isMelee, Node3D barrelObject, Node3D muzzleObject)
	{
		if (ownerDead)
			return;

		if (destroyWeapon)
			DestroyWeapon();

		Node3D barrelTag = null;

		weapon = newWeaponList[0].Model;
		weaponModel = Mesher.GenerateModelFromMeshes(weapon, currentLayer, true, true, null, false, false);
		weaponModel.node.Name = "weapon";
		weaponNode.AddChild(weaponModel.node);
		AddAllMeshInstance3D(weaponNode);

		for (int i = 1; i < newWeaponList.Length; i++)
		{
			Node3D weaponPart = new Node3D();
			weaponPart.Name = "Weapon_Part_" + i;

			Mesher.GenerateModelFromMeshes(newWeaponList[i].Model, currentLayer, true, true, weaponPart, false, false);
			//Ugly Hack but Gauntlet rotation is all messed up
			if (isMelee)
			{
				if (i == 1)
				{
					barrelTag = new Node3D();
					barrelTag.Name = "Barrel_Tag";
					if (newWeaponList[0].Model.tagsIdbyName.TryGetValue("tag_barrel", out int tagId))
					{
						barrelTag.Position = newWeaponList[0].Model.tagsbyId[tagId][0].origin;
						barrelTag.Quaternion = newWeaponList[0].Model.tagsbyId[tagId][0].rotation;
					}
					weaponModel.node.AddChild(barrelTag);
					barrelTag.AddChild(weaponPart);
				}
				else if (i == 2)
				{
					weaponPart.Position += barrelTag.Position;
					weaponPart.Quaternion *= Quaternion.FromEuler(Vector3.Up * Mathf.Pi);
				}
			}
			else
				weaponModel.node.AddChild(weaponPart);
			weaponPart.Position = newWeaponList[i].Position;
			weaponPart.Quaternion = newWeaponList[i].Quaternion;
			if (newWeaponList[i] == barrelObject)
			{
				barrel = weaponPart;
				AddAllMeshInstance3D(weaponPart);
			}
			else if (newWeaponList[i] == muzzleObject)
			{
				if ((barrel != null) && (!isMelee))
					weaponPart.Reparent(barrel, false);
				muzzleFlash = weaponPart;
				muzzleFlash.Visible = false;
				AddAllMeshInstance3D(weaponPart, false, false);
			}
			else
				AddAllMeshInstance3D(weaponPart);
		}

		isMeleeWeapon = isMelee;
		upperAnimation = UpperAnimation.Raise;

		if (currentFx != 0)
			GameManager.ChangeFx(fxMeshes, currentFx);
	}

	public void UnloadWeapon()
	{
		if (weapon == null)
			return;

		if (ownerDead)
		{
			if (weaponModel != null)
				if (weaponModel.node != null)
				{
					RemoveAllMeshInstance3D(weaponNode);
					weaponModel.node.QueueFree();
					weaponModel.node = null;
				}

			weapon = null;
			barrel = null;
			muzzleFlash = null;
			return;
		}
		destroyWeapon = true;
		upperAnimation = UpperAnimation.Drop;
	}
	public void AddLightningBolt(Node3D lightningBolt)
	{
		lightningBolt.Hide();
		weaponModel.node.AddChild(lightningBolt);
		lightningBolt.Position = muzzleFlash.Position;
		AddAllMeshInstance3D(lightningBolt, false, false);
		ChangeLayer(currentLayer);
	}

	public List<MeshInstance3D> GetWeaponModulateMeshes(bool fromMuzzle = false)
	{
		Node parent = weaponModel.node;
		if (fromMuzzle)
			parent = muzzleFlash;
		return GameManager.GetModulateMeshes(parent, fxMeshes);
	}

	public void DestroyWeapon()
	{
		if (weapon == null)
			return;

		if (weaponModel != null)
			if (weaponModel.node != null)
			{
				RemoveAllMeshInstance3D(weaponNode);
				weaponModel.node.QueueFree();
				weaponModel.node = null;
			}

		weapon = null;
		barrel = null;
		muzzleFlash = null;
		destroyWeapon = false;
	}

	public bool LoadPlayer(ref string modelName, ref string SkinName, uint layer, PlayerControls control)
	{
		playerControls = control;

		string playerModelPath = "players/" + modelName;
		string lowerModelName = playerModelPath + "/lower";

		lower = ModelsManager.GetModel(lowerModelName);
		if (lower == null)
		{
			modelName = defaultModel;
			playerModelPath = "players/" + modelName;
			lowerModelName = playerModelPath + "/lower";
			lower = ModelsManager.GetModel(lowerModelName);
			if (lower == null)
				return false;
		}

		string upperModelName = playerModelPath + "/upper";
		string headModelName = playerModelPath + "/head";
		string animationFile = playerModelPath + "/animation";

		upper = ModelsManager.GetModel(upperModelName);
		if (upper == null)
			return false;

		head = ModelsManager.GetModel(headModelName);
		if (head == null)
			return false;

		string lowerSkin = playerModelPath + "/lower_" + SkinName;

		if (!LoadSkin(lower, lowerSkin))
		{
			SkinName = defaultSkin;
			lowerSkin = playerModelPath + "/lower_" + SkinName;
			if (!LoadSkin(lower, lowerSkin))
				return false;
		}

		string upperSkin = playerModelPath + "/upper_" + SkinName;
		string headSkin = playerModelPath + "/head_" + SkinName;

		if (!LoadSkin(upper, upperSkin))
			return false;
		if (!LoadSkin(head, headSkin))
			return false;

		upper_tag_torso = upper.tagsIdbyName["tag_torso"];
		lower_tag_torso = lower.tagsIdbyName["tag_torso"];
		upper_tag_head = upper.tagsIdbyName["tag_head"];
		upper_tag_weapon = upper.tagsIdbyName["tag_weapon"];

		LoadAnimations(animationFile, upperAnim, lowerAnim);
		currentUpper = upperAnim[UpperAnimation.Stand];
		currentFrameUpper = currentUpper.startFrame;
		currentLower = lowerAnim[LowerAnimation.Idle];
		currentFrameLower = currentLower.startFrame;

		{
			playerModel = new Node3D();
			AddChild(playerModel);
			playerModel.Name = modelName;

			upperBody = new Node3D();
			upperBody.Name = "Upper Body";
			playerModel.AddChild(upperBody);

			tagHeadNode = new Node3D();
			tagHeadNode.Name = "tag_head";
			upperBody.AddChild(tagHeadNode);

			weaponNode = new Node3D();
			weaponNode.Name = "tag_weapon";
			upperBody.AddChild(weaponNode);

			headBody = new Node3D();
			headBody.Name = "Head";
			tagHeadNode.AddChild(headBody);

			upperModel = Mesher.GenerateModelFromMeshes(upper, meshToSkin, layer);
			upperModel.node.Name = "upper_body";
			upperBody.AddChild(upperModel.node);

			headModel = Mesher.GenerateModelFromMeshes(head, meshToSkin, layer);
			headModel.node.Name = "head";
			headBody.AddChild(headModel.node);

			lowerModel = Mesher.GenerateModelFromMeshes(lower, meshToSkin, layer);
			lowerModel.node.Name = "lower_body";
			lowerNode = lowerModel.node;
			playerModel.AddChild(lowerModel.node);

			loaded = true;
		}
		currentLayer = layer;

		AddAllMeshInstance3D(playerModel);
		AddPainMaterial();
		playerControls.playerInfo.playerPostProcessing.playerHUD.InitHUD(head, meshToSkin);
		return true;
	}

	public void AddPainMaterial()
	{
		foreach (MeshInstance3D mesh in modelsMeshes)
		{
			ShaderMaterial material = (ShaderMaterial)MaterialManager.Instance.painModelMaterial.Duplicate(true);
			painMaterial.Add(mesh,material);
		}
	}

	public void SetPain(bool enable, float duration = 0)
	{
		foreach (var painMat in painMaterial)
		{
			if (enable)
			{
				painMat.Value.SetShaderParameter("pain_duration", .25f);
				painMat.Value.SetShaderParameter("pain_start_time", GameManager.CurrentTimeMsec);
				painMat.Key.MaterialOverlay = painMat.Value;
			}
			else
				painMat.Key.MaterialOverlay = null;
		}
	}

	public void ChangeLayer(uint layer)
	{
		for (int i = 0; i < modelsMeshes.Count; i++)
			modelsMeshes[i].Layers = layer;
		for (int i = 0; i < fxMeshes.Count; i++)
			fxMeshes[i].Layers = layer;
		currentLayer = layer;
	}

	private void AddAllMeshInstance3D(Node parent, bool addFx = true, bool isPlayerOrWeapon = true)
	{
		List<MeshInstance3D> Childrens = GameManager.GetAllChildrensByType<MeshInstance3D>(parent);
		foreach (MeshInstance3D mesh in Childrens)
		{
			if (modelsMeshes.Contains(mesh))
				continue;

			//Check if UI Self Shadow
			if (mesh.CastShadow == GeometryInstance3D.ShadowCastingSetting.ShadowsOnly)
				continue;

			if (fxMeshes.Contains(mesh))
				continue;

			modelsMeshes.Add(mesh);

			if (isPlayerOrWeapon && (!playerAndWeaponsMeshes.Contains(mesh)))
				playerAndWeaponsMeshes.Add(mesh);

			//UI Self Shadow
			MeshInstance3D shadowMesh = new MeshInstance3D();
			shadowMesh.Mesh = mesh.Mesh;
			shadowMesh.CastShadow = GeometryInstance3D.ShadowCastingSetting.ShadowsOnly;
			shadowMesh.Layers = playerControls.playerInfo.uiLayer;
			mesh.AddChild(shadowMesh);

			if (!addFx)
				continue;

			//FX Mesh
			MeshInstance3D fxMesh = new MeshInstance3D();
			fxMesh.Mesh = mesh.Mesh;
			fxMesh.Layers = currentLayer;
			fxMesh.Visible = false;
			mesh.AddChild(fxMesh);
			fxMeshes.Add(fxMesh);
		}
	}
	private void RemoveAllMeshInstance3D(Node parent)
	{
		List<MeshInstance3D> Childrens = GameManager.GetAllChildrensByType<MeshInstance3D>(parent);
		foreach (MeshInstance3D mesh in Childrens)
		{
			if (fxMeshes.Contains(mesh))
				fxMeshes.Remove(mesh);
			if (modelsMeshes.Contains(mesh))
				modelsMeshes.Remove(mesh);
			if (playerAndWeaponsMeshes.Contains(mesh))
				playerAndWeaponsMeshes.Remove(mesh);
		}
	}

	private bool LoadAnimations(string file, List<ModelAnimation> upper, List<ModelAnimation> lower)
	{
		StreamReader animFile;
		string FileName;

		ModelsManager.ModelAnimationData animationData = ModelsManager.GetAnimationData(file);
		if (animationData != null)
		{
			upper.AddRange(animationData.Upper);
			lower.AddRange(animationData.Lower);
			playerControls.footStep = animationData.FootSteps;
			return true;
		}

		string path = Directory.GetCurrentDirectory() + "/StreamingAssets/models/" + file + ".cfg";
		if (File.Exists(path))
			animFile = new StreamReader(File.Open(path, FileMode.Open));
		else if (PakManager.ZipFiles.TryGetValue(path = ("models/" + file + ".cfg").ToUpper(), out FileName))
		{
			MemoryStream ms = new MemoryStream(PakManager.GetPK3FileData(path, FileName));
			animFile = new StreamReader(ms);
		}
		else
		{
			GameManager.Print("Unable to load animation file: " + file, GameManager.PrintType.Warning);
			return false;
		}

		animFile.BaseStream.Seek(0, SeekOrigin.Begin);
		ModelAnimation[] animations = new ModelAnimation[TotalAnimation];

		if (animFile.EndOfStream)
		{
			return false;
		}

		string strWord;
		int currentAnim = 0;
		int torsoOffset = 0;
		int legsOffset = LowerAnimation.WalkCR + 1;
		char[] separators = new char[2] { '\t', '(' };
		while ((!animFile.EndOfStream) && (currentAnim < 25))
		{
			strWord = animFile.ReadLine();

			if (strWord.Length == 0)
				continue;

			if (!char.IsDigit(strWord[0]))
			{
				if (strWord[0] != 'f')
					continue;

				strWord = strWord.Trim();
				strWord = strWord.Replace('\t', ' ');
				string[] type = strWord.Split(' ');
				strWord = type[type.Length - 1].Trim();
				switch (strWord[0])
				{
					default:
						playerControls.footStep = PlayerThing.FootStepType.Normal;
					break;
					case 'b':
						playerControls.footStep = PlayerThing.FootStepType.Boot;
					break;
					case 'm':
						playerControls.footStep = PlayerThing.FootStepType.Mech;
					break;
					case 'f':
						playerControls.footStep = PlayerThing.FootStepType.Flesh;
					break;
					case 'e':
						playerControls.footStep = PlayerThing.FootStepType.Energy;
					break;
				}
				continue;
			}

			string[] values = new string[4] { "", "", "", "" };
			bool lastDigit = true;
			for (int i = 0, j = 0; i < strWord.Length; i++)
			{
				if (char.IsDigit(strWord[i]))
				{
					if (lastDigit)
						values[j] += strWord[i];
					else
					{
						j++;
						values[j] += strWord[i];
						lastDigit = true;
					}
				}
				else
					lastDigit = false;

				if ((j == 3) && (!lastDigit))
					break;
			}

			int startFrame = int.Parse(values[0]);
			int numOfFrames = int.Parse(values[1]);
			int loopingFrames = int.Parse(values[2]);
			int fps = int.Parse(values[3]);

			animations[currentAnim] = new ModelAnimation(currentAnim);
			animations[currentAnim].startFrame = startFrame;
			animations[currentAnim].endFrame = startFrame + numOfFrames;
			animations[currentAnim].loopingFrames = loopingFrames;
			animations[currentAnim].fps = fps;

			string[] name = strWord.Split('/');
			strWord = name[name.Length - 1].Trim();
			name = strWord.Split(separators);
			animations[currentAnim].strName = name[0];

			if (animations[currentAnim].strName.Contains("BOTH"))
			{
				upper.Add(animations[currentAnim]);
				lower.Add(animations[currentAnim]);
			}
			else if (animations[currentAnim].strName.Contains("TORSO"))
			{
				upper.Add(animations[currentAnim]);
			}
			else if (animations[currentAnim].strName.Contains("LEGS"))
			{
				if (torsoOffset == 0)
					torsoOffset = animations[UpperAnimation.Stand2 + 1].startFrame - animations[LowerAnimation.WalkCR].startFrame;

				animations[currentAnim].startFrame -= torsoOffset;
				animations[currentAnim].endFrame -= torsoOffset;
				animations[currentAnim].index -= legsOffset;
				lower.Add(animations[currentAnim]);
			}
			currentAnim++;
		}

		//Set currentAnim back
		currentAnim = 24;

		//Add Walk Crounched Back 
		animations[currentAnim] = new ModelAnimation(LowerAnimation.WalkCRBack);
		animations[currentAnim].startFrame = lowerAnim[LowerAnimation.WalkCR].endFrame - 1;
		animations[currentAnim].endFrame = lowerAnim[LowerAnimation.WalkCR].startFrame - 1;
		animations[currentAnim].loopingFrames = lowerAnim[LowerAnimation.WalkCR].loopingFrames;
		animations[currentAnim].fps = lowerAnim[LowerAnimation.WalkCR].fps;
		animations[currentAnim].nextFrame = -1;
		lower.Add(animations[currentAnim++]);

		//Add Fall
		animations[currentAnim] = new ModelAnimation(LowerAnimation.Fall);
		animations[currentAnim].startFrame = lowerAnim[LowerAnimation.Land].endFrame - 1;
		animations[currentAnim].endFrame = lowerAnim[LowerAnimation.Land].endFrame;
		animations[currentAnim].loopingFrames = 0;
		animations[currentAnim].fps = lowerAnim[LowerAnimation.Land].fps;
		lower.Add(animations[currentAnim++]);

		//Add Walk Back
		animations[currentAnim] = new ModelAnimation(LowerAnimation.WalkBack);
		animations[currentAnim].startFrame = lowerAnim[LowerAnimation.Walk].endFrame - 1;
		animations[currentAnim].endFrame = lowerAnim[LowerAnimation.Walk].startFrame - 1;
		animations[currentAnim].loopingFrames = lowerAnim[LowerAnimation.Walk].loopingFrames;
		animations[currentAnim].fps = lowerAnim[LowerAnimation.Walk].fps;
		animations[currentAnim].nextFrame = -1;
		lower.Add(animations[currentAnim++]);

		//Add Fall Back
		animations[currentAnim] = new ModelAnimation(LowerAnimation.FallBack);
		animations[currentAnim].startFrame = lowerAnim[LowerAnimation.LandBack].endFrame - 1;
		animations[currentAnim].endFrame = lowerAnim[LowerAnimation.LandBack].endFrame;
		animations[currentAnim].loopingFrames = 0;
		animations[currentAnim].fps = lowerAnim[LowerAnimation.LandBack].fps;
		lower.Add(animations[currentAnim]);

		animFile.Close();

		ModelsManager.AddAnimationData(file, upper, lower, playerControls.footStep);
		return true;
	}
	public bool LoadSkin(MD3 model, string skinName)
	{
		StreamReader SkinFile;
		string FileName;

		Dictionary<string, string> MeshToSkin = ModelsManager.GetSkinData(skinName);
		if (MeshToSkin != null)
		{
			foreach (var value in MeshToSkin)
			{
				if (!meshToSkin.ContainsKey(value.Key))
					meshToSkin.Add(value.Key, value.Value);
			}
			return true;
		}

		MeshToSkin = new Dictionary<string, string>();
		string path = Directory.GetCurrentDirectory() + "/StreamingAssets/models/" + skinName + ".skin";
		if (File.Exists(path))
			SkinFile = new StreamReader(File.Open(path, FileMode.Open));
		else if (PakManager.ZipFiles.TryGetValue(path = ("models/" + skinName + ".skin").ToUpper(), out FileName))
		{
			MemoryStream ms = new MemoryStream(PakManager.GetPK3FileData(path, FileName));
			SkinFile = new StreamReader(ms);
		}
		else
		{
			GameManager.Print("Unable to load skin for model: " + model.name, GameManager.PrintType.Warning);
			return false;
		}

		SkinFile.BaseStream.Seek(0, SeekOrigin.Begin);

		if (SkinFile.EndOfStream)
		{
			GameManager.Print("Unable to load skin for model: " + model.name, GameManager.PrintType.Warning);
			return false;
		}

		string strLine;
		int textureNameStart = 0;

		while (!SkinFile.EndOfStream)
		{
			strLine = SkinFile.ReadLine().ToUpper();

			for (int i = 0; i < model.meshes.Count; i++)
			{
				if (strLine.Contains(model.meshes[i].name))
				{
					for (int j = strLine.Length - 1; j > 0; j--)
					{
						if (strLine[j] == ',')
						{
							textureNameStart = j + 1;
							break;
						}
					}
					string skin = strLine.Substring(textureNameStart);
					string[] fullName = skin.Split('.');

					//Check if skin texture exist, if not add it
					if (!TextureLoader.HasTexture(fullName[0]))
					{
						GameManager.Print("Skin: " + fullName[0]);
						TextureLoader.AddNewTexture(fullName[0], false);
					}
					if (!MeshToSkin.ContainsKey(model.meshes[i].name))
						MeshToSkin.Add(model.meshes[i].name, fullName[0]);
				}
			}
		}
		SkinFile.Close();
		ModelsManager.AddSkinData(skinName, MeshToSkin);
		foreach (var value in MeshToSkin)
		{
			if (!meshToSkin.ContainsKey(value.Key))
				meshToSkin.Add(value.Key, value.Value);
		}
		return true;
	}

	public void SetMultiMesh(MeshProcessed model, Node3D owner)
	{
		for (int i = 0; i < model.data.Length; i++)
		{
			if (model.data[i] == null)
				continue;
			if (model.data[i].isTransparent)
				continue;

			if (Mesher.MultiMeshes.ContainsKey(model.data[i].multiMesh))
			{
				MultiMeshData multiMeshData = new MultiMeshData();
				multiMeshData.multiMesh = model.data[i].multiMesh;
				Mesher.AddNodeToMultiMeshes(model.data[i].multiMesh, owner, Colors.Black);
				multiMeshData.owner = owner;
				multiMeshDataList.Add(multiMeshData);
			}
		}
	}
	void UpdateMultiMesh()
	{
		if (multiMeshDataList.Count == 0)
			return;

		if (Sleeping)
			return;

		for (int i = 0; i < multiMeshDataList.Count; i++)
			Mesher.UpdateInstanceMultiMesh(multiMeshDataList[i].multiMesh, multiMeshDataList[i].owner);
		
	}

	public override void _ExitTree()
	{
		if (ragDoll)
			ClearPlayerModel();
	}
	public void ClearPlayerModel()
	{
		List<MultiMesh> updateMultiMesh = new List<MultiMesh>();
		for (int i = 0; i < multiMeshDataList.Count; i++)
		{
			MultiMesh multiMesh = multiMeshDataList[i].multiMesh;
			Dictionary<Node3D, int> multiMeshSet;

			multiMeshDataList[i].owner.Hide();
			Mesher.UpdateInstanceMultiMesh(multiMesh, multiMeshDataList[i].owner);
			if (Mesher.MultiMeshes.TryGetValue(multiMesh, out multiMeshSet))
			{
				if (multiMeshSet.ContainsKey(multiMeshDataList[i].owner))
					multiMeshSet.Remove(multiMeshDataList[i].owner);
			}
			if (!updateMultiMesh.Contains(multiMesh))
				updateMultiMesh.Add(multiMesh);
		}

		//No need to update if changing map
		if (GameManager.CurrentState != GameManager.FuncState.Start)
			return;

		foreach (MultiMesh multiMesh in updateMultiMesh)
			Mesher.MultiMeshUpdateInstances(multiMesh);
	}
}```

./Assets/Scripts/Player/PlayerViewPort.cs:
```
using Godot;
using System;

public partial class PlayerViewPort : SubViewportContainer
{
	[Export]
	public SubViewport viewPort;
}
```

./Assets/Scripts/MD3.cs:
```
using Godot;
using System.IO;
using System.Collections.Generic;
using ExtensionMethods;

public class MeshProcessed
{
	public Node3D	node;
	public int numMeshes;
	public dataMeshes[] data;
	public class dataMeshes
	{
		public MeshDataTool meshDataTool = new MeshDataTool();
		public ArrayMesh arrMesh = new ArrayMesh();
		public bool isTransparent;
		public MultiMesh multiMesh;
	}
}

public class MultiMeshData
{
	public Node3D owner;
	public MultiMesh multiMesh;
}

public class SurfaceData
{
	public string skinName;															// This is the materialName;
	public MultiMesh commonMesh;													// This is the common processed Godot Mesh
	public bool useTransparent;														// This is bool for the transparent surface
	public ShaderMaterial readyMaterials;											// This is the processed Material

}

public class FrameSurfaces
{
	public List<Godot.Collections.Array> readySurfaceArray = new List<Godot.Collections.Array>();		// This is the processed Godot Mesh
	public List<SurfaceData> readySurfaces = new List<SurfaceData>();									// This store the surface data
	public Dictionary<string, int> surfaceIdbySkinName = new Dictionary<string, int>();					// Get the index of surface list by the skin name
}

public class MD3
{
	public string name;																				// The name of the model
	public int flags;																				// The model flags
	public int version;																				// The version of the model
	public int numFrames;																			// The number of frames in the model
	public int numTags;																				// The number of tags in the model
	public int numMeshes;																			// The number of meshes in the model
	public int numSkins;																			// The number of skins in the model
	public List<MD3Frame> frames;																	// The list of frames in the model
	public Dictionary<string, int> tagsIdbyName = new Dictionary<string, int>();					// Get the index of tags list in the model by name
	public List<List<MD3Tag>> tagsbyId = new List<List<MD3Tag>>();									// The list of tags in the model by Id
	public List<MD3Mesh> meshes;																	// The list of meshes in the model
	public List<MD3Skin> skins;																		// The list of skins in the model
	public Dictionary<int , FrameSurfaces> frameSurfaces = new Dictionary<int , FrameSurfaces>();	//This holds the readySurfaces by Frame
	public static MD3 ImportModel(string modelName, bool forceSkinAlpha)
	{
		BinaryReader Md3ModelFile;
		string FileName;
		string path = Directory.GetCurrentDirectory() + "/StreamingAssets/models/" + modelName + ".md3";
		if (File.Exists(path))
			Md3ModelFile = new BinaryReader(File.Open(path, FileMode.Open));
		else if (PakManager.ZipFiles.TryGetValue(path = ("models/" + modelName + ".md3").ToUpper(), out FileName))
		{
			MemoryStream ms = new MemoryStream(PakManager.GetPK3FileData(path, FileName));
			Md3ModelFile = new BinaryReader(ms);
		}
		else
			return null;

		Md3ModelFile.BaseStream.Seek(0, SeekOrigin.Begin);
		string header = path.GetStringFromBytes(Md3ModelFile.ReadBytes(4)); //4 IDP3
		if (header != "IDP3")
		{
			GD.PrintErr(modelName + " not a md3 model");
			return null;
		}

		MD3 md3Model = new MD3();

		md3Model.version = Md3ModelFile.ReadInt32();
		md3Model.name = path.GetStringFromBytes(Md3ModelFile.ReadBytes(64));

		md3Model.flags = Md3ModelFile.ReadInt32();
		md3Model.numFrames = Md3ModelFile.ReadInt32();
		md3Model.numTags = Md3ModelFile.ReadInt32();
		md3Model.numMeshes = Md3ModelFile.ReadInt32();
		md3Model.numSkins = Md3ModelFile.ReadInt32();

		int ofsFrames = Md3ModelFile.ReadInt32();
		int ofsTags = Md3ModelFile.ReadInt32();
		int ofsMeshes = Md3ModelFile.ReadInt32();
		int fileSize = Md3ModelFile.ReadInt32();


		md3Model.frames = new List<MD3Frame>();
		Md3ModelFile.BaseStream.Seek(ofsFrames, SeekOrigin.Begin);
		for (int i = 0; i < md3Model.numFrames; i++)
		{
			MD3Frame frame = new MD3Frame();

			float x = Md3ModelFile.ReadSingle();
			float y = Md3ModelFile.ReadSingle();
			float z = Md3ModelFile.ReadSingle();
			frame.bb_Min = new Vector3(x, y, z);

			x = Md3ModelFile.ReadSingle();
			y = Md3ModelFile.ReadSingle();
			z = Md3ModelFile.ReadSingle();
			frame.bb_Max = new Vector3(x, y, z);

			x = Md3ModelFile.ReadSingle();
			y = Md3ModelFile.ReadSingle();
			z = Md3ModelFile.ReadSingle();
			frame.locOrigin = new Vector3(x, y, z);

			frame.bs_Radius = Md3ModelFile.ReadSingle();

			Md3ModelFile.ReadBytes(16);
//			frame.name = GetStringFromBytes(Md3ModelFile.ReadBytes(16));
			frame.name = "Frame " + i;
			frame.QuakeToGodotCoordSystem();
			md3Model.frames.Add(frame);
		}

		for (int numFrame = 0; numFrame < md3Model.numFrames; numFrame++) 
		{
			for (int numtag = 0; numtag < md3Model.numTags; numtag++)
			{
				MD3Tag tag = new MD3Tag();
				tag.name = path.GetStringFromBytes(Md3ModelFile.ReadBytes(64));
				float x = Md3ModelFile.ReadSingle();
				float y = Md3ModelFile.ReadSingle();
				float z = Md3ModelFile.ReadSingle();

				tag.origin = new Vector3(x, y, z);

				float m00 = Md3ModelFile.ReadSingle();
				float m01 = Md3ModelFile.ReadSingle();
				float m02 = Md3ModelFile.ReadSingle();

				float m10 = Md3ModelFile.ReadSingle();
				float m11 = Md3ModelFile.ReadSingle();
				float m12 = Md3ModelFile.ReadSingle();

				float m20 = Md3ModelFile.ReadSingle();
				float m21 = Md3ModelFile.ReadSingle();
				float m22 = Md3ModelFile.ReadSingle();

				Vector3 column0 = new Vector3(m00, m10, m20);
				Vector3 column1 = new Vector3(m01, m11, m21);
				Vector3 column2 = new Vector3(m02, m12, m22);
				Vector3 column3 = new Vector3(0, 0, 0);

				//https://math.stackexchange.com/questions/3882851/convert-rotation-matrix-between-coordinate-systems
				//We need to convert the rotation to the new coordinate system, the new coordinate system conversion is given by T (Quakt To Unity Conversion)
				//If the two coordinate system are in the same space and they are related by T, with the old rotation Ra then the new rotation Rb is given by 
				//Rb = TRaT^-1
				Transform3D R = new Transform3D(column0, column1, column2, column3);
				if (R.IsFinite())
				{
					//https://gamedev.stackexchange.com/questions/203073/how-to-convert-a-4x4-matrix-transformation-to-another-coordinate-system
					//We want to map +x to -x (-1 ,  0 ,  0)
					//We want to map +y to +z ( 0 ,  0 ,  1)
					//We want to map +z to +y ( 0 ,  1 ,  0)
					//We want the origin, coordinate to survive unchanged (0, 0, 0)
					//If we left-multiply this matrix by any homogeneous vector in our old coordinate system,
					//it converts it to the corresponding vector in the new coordinate system:
					//Vnew = T*Vold
					Transform3D T = new Transform3D(-1, 0, 0,
													 0, 0, 1,
													 0, 1, 0,
													 0, 0, 0);

					tag.orientation = T * R * T.Inverse();
					Quaternion Rot = tag.orientation.Basis.GetRotationQuaternion();
					if (Rot.IsNormalized())
						tag.rotation = Rot.Inverse();
				}
				tag.QuakeToGodotCoordSystem();
				if (!md3Model.tagsIdbyName.ContainsKey(tag.name))
				{
					List<MD3Tag> tagList = new List<MD3Tag>();
					md3Model.tagsIdbyName.Add(tag.name, numtag);
					md3Model.tagsbyId.Add(tagList);
				}

				tag.localOrigin = md3Model.frames[numFrame].locOrigin;
				md3Model.tagsbyId[md3Model.tagsIdbyName[tag.name]].Add(tag);
			}
		}

		int offset = ofsMeshes;
		md3Model.meshes = new List<MD3Mesh>(md3Model.numMeshes);
		for (int i = 0; i < md3Model.numMeshes; i++)
		{
			Md3ModelFile.BaseStream.Seek(offset, SeekOrigin.Begin);
			MD3Mesh md3Mesh = new MD3Mesh();

			md3Mesh.parseMesh(i, md3Model.name, Md3ModelFile, offset, forceSkinAlpha);
			offset += md3Mesh.meshSize;
			md3Model.meshes.Add(md3Mesh);
		}
		return md3Model;
	}
}
public class MD3Frame
{
	public string name;                 // The name of the frame
	public Vector3 bb_Min;              // The minimum bounds of the frame's bounding box
	public Vector3 bb_Max;              // The maximum bounds of the frame's bounding box
	public float bs_Radius;             // The radius of the frame's bounding sphere
	public Vector3 locOrigin;           // The local origin of the frame
	public void QuakeToGodotCoordSystem()
	{
		bb_Min = new Vector3(-bb_Min.X, bb_Min.Z, bb_Min.Y);
		bb_Max = new Vector3(-bb_Max.X, bb_Max.Z, bb_Max.Y);
		locOrigin = new Vector3(-locOrigin.X, locOrigin.Z, locOrigin.Y);

		bb_Min *= GameManager.sizeDividor;
		bb_Max *= GameManager.sizeDividor;
		locOrigin *= GameManager.sizeDividor;
		bs_Radius *= GameManager.sizeDividor;
	}
}
public class MD3Tag
{
	public string name;                 // The name of the tag
	public Vector3 origin;              // The origin of the tag in 3D space
	public Vector3 localOrigin;         // Model local origin in 3D space
	public Transform3D orientation;       // The orientation of the tag in 3D space
	public Quaternion rotation;         // The rotation of the tag in 3D space
	public void QuakeToGodotCoordSystem()
	{
		origin = new Vector3(-origin.X, origin.Z, origin.Y);
		origin *= GameManager.sizeDividor;
	}
}
public class MD3Skin
{
	public string name;                 // The name of the skin
	public int skinId;                  // The index of the skin in the list of skins
	public MD3Skin(int skinId, string name)
	{
		this.skinId = skinId;
		this.name = name;
	}
}

public class MD3Mesh
{
	public string name;                 // The name of the surface
	public int meshNum;                 // The index num of the mesh in the model
	public int meshId;                  // The index of the mesh in the list of meshes
	public int flags;                   // The flags associated with the surface
	public int numFrames;               // The number of frames in the surface
	public int numSkins;                // The number of skins in the surface
	public int numTriangles;            // The number of triangles in the surface
	public int numVertices;             // The number of vertexes in the surface
	public List<MD3Skin> skins;         // The list of shaders in the surface
	public List<MD3Triangle> triangles; // The list of triangles in the surface
	public List<Vector3>[] verts;       // The list of vertexes in the surface
	public List<Vector3>[] normals;       // The list of normals in the surface
	public List<Vector2> texCoords;     // The texture coordinates of the vertex
	public int meshSize;                // This stores the total mesh size
	public void parseMesh(int MeshNum, string modelName, BinaryReader Md3ModelFile, int MeshOffset, bool forceSkinAlpha)
	{
		meshNum = MeshNum;
		meshId = Md3ModelFile.ReadInt32();
		name = modelName.GetStringFromBytes(Md3ModelFile.ReadBytes(64)).ToUpper();

//		GameManager.Print("Loading Mesh: " + name + " , " + meshId);

		flags = Md3ModelFile.ReadInt32();
		numFrames = Md3ModelFile.ReadInt32();					// This stores the mesh aniamtion frame count
		numSkins = Md3ModelFile.ReadInt32();					// This stores the mesh skin count
		numVertices = Md3ModelFile.ReadInt32();					// This stores the mesh vertex count
		numTriangles = Md3ModelFile.ReadInt32();				// This stores the mesh face count
		int ofsTriangles = Md3ModelFile.ReadInt32();			// This stores the starting offset for the triangles
		int ofsSkins = Md3ModelFile.ReadInt32();				// This stores the header size for the mesh
		int ofsTexCoords = Md3ModelFile.ReadInt32();			// This stores the starting offset for the UV coordinates
		int ofsVerts = Md3ModelFile.ReadInt32();				// This stores the starting offset for the vertex indices
		meshSize = Md3ModelFile.ReadInt32();					// This stores the total mesh size

		skins = new List<MD3Skin>();
		List<string> skinList = new List<string>();

		Md3ModelFile.BaseStream.Seek(MeshOffset + ofsSkins, SeekOrigin.Begin);
		for (int i = 0; i < numSkins; i++)
		{
			string skinName = modelName.GetStringFromBytes(Md3ModelFile.ReadBytes(64)).StripExtension().ToUpper();
			int num = Md3ModelFile.ReadInt32();

			//Some skins are mentioned more than once
			if (skinList.Contains(skinName))
				continue;

			if (string.IsNullOrEmpty(skinName))
				continue;

			if (!TextureLoader.HasTexture(skinName))
				TextureLoader.AddNewTexture(skinName, forceSkinAlpha);

			skins.Add(new MD3Skin(num, skinName));
			skinList.Add(skinName);
		}
		//Update Number of skins as some are repeated
		numSkins = skins.Count;

		triangles = new List<MD3Triangle>();
		Md3ModelFile.BaseStream.Seek(MeshOffset + ofsTriangles, SeekOrigin.Begin);
		for (int i = 0; i < numTriangles; i++)
		{
			int f0 = Md3ModelFile.ReadInt32();
			int f1 = Md3ModelFile.ReadInt32();
			int f2 = Md3ModelFile.ReadInt32();
			triangles.Add(new MD3Triangle(i, f0, f1, f2));
		}

		texCoords = new List<Vector2>();
		Md3ModelFile.BaseStream.Seek(MeshOffset + ofsTexCoords, SeekOrigin.Begin);
		for (int i = 0; i < numVertices; i++)
		{
			float u = Md3ModelFile.ReadSingle();
			float v = Md3ModelFile.ReadSingle();
			texCoords.Add(new Vector2(u, v));
		}

		verts = new List<Vector3>[numFrames];
		normals = new List<Vector3>[numFrames];
		for (int i = 0; i < numFrames; i++)
		{
			verts[i] = new List<Vector3>();
			normals[i] = new List<Vector3>();
		}
		Md3ModelFile.BaseStream.Seek(MeshOffset + ofsVerts, SeekOrigin.Begin);
		for (int i = 0, j = 0; i < numVertices * numFrames; i++)
		{
			float x = Md3ModelFile.ReadInt16() * GameManager.modelScale;
			float y = Md3ModelFile.ReadInt16() * GameManager.modelScale;
			float z = Md3ModelFile.ReadInt16() * GameManager.modelScale;
			byte n1 = Md3ModelFile.ReadByte();
			byte n2 = Md3ModelFile.ReadByte();

			float lng = n1 * (Mathf.Pi) / 128.0f;
			float lat = n2 * (Mathf.Pi) / 128.0f;

			Vector3	normal = new Vector3(- Mathf.Cos(lat) * Mathf.Sin(lng), Mathf.Cos(lng), Mathf.Sin(lat) * Mathf.Sin(lng));
			Vector3 position = new Vector3(-x, z, y);
			position *= GameManager.sizeDividor;
			verts[j].Add(position);
			normals[j].Add(normal.Normalized());
			if (((i + 1) % numVertices) == 0)
				j++;
		}
	}

}

// The indexes of the vertexes that make up the triangle
public class MD3Triangle
{
	public int triId;
	public int vertex1;
	public int vertex2;
	public int vertex3;
	public MD3Triangle(int triId, int vertex1, int vertex2, int vertex3)
	{
		this.triId = triId;
		this.vertex1 = vertex1;
		this.vertex2 = vertex2;
		this.vertex3 = vertex3;
	}
}```

./Assets/Scripts/Managers/QShaderManager.cs:
```
using Godot;
using System.IO;
using System.Collections.Generic;
using ExtensionMethods;

public static class QShaderManager
{
	public static Dictionary<string, QShaderData> QShaders = new Dictionary<string, QShaderData>();
	public static Dictionary<string, QShaderData> FogShaders = new Dictionary<string, QShaderData>();
	public enum GenFuncType
	{
		RGB,
		Alpha
	}

	public static ShaderMaterial GetFog(string shaderName, float height)
	{
		const string Density = "shader_parameter/density";
		const string Albedo = "shader_parameter/albedo";
		const string Emission = "shader_parameter/emission";
		const string HeightFalloff = "shader_parameter/height_falloff";

		ShaderMaterial fogMaterial = (ShaderMaterial)MaterialManager.Instance.fogMaterial.Duplicate(true);

		QShaderData Fog;
		if (!FogShaders.TryGetValue(shaderName, out Fog))
		{
			fogMaterial.Set(Density, .15f);
			fogMaterial.Set(Emission, Colors.Black);
			return fogMaterial;
		}

		float R = TryToParseFloat(Fog.qShaderGlobal.fogParms[1]);
		float G = TryToParseFloat(Fog.qShaderGlobal.fogParms[2]);
		float B = TryToParseFloat(Fog.qShaderGlobal.fogParms[3]);
		float OpaqueHeight = TryToParseFloat(Fog.qShaderGlobal.fogParms[5]) * GameManager.sizeDividor;
		if (OpaqueHeight >= height)
			fogMaterial.Set(Density, height / OpaqueHeight);
		else
		{
			fogMaterial.Set(Density, 1);
			fogMaterial.Set(HeightFalloff, .15f / OpaqueHeight);
		}

		fogMaterial.Set(Emission, new Color(R, G, B));


		return fogMaterial;
	}

	public static bool HasShader(string shaderName)
	{
		if (QShaders.ContainsKey(shaderName))
			return true;
		return false;
	}
	public static ShaderMaterial GetShadedMaterial(string shaderName, int lm_index, ref bool alphaIsTransparent, ref bool hasPortal, List<int> multiPassList = null, bool forceView = false, bool canvasShader = false, int numPass = 0)
	{
		string code = "";
		string GSHeader = "shader_type spatial;\nrender_mode diffuse_lambert, specular_schlick_ggx, ";
		if (canvasShader)
			GSHeader = "shader_type canvas_item;\nrender_mode ";
		string GSUniforms = "";
		string GSLigtH = "void light()\n{ \n";
		string GSVertexH = "void vertex()\n{ \n";
		string GSVaryings = "";
		string GSVertexUvs = "";
		string GSFragmentH = "void fragment()\n{ \n";
		string GSFragmentUvs = "";
		string GSFragmentTcMod = "";
		string GSFragmentTexs = "";
		string GSLateFragmentTexs = "";
		string GSFragmentRGBs = "\tvec4 vertx_color = COLOR;\n";
		if (canvasShader)
			GSFragmentRGBs = "\tvec4 vertx_color = vec4(1.0);\n";
		string GSFragmentBlends = "";
		string GSAnimation = "";

		List<string> textures = new List<string>();
		Dictionary<string, int> TexIndex = new Dictionary<string, int>();

		QShaderData qShader;
		if (!QShaders.TryGetValue(shaderName, out qShader))
			return null;

		GameManager.Print("Shader found: " + shaderName);

		GetSunData(qShader);

		int lightmapStage = -1;
		bool helperRotate = false;
		bool animStages = false;
		bool skyMap = false;
		bool depthWrite = false;
		bool entityColor = false;
		bool checkEditorImage = true;
		bool firstPass = true;

		//Needed for Mutipass
		int needMultiPass = 0;
		bool forceAlpha = alphaIsTransparent;
		QShaderGlobal.SortType sortType = qShader.qShaderGlobal.sort;
		int totalStages;

		if (multiPassList == null)
			totalStages = qShader.qShaderStages.Count;
		else
		{
			totalStages = multiPassList.Count;
			if (multiPassList[0] != 0)
			{
				firstPass = false;
				checkEditorImage = false;
			}
		}

		for (int i = 0; i < totalStages; i++)
		{
			int currentStage;
			if (multiPassList == null)
				currentStage = i;
			else
				currentStage = multiPassList[i];
			
			QShaderStage qShaderStage = qShader.qShaderStages[currentStage];

			if (qShaderStage.map != null)
			{
				if (qShaderStage.skyMap)
				{
					skyMap = true;
					int index = textures.Count;
					GSUniforms += "uniform samplerCube " + "Sky_" + currentStage + " : repeat_disable;\n";
					GSFragmentTexs += "\tvec3 sky_uv" + currentStage + " = vot" + currentStage + ".xyz;\n";
					GSFragmentTexs += "\tvec4 Stage_" + currentStage + " = texture(" + "Sky_" + currentStage + ", sky_uv" + currentStage + ");\n";
					TexIndex.Add(qShaderStage.map[0], index);
					textures.Add(qShaderStage.map[0]);
				}
				else if (qShaderStage.animFreq > 0)
				{
					animStages = true;
					GSLateFragmentTexs += "\tvec4 Stage_" + currentStage + " = animation_" + currentStage + "(Time, ";
					GSLateFragmentTexs += qShaderStage.animFreq.ToString("0.00") + " , " + qShaderStage.map.Length;
					for (int j = 0; j < qShaderStage.map.Length; j++)
						GSLateFragmentTexs += " , Anim_" + currentStage + "_" + j;
					GSLateFragmentTexs += ");\n";
					GSAnimation += "vec4 animation_" + currentStage + "(float Time, ";
					GSAnimation += "float freq , int frames";
					for (int j = 0; j < qShaderStage.map.Length; j++)
						GSAnimation += " , vec4 frame_" + j;
					GSAnimation += ")\n";
					GSAnimation += "{\n";
					GSAnimation += "\tvec4 frame["+ qShaderStage.map.Length + "] = { ";
					for (int j = 0; j < qShaderStage.map.Length; j++)
					{
						if (j != 0)
							GSAnimation += " , ";
						GSAnimation += "frame_" + j;
					}
					GSAnimation += "};\n";
					GSAnimation += "\tint currentFrame = int(floor(mod(Time * freq,  float(frames))));\n";
					GSAnimation += "\treturn frame[currentFrame];\n";
					GSAnimation += "}\n";
				}
				else
				{
					int index;
					if (TexIndex.TryGetValue(qShaderStage.map[0], out index))
					{
						if (qShaderStage.isLightmap)
							GSFragmentTexs += "\tvec4 Stage_" + currentStage + " = texture(" + "LightMap, uv_" + currentStage + ");\n";
						else
							GSFragmentTexs += "\tvec4 Stage_" + currentStage + " = texture(" + "Tex_" + index + ", uv_" + currentStage + ");\n";
					}
					else
					{
						index = textures.Count;
						if (qShaderStage.isLightmap)
						{
							GSUniforms += "uniform sampler2D " + "LightMap";
							GSFragmentTexs += "\tvec4 Stage_" + currentStage + " = texture(" + "LightMap, uv_" + currentStage + ");\n";
						}
						else
						{
							GSUniforms += "uniform sampler2D " + "Tex_" + index;
							GSFragmentTexs += "\tvec4 Stage_" + currentStage + " = texture(" + "Tex_" + index + ", uv_" + currentStage + ");\n";
						}

						if (qShaderStage.clamp)
							GSUniforms += " : repeat_disable;\n";
						else
							GSUniforms += " : repeat_enable;\n";

						TexIndex.Add(qShaderStage.map[0], index);
						//Lightmap will be added outside of the shader creation
						if (qShaderStage.isLightmap)
							textures.Add("");
						else
							textures.Add(qShaderStage.map[0]);
					}
				}
			}
			else
			{
				GameManager.Print("Shader: '" + shaderName + "' Stage: " + currentStage + " is invalid, skipping", GameManager.PrintType.Warning);
				continue;
			}

			GSVertexUvs += GetUVGen(qShader, currentStage, ref GSVaryings);
			GSFragmentUvs += GetTcGen(qShader, currentStage, ref lightmapStage);
			GSFragmentTcMod += GetTcMod(qShader, currentStage, ref helperRotate);
			
			GSFragmentRGBs += GetGenFunc(qShader, currentStage, GenFuncType.RGB, ref entityColor);
			GSFragmentRGBs += GetGenFunc(qShader, currentStage, GenFuncType.Alpha, ref entityColor);
			GSFragmentBlends += GetAlphaFunc(qShader, currentStage, multiPassList, ref needMultiPass);
			GSFragmentBlends += GetBlend(qShader, currentStage, i, multiPassList, ref needMultiPass, ref alphaIsTransparent);
			if (qShaderStage.depthWrite)
			{
				if (i == 0)
					depthWrite = true;
				else
					needMultiPass = i;
			}
		}

		if (needMultiPass > 0)
		{
			GameManager.Print("Shader needs multipass " + needMultiPass);
			List<int> matPass = new List<int>();
			for (int i = 0; i < needMultiPass; i++)
			{
				int currentStage;
				if (multiPassList == null)
					currentStage = i;
				else
					currentStage = multiPassList[i];
				matPass.Add(currentStage);
			}
			if (lightmapStage >= 0)
				if (!matPass.Contains(lightmapStage))
					matPass.Add(lightmapStage);
			bool baseAlpha = forceAlpha;

			ShaderMaterial passZeroMaterial = GetShadedMaterial(shaderName, lm_index, ref baseAlpha, ref hasPortal, matPass, forceView, canvasShader, numPass);
			ShaderMaterial lastMaterial = passZeroMaterial;

			while (lastMaterial.NextPass != null)
			{
				numPass++;
				lastMaterial = (ShaderMaterial)lastMaterial.NextPass;
			}

			matPass = new List<int>();
			if (multiPassList == null)
				totalStages = qShader.qShaderStages.Count;
			else
				totalStages = multiPassList.Count;
			for (int i = needMultiPass; i < totalStages; i++)
			{
				int currentStage;
				if (multiPassList == null)
					currentStage = i;
				else
					currentStage = multiPassList[i];
				matPass.Add(currentStage);
			}
			if (lightmapStage >= 0)
				if (!matPass.Contains(lightmapStage))
					matPass.Add(lightmapStage);

			qShader.qShaderGlobal.sort = sortType;

			numPass++;
			ShaderMaterial passOneMaterial = GetShadedMaterial(shaderName, lm_index, ref forceAlpha, ref hasPortal, matPass, forceView, canvasShader, numPass);
			lastMaterial.NextPass = passOneMaterial;
			alphaIsTransparent = forceAlpha | baseAlpha;

			return passZeroMaterial;
		}

		if (canvasShader)
		{
			switch (qShader.qShaderGlobal.sort)
			{
				case QShaderGlobal.SortType.Opaque:
					GSHeader += "blend_mix";
				break;
				case QShaderGlobal.SortType.Additive:
					GSHeader += "blend_add";
				break;
				case QShaderGlobal.SortType.Multiplicative:
					GSHeader += "blend_mul";
					qShader.qShaderGlobal.unShaded = true;
				break;
			}
		}
		else
		{
			switch (qShader.qShaderGlobal.sort)
			{
				case QShaderGlobal.SortType.Opaque:
				{
					if (alphaIsTransparent)
					{
						if (multiPassList != null)
							GSHeader += "depth_prepass_alpha, ";
					}
					if ((depthWrite) || (forceAlpha))
						GSHeader += "depth_draw_always, blend_mix, ";
					else
						GSHeader += "depth_draw_opaque, blend_mix, ";
				}
				break;
				case QShaderGlobal.SortType.Additive:
					if (depthWrite)
						GSHeader += "depth_draw_always, blend_add, ";
					else
						GSHeader += "depth_draw_opaque, blend_add, ";
				break;
				case QShaderGlobal.SortType.Multiplicative:
					if (depthWrite)
						GSHeader += "depth_draw_always, blend_mul, ";
					else
						GSHeader += "depth_draw_opaque, blend_mul, ";
					qShader.qShaderGlobal.unShaded = true;
				break;
			}
		}

		if (qShader.qShaderGlobal.isSky)
		{
			qShader.qShaderGlobal.unShaded = true;
			checkEditorImage = false;
		}

		if (qShader.qShaderGlobal.unShaded)
		{
			if (canvasShader)
				GSHeader += ", unshaded";
			else
				GSHeader += "unshaded, ";
		}

		if (canvasShader)
			GSHeader += ";\n \n";
		else
		{
			switch (qShader.qShaderGlobal.cullType)
			{
				case QShaderGlobal.CullType.Back:
					GSHeader += "cull_back;\n \n";
				break;
				case QShaderGlobal.CullType.Front:
					GSHeader += "cull_front;\n \n";
				break;
				case QShaderGlobal.CullType.Disable:
					GSHeader += "cull_disabled;\n \n";
				break;
			}
		}

		int totalTex = textures.Count;
		if (qShader.qShaderGlobal.trans)
		{
			alphaIsTransparent = true;
			GameManager.Print("Current shader is transparent");
		}

		if ((checkEditorImage) && (qShader.qShaderGlobal.editorImage.Length != 0))
		{
			if (QShaders.TryGetValue(qShader.qShaderGlobal.editorImage, out QShaderData qeditorShader))
			{
				if (qeditorShader.qShaderGlobal.trans)
				{
					alphaIsTransparent = true;
					GameManager.Print("Current editor shader is transparent");
				}
			}

			if (TextureLoader.HasTextureOrAddTexture(qShader.qShaderGlobal.editorImage, alphaIsTransparent))
			{
				int lastStage = totalStages;
				if (multiPassList != null)
					lastStage = multiPassList[lastStage-1] + 1;

				if (TexIndex.TryGetValue(qShader.qShaderGlobal.editorImage, out int editorIndex))
				{
					GSFragmentUvs += "\tvec2 uv_" + lastStage + " = UV;\n";
					GSFragmentTexs += "\tvec4 Stage_" + lastStage + " = texture(" + "Tex_" + editorIndex + ", uv_" + lastStage + ");\n";
				}
				else
				{
					GSUniforms += "uniform sampler2D " + "Tex_" + totalTex + " : repeat_enable;\n";
					GSFragmentUvs += "\tvec2 uv_" + lastStage + " = UV;\n";
					GSFragmentTexs += "\tvec4 Stage_" + lastStage + " = texture(" + "Tex_" + totalTex + ", uv_" + lastStage + ");\n";
					textures.Add(qShader.qShaderGlobal.editorImage);
					TexIndex.Add(qShader.qShaderGlobal.editorImage, totalTex);
					totalTex++;
				}
			}
		}

		if (animStages)
		{
			for (int i = 0; i < totalStages; i++)
			{
				QShaderStage qShaderStage = qShader.qShaderStages[i];
				if (qShaderStage.map != null)
				{
					if (qShaderStage.animFreq > 0)
					{
						for (int j = 0; j < qShaderStage.map.Length; j++)
						{
							if (TexIndex.TryGetValue(qShaderStage.map[j], out int texIndex))
								GSFragmentTexs += "\tvec4 Anim_" + i + "_" + j + " = texture(" + "Tex_" + texIndex + ", uv_" + i + ");\n";
							else
							{
								GSUniforms += "uniform sampler2D " + "Tex_" + totalTex + " : repeat_enable;\n";
								GSFragmentTexs += "\tvec4 Anim_" + i + "_" + j + " = texture(" + "Tex_" + totalTex + ", uv_" + i + ");\n";
								TexIndex.Add(qShaderStage.map[j], totalTex);
								textures.Add(qShaderStage.map[j]);
								totalTex++;
							}
						}
					}
				}
			}
		}

		code += GSHeader;
		code += GSUniforms;
		code += GSVaryings;
		code += "global uniform float ViewCameraFOV;\n";
		code += "global uniform float MsTime;\n";
		code += "global uniform vec4 AmbientColor: source_color;\n";
		code += "global uniform float mixBrightness;\n";
		if (canvasShader)
			code += "uniform float OffSetTime = 0.0;\n";
		else
			code += "instance uniform float OffSetTime = 0.0;\n";
		if (entityColor)
		{
			code += "uniform bool UseModulation = true;\n";
			if (canvasShader)
				code += "uniform vec4 modulate: source_color = vec4(1.0, 1.0, 1.0, 1.0);\n";
			else
				code += "instance uniform vec4 modulate: source_color = vec4(1.0, 1.0, 1.0, 1.0);\n";
		}
		if ((multiPassList == null) && (canvasShader == false) && (qShader.qShaderGlobal.isSky == false))
		{
			code += "instance uniform float ShadowIntensity : hint_range(0, 1) = 0.0;\n";
			code += "instance uniform bool ViewModel = false;\n";
			code += "instance uniform bool UseLightVol = false;\n";
			code += "global uniform vec3 LightVolNormalize;\n";
			code += "global uniform vec3 LightVolOffset;\n";
			code += "global uniform sampler3D LightVolAmbient;\n";
			code += "global uniform sampler3D LightVolDirectonal;\n";
			code += "varying vec3 ambientColor;\n";
			code += "varying vec3 dirColor;\n";
			code += "varying vec3 dirVector;\n\n";
			code += "vec3 GetTextureCoordinates(vec3 Position)\n";
			code += "{\n\tPosition -= LightVolOffset;\n";
			code += "\tvec3 Q3Pos = vec3(Position.x / -LightVolNormalize.x, Position.z / LightVolNormalize.y, Position.y / LightVolNormalize.z);\n";
			code += "\treturn Q3Pos;\n}\n";
		}
		if (helperRotate)
		{
			code += "\nvec2 rotate(vec2 uv, vec2 pivot, float angle)\n{\n\tmat2 rotation = mat2(vec2(sin(angle), -cos(angle)),vec2(cos(angle), sin(angle)));\n";
			code += "\tuv -= pivot;\n\tuv = uv * rotation;\n\tuv += pivot;\n\treturn uv;\n}\n\n";
		}

		if (animStages)
			code += GSAnimation;

		//Vertex
		if ((canvasShader == false) && (qShader.qShaderGlobal.isSky == false))
		{
			float Value = 0.001f;
			bool offSet = qShader.qShaderGlobal.polygonOffset;
			if (offSet)
				numPass++;
			code += GSVertexH;
			if (multiPassList == null)
			{
				code += "\tvec3 WorldPos = GetTextureCoordinates((MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz);\n";
				code += "\tvec4 ambient = texture(LightVolAmbient, WorldPos);\n";
				code += "\tvec4 dir = texture(LightVolDirectonal, WorldPos);\n";
				code += "\tambientColor = ambient.rgb;\n";
				code += "\tdirColor = dir.rgb;\n";
				code += "\tfloat lng = ambient.a * (PI) / 128.0f;\n";
				code += "\tfloat lat = dir.a * (PI) / 128.0f;\n";
				code += "\tdirVector = vec3(-cos(lat) * sin(lng), cos(lng), sin(lat) * sin(lng));\n";
			}
			else if (!firstPass)
				offSet = true;

			if (offSet)
				Value *= numPass;
			code += GetVertex(qShader, (multiPassList == null), forceView, offSet, Value);
			code += GSVertexUvs + "}\n";
		}

		//Lightning
		if ((multiPassList == null) && (qShader.qShaderGlobal.unShaded == false) && (canvasShader == false))
		{
			code += GSLigtH;
			code += GetDiffuseLightning();
			code += "}\n";
		}

		code += GSFragmentH;
		code += GSFragmentUvs;
		code += "\tfloat Time = (MsTime - OffSetTime);\n";
		code += GSFragmentTcMod;
		code += GSFragmentTexs;
		code += GSLateFragmentTexs;
		code += GSFragmentRGBs;

		if (qShader.qShaderGlobal.isSky)
			code += "\tvec3 ambient = AmbientColor.rgb;\n";
		else if (lightmapStage < 0)
			code += "\tvec3 ambient = AmbientColor.rgb * mixBrightness;\n";

		if ((qShader.qShaderGlobal.isSky) || (!firstPass) || (qShader.qShaderGlobal.sort == QShaderGlobal.SortType.Additive))
			code += "\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n";
		else if (lightmapStage >= 0)
			code += "\tvec4 color = Stage_" + lightmapStage + ";\n";
		else if (qShader.qShaderGlobal.editorImage.Length != 0)
		{
			if (TexIndex.ContainsKey(qShader.qShaderGlobal.editorImage))
				code += "\tvec4 color = Stage_" + totalStages + ";\n";
			else
				code += "\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n";
		}
		else 
			code += "\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n";

		code += "\tvec4 black = vec4(0.0, 0.0, 0.0, 0.0);\n";
		code += "\tvec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n";
		code += GSFragmentBlends;

		if (qShader.qShaderGlobal.isSky)
		{
			if (canvasShader)
				code += "\tCOLOR.rgb = (color.rgb * ambient);\n";
			else
			{
				code += "\tALBEDO = (color.rgb * ambient);\n";
				code += "\tEMISSION = ambient;\n";
			}
		}
		else if (qShader.qShaderGlobal.sort == QShaderGlobal.SortType.Multiplicative)
		{
			if (canvasShader)
				code += "\tCOLOR.rgb = color.rgb;\n";
			else
				code += "\tALBEDO = color.rgb;\n";
		}
		else
		{
			code += "\tvec3 albedo = color.rgb * vertx_color.rgb;\n";
			code += "\tvec3 emission = color.rgb;\n";
			if (lightmapStage >= 0)
				code += "\temission = mix(Stage_" + lightmapStage + ".rgb * color.rgb, color.rgb, mixBrightness);\n";
			else
			{
				code += "\tvec3 defaultEmission = mix(emission * ambient, emission, mixBrightness);\n";
				if ((multiPassList == null) && (canvasShader == false))
				{
					code += "\tvec3 useLightVolEmission = emission * mix(ambientColor, emission, mixBrightness);\n";
					code += "\temission = mix(defaultEmission, useLightVolEmission, float(UseLightVol));\n";
				}
				else
					code += "\temission = defaultEmission;\n";
			}

			//FOG gets removed from sprites
			if ((MaterialManager.HasBillBoard.Contains(qShader.Name)) && (qShader.qShaderGlobal.sort == QShaderGlobal.SortType.Additive))
				code += "\talbedo -= FOG.rgb;\n";
			if (canvasShader)
				code += "\tCOLOR.rgb = albedo;\n";
			else
			{
				code += "\tALBEDO = albedo;\n";
				code += "\tEMISSION = emission;\n";
			}
		}
		if (forceView)
			code += "\tDEPTH = mix(FRAGCOORD.z, 1.0, 0.999);\n";
		else if ((multiPassList == null) && (canvasShader == false) && (qShader.qShaderGlobal.isSky == false))
			code += "\tDEPTH = mix(FRAGCOORD.z, mix(FRAGCOORD.z, 1.0, 0.999), float(ViewModel));\n";

		if (qShader.qShaderGlobal.portal)
		{
			hasPortal = true;
			alphaIsTransparent = false;
		}

		if (alphaIsTransparent)
		{
			if (canvasShader)
				code += "\tCOLOR = COLOR.rgb + color.a;\n";
			else if ((multiPassList == null) || (firstPass))
				code += "\tALPHA = color.a;\n";
			else
			{
				code += "\tALPHA_HASH_SCALE = 0.5;\n";
				code += "\tALPHA = color.a;\n";
			}
		}
		code += "}\n\n";

//		if (shaderName.Contains("RAILGUN"))
//			GameManager.Print(code);

		Shader shader = new Shader();
		shader.Code = code;
		ImageTexture tex;
		ShaderMaterial shaderMaterial = new ShaderMaterial();
		shaderMaterial.Shader = shader;
		for (int i = 0; i < textures.Count; i++)
		{
			if (textures[i].Length > 0)
			{
				//CubeMap Skybox will always be the first stage
				if ((i == 0) && (skyMap))
				{
					Cubemap cube = TextureLoader.GetCubeMap(textures[i]);
					shaderMaterial.SetShaderParameter("Sky_" + i, cube);
				}
				//Check for Quake Live Ads
				else if (textures[i] == MaterialManager.advertisementTexture)
				{
					shaderMaterial.SetShaderParameter("Tex_" + i, GameManager.Instance.AdvertisementViewPort.GetTexture());
					if (!MaterialManager.AdsMaterials.Contains(shaderName))
						MaterialManager.AdsMaterials.Add(shaderName);
				}
				else
				{
					tex = TextureLoader.GetTextureOrAddTexture(textures[i], alphaIsTransparent);
					shaderMaterial.SetShaderParameter("Tex_" + i, tex);
				}
			}
		}

		if (hasPortal)
		{
			ShaderMaterial portalMaterial = PortalMaterial(qShader);
			shaderMaterial.NextPass = portalMaterial;
		}

		if (lightmapStage >= 0)
		{
			//If Lightmap is needed but there is no lightmapIndex, then the material is broken
			if (lm_index == -1)
			{
				GameManager.Print("Requested Lightmap, but there is no lightmapIndex", GameManager.PrintType.Warning);
				return MaterialManager.Instance.illegal;
			}
		}

		return shaderMaterial;
	}

	public static void GetSunData(QShaderData qShader)
	{
		if (qShader.qShaderGlobal.sunParams == null)
			return;

		string[] SunData = qShader.qShaderGlobal.sunParams;
		float degrees = TryToParseFloat(SunData[4]);
		float elevation = TryToParseFloat(SunData[5]);
		GameManager.Instance.Sun.RotationDegrees = new Vector3(-elevation, degrees - 90, 0); 

	}
	public static ShaderMaterial PortalMaterial(QShaderData qShader)
	{
		string code = "shader_type spatial;\nrender_mode diffuse_lambert, specular_schlick_ggx, depth_draw_always, blend_mix, cull_back;\n\n";
		code += "uniform sampler2D Tex_0 : repeat_enable;\n";
		code += "uniform float Transparency : hint_range(0, 1) = 0.0;\n";
		code += "global uniform float MsTime;\n";
		code += "global uniform vec4 AmbientColor: source_color;\n";
		code += "global uniform float mixBrightness;\n";
		code += "instance uniform float OffSetTime = 0.0;\n";
		code += "const bool ViewModel = false;\n";
		code += "void vertex()\n{\n";
		code += GetVertex(qShader, false, false, qShader.qShaderGlobal.polygonOffset) + "}\n";
		code += "void fragment()\n{\n\tvec2 uv_0 = SCREEN_UV;\n\tvec4 Stage_0 = texture(Tex_0, uv_0);\n";
		code += "\tvec4 ambient = AmbientColor * mixBrightness;\n";
		code += "\tvec4 vertx_color = COLOR;\n";
		code += "\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n";
		code += "\tcolor = Stage_0;\n";
		code += "\tALBEDO = (color.rgb * vertx_color.rgb);\n";
		code += "\tEMISSION = mix((ambient.rgb * color.rgb), color.rgb, mixBrightness);\n";
		code += "\tALPHA = Transparency;\n";
		code += "}\n\n";
		Shader shader = new Shader();
		shader.Code = code;
		ShaderMaterial shaderMaterial = new ShaderMaterial();
		shaderMaterial.Shader = shader;
		shaderMaterial.RenderPriority = 1;
		return shaderMaterial;
	}
	public static ShaderMaterial MirrorShader(string shaderName)
	{
		QShaderData qShader;
		if (!QShaders.TryGetValue(shaderName, out qShader))
			qShader = null;

		string code = "shader_type spatial;\nrender_mode diffuse_lambert, specular_schlick_ggx, depth_draw_opaque, blend_mix, cull_back;\n\n";
		code += "uniform sampler2D Tex_0 : repeat_enable;\n";
		code += "uniform float InvertX : hint_range(0, 1) = 1.0;\n";
		code += "uniform float InvertY : hint_range(0, 1) = 1.0;\n";
		code += "global uniform float MsTime;\n";
		code += "global uniform vec4 AmbientColor: source_color;\n";
		code += "global uniform float mixBrightness;\n";
		code += "instance uniform float OffSetTime = 0.0;\n";
		code += "const bool ViewModel = false;\n";
		code += "void vertex()\n{\n";
		code += "\tUV2.x = mix(UV2.x, 1.0 - UV2.x, InvertX);\n";
		code += "\tUV2.y = mix(UV2.y, 1.0 - UV2.y, InvertY);\n";
		if (qShader != null)
			code += GetVertex(qShader, false, false, qShader.qShaderGlobal.polygonOffset);
		code += "}\nvoid fragment()\n{\n\tvec2 uv_0 = UV2;\n\tvec4 Stage_0 = texture(Tex_0, uv_0);\n";
		code += "\tvec4 ambient = AmbientColor * mixBrightness;\n";
		code += "\tvec4 vertx_color = COLOR;\n";
		code += "\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n";
		code += "\tcolor = Stage_0;\n";
		code += "\tALBEDO = (color.rgb * vertx_color.rgb);\n";
		code += "\tEMISSION = mix((ambient.rgb * color.rgb), color.rgb, mixBrightness);\n";
		code += "}\n\n";
		Shader shader = new Shader();
		shader.Code = code;
		ShaderMaterial shaderMaterial = new ShaderMaterial();
		shaderMaterial.Shader = shader;
		return shaderMaterial;
	}
	public static string GetDiffuseLightning()
	{
		string DiffuseLight;

		DiffuseLight = "\tfloat isLightDir = float(LIGHT_IS_DIRECTIONAL);\n";
		DiffuseLight += "\tfloat useLightVol = float(UseLightVol);\n";
		DiffuseLight += "\tfloat mul = mix(1.0, 0.4, useLightVol);\n";
		DiffuseLight += "\tDIFFUSE_LIGHT += ShadowIntensity * mul * vec3(ATTENUATION - 1.0) * isLightDir;\n";
		DiffuseLight += "\tDIFFUSE_LIGHT += clamp(dot(NORMAL, dirVector), 0.0, 1.0) * dirColor * isLightDir * useLightVol;\n";
		DiffuseLight += "\tDIFFUSE_LIGHT += clamp(dot(NORMAL, LIGHT), 0.0, 1.0) * ATTENUATION * LIGHT_COLOR * (1.0 - isLightDir);\n";

		return DiffuseLight;
	}

	public static string GetVertex(QShaderData qShader, bool useView, bool forceView, bool polygonOffSet, float Value = 0.001f)
	{
		string Vertex = "";

		//This is important as we added Billboard outside the shaders
		if (MaterialManager.HasBillBoard.Contains(qShader.Name))
		{
			switch (qShader.qShaderGlobal.billboard)
			{
				default:
					Vertex = "\tVERTEX = (vec4(VERTEX, 1.0) * MODELVIEW_MATRIX).xyz;\n";
				break;
				case QShaderGlobal.SpriteType.FixedY:
					Vertex = "\tivec2 alignment = ivec2(1,0);\n";
					Vertex += "\tvec3 local_up = MODEL_MATRIX[alignment.x].xyz;\n";
					Vertex += "\tvec4 ax = vec4(normalize(cross(local_up, INV_VIEW_MATRIX[2].xyz)), 0.0);\n";
					Vertex += "\tvec4 ay = vec4(local_up.xyz, 0.0);\n";
					Vertex += "\tvec4 az = vec4(normalize(cross(INV_VIEW_MATRIX[alignment.y].xyz, local_up)), 0.0);\n";
					Vertex += "\tMODELVIEW_MATRIX = VIEW_MATRIX * mat4(ax, ay, az, MODEL_MATRIX[3]);\n";
					Vertex += "\tMODELVIEW_NORMAL_MATRIX = mat3(MODELVIEW_MATRIX);\n";
				break;
			}
		}

		if (qShader.qShaderGlobal.deformVertexes == null)
		{
			if (useView)
			{
				Vertex += "\tfloat InvTanFOV = 1.0f / tan(0.5f * (ViewCameraFOV * PI / 180.0f));\n";
				Vertex += "\tfloat Aspect = VIEWPORT_SIZE.x / VIEWPORT_SIZE.y;\n";
				Vertex += "\tPROJECTION_MATRIX[1][1] = mix(PROJECTION_MATRIX[1][1], -InvTanFOV, float(ViewModel));\n";
				Vertex += "\tPROJECTION_MATRIX[0][0] = mix(PROJECTION_MATRIX[0][0], InvTanFOV / Aspect, float(ViewModel));\n";
			}
			else if (forceView)
			{
				Vertex += "\tfloat InvTanFOV = 1.0f / tan(0.5f * (ViewCameraFOV * PI / 180.0f));\n";
				Vertex += "\tfloat Aspect = VIEWPORT_SIZE.x / VIEWPORT_SIZE.y;\n";
				Vertex += "\tPROJECTION_MATRIX[1][1] = -InvTanFOV;\n";
				Vertex += "\tPROJECTION_MATRIX[0][0] =  InvTanFOV / Aspect;\n";
			}
			Vertex += "\tPOSITION = PROJECTION_MATRIX * MODELVIEW_MATRIX * vec4(VERTEX, 1.0);\n";
			if (polygonOffSet)
				Vertex += "\tPOSITION.z = mix(POSITION.z, 1.0, "+ Value.ToString("0.000") + ");\n";
			return Vertex;
		}

		Vertex += "\tfloat Time = (MsTime - OffSetTime);\n";
		string Vars = "";
		string Verts = "";
		for (int i = 0; i < qShader.qShaderGlobal.deformVertexes.Count; i++)
		{
			string[] VertexFunc = qShader.qShaderGlobal.deformVertexes[i];
			if (VertexFunc[0] == "WAVE")
			{
				float div = TryToParseFloat(VertexFunc[1]) * GameManager.sizeDividor;
				string DeformFunc = VertexFunc[2];
				float offset = TryToParseFloat(VertexFunc[3]);
				float amp = TryToParseFloat(VertexFunc[4]);
				float phase = TryToParseFloat(VertexFunc[5]);
				float freq = TryToParseFloat(VertexFunc[6]);

				if (div > 0)
					div = 1.0f / div;
				else
					div = 100 * GameManager.sizeDividor;

				Vars += "\tfloat OffSet_" + i + " = (VERTEX.x + VERTEX.y + VERTEX.z) * " + div.ToString("0.00") + ";\n";
				if (DeformFunc == "SIN")
				{
					Verts += "\tVERTEX += NORMAL * " + GameManager.sizeDividor.ToString("0.00") + " * (";
					Verts += offset.ToString("0.00") + " + sin(6.28 * " + freq.ToString("0.00") + " * (Time +" + phase.ToString("0.00") + " +  OffSet_" + i + "))  * " + amp.ToString("0.00") + "); \n";
				}
				else if (DeformFunc == "SQUARE")
				{
					Verts += "\tVERTEX += NORMAL * " + GameManager.sizeDividor.ToString("0.00") + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * round(fract(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + "))); \n";
				}
				else if (DeformFunc == "TRIANGLE")
				{

					Verts += "\tVERTEX += NORMAL * " + GameManager.sizeDividor.ToString("0.00") + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (abs(2.0 * (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + " - floor(0.5 + Time * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + "))))); \n";
				}
				else if (DeformFunc == "SAWTOOTH")
				{
					Verts += "\tVERTEX += NORMAL * " + GameManager.sizeDividor.ToString("0.00") + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + " - floor(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + "))); \n";
				}
				else if (DeformFunc == "INVERSESAWTOOTH")
				{
					Verts += "\tVERTEX += NORMAL * " + GameManager.sizeDividor.ToString("0.00") + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (1.0 - (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + " - floor(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " +  OffSet_" + i + ")))); \n";
				}
			}
			else if (VertexFunc[0] == "MOVE")
			{
				Vector3 move = new Vector3(-1.0f * TryToParseFloat(VertexFunc[1]), TryToParseFloat(VertexFunc[3]), TryToParseFloat(VertexFunc[2])) * GameManager.sizeDividor;
				string DeformFunc = VertexFunc[4];
				float offset = TryToParseFloat(VertexFunc[5]);
				float amp = TryToParseFloat(VertexFunc[6]);
				float phase = TryToParseFloat(VertexFunc[7]);
				float freq = TryToParseFloat(VertexFunc[8]);

				Vars += "\tvec3 OffSet_" + i + " = vec3(" + move.X.ToString("0.00") + ", " + move.Y.ToString("0.00") + ", " + move.Z.ToString("0.00") + ");\n";
				if (DeformFunc == "SIN")
				{
					Verts += "\tVERTEX += OffSet_" + i + " * (";
					Verts += offset.ToString("0.00") + " + sin(6.28 * " + freq.ToString("0.00") + " * (Time +" + phase.ToString("0.00") + "))  * " + amp.ToString("0.00") + "); \n";
				}
				else if (DeformFunc == "SQUARE")
				{
					Verts += "\tVERTEX += OffSet_" + i + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * round(fract(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + "))); \n";
				}
				else if (DeformFunc == "TRIANGLE")
				{
					Verts += "\tVERTEX += OffSet_" + i + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (abs(2.0 * (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " - floor(0.5 + Time * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + "))))); \n";
				}
				else if (DeformFunc == "SAWTOOTH")
				{

					Verts += "\tVERTEX += OffSet_" + i + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " - floor(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + "))); \n";
				}
				else if (DeformFunc == "INVERSESAWTOOTH")
				{
					Verts += "\tVERTEX += OffSet_" + i + " * (";
					Verts += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (1.0 - (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " - floor(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + ")))); \n";
				}
			}
		}
		Vertex += Vars;
		Vertex += Verts;
		if (useView)
		{
			Vertex += "\tfloat InvTanFOV = 1.0f / tan(0.5f * (ViewCameraFOV * PI / 180.0f));\n";
			Vertex += "\tfloat Aspect = VIEWPORT_SIZE.x / VIEWPORT_SIZE.y;\n";
			Vertex += "\tPROJECTION_MATRIX[1][1] = mix(PROJECTION_MATRIX[1][1], -InvTanFOV, float(ViewModel));\n";
			Vertex += "\tPROJECTION_MATRIX[0][0] = mix(PROJECTION_MATRIX[0][0], InvTanFOV / Aspect, float(ViewModel));\n";
		}
		else if (forceView)
		{
			Vertex += "\tfloat InvTanFOV = 1.0f / tan(0.5f * (ViewCameraFOV * PI / 180.0f));\n";
			Vertex += "\tfloat Aspect = VIEWPORT_SIZE.x / VIEWPORT_SIZE.y;\n";
			Vertex += "\tPROJECTION_MATRIX[1][1] = -InvTanFOV;\n";
			Vertex += "\tPROJECTION_MATRIX[0][0] =  InvTanFOV / Aspect;\n";
		}
		Vertex += "\tPOSITION = PROJECTION_MATRIX * MODELVIEW_MATRIX * vec4(VERTEX, 1.0);\n";
		if (polygonOffSet)
			Vertex += "\tPOSITION.z = mix(POSITION.z, 1.0, "+ Value.ToString("0.000") + ");\n";
		return Vertex;
	}
	public static string GetUVGen(QShaderData qShader, int currentStage, ref string GSVaryings)
	{
		string UVGen = "";
		if (qShader.qShaderStages[currentStage].environment)
		{
			GSVaryings += "varying vec2 UV_" + currentStage + ";\n";
			UVGen = "\tvec3 viewer_" + currentStage + " = normalize((MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz - CAMERA_POSITION_WORLD);\n";
			UVGen += "\tvec3 normal_" + currentStage + " = normalize(MODEL_NORMAL_MATRIX * NORMAL);\n";
			UVGen += "\tvec3 reflect_" + currentStage + " = reflect(viewer_" + currentStage + ", normal_" + currentStage + ");\n";
			UVGen += "\tUV_" + currentStage + " = reflect_" + currentStage + ".yz;\n";
		}
		return UVGen;
	}
		
	public static string GetTcGen(QShaderData qShader, int currentStage, ref int lightmapStage)
	{
		string TcGen = "";

		if (qShader.qShaderGlobal.skyParms != null)
		{
			if (qShader.qShaderGlobal.skyParms[0] == "-")
			{
//				int cloudheight = int.Parse(qShader.qShaderGlobal.skyParms[1]) / 5;
				TcGen += "\tvec4 vot" + currentStage + " = INV_VIEW_MATRIX * vec4(VERTEX, 0.0);\n";
				TcGen += "\tvot" + currentStage + ".y = 5.0 * (vot" + currentStage + ".y);\n";
				TcGen += "\tvot" + currentStage + " = normalize(vot" + currentStage + ");\n";
				TcGen += "\tvec2 uv_" + currentStage + " = vec2(vot" + currentStage + ".x, vot" + currentStage + ".z);\n";
			}
			else
			{
				if (currentStage == 0)
				{
					TcGen += "\tvec4 vot" + currentStage + " = INV_VIEW_MATRIX * vec4(VERTEX, 0.0);\n";
					TcGen += "\tvec4 sky_vol" + currentStage + " = vot" + currentStage + ";\n";
					TcGen += "\tsky_vol" + currentStage + ".y = 5.0 * (vot" + currentStage + ".y);\n";
					TcGen += "\tsky_vol" + currentStage + " = normalize(sky_vol" + currentStage + ");\n";
					TcGen += "\tvot" + currentStage + " = normalize(vot" + currentStage + ");\n";
					TcGen += "\tvec2 uv_" + currentStage + " = vec2(sky_vol" + currentStage + ".x, sky_vol" + currentStage + ".z);\n";
				}
				else
					TcGen += "\tvec2 uv_" + currentStage + " = uv_0;\n";
			}
		}
		else
		{
			if (qShader.qShaderStages[currentStage].environment)
			{
				TcGen += "\tvec2 uv_" + currentStage + ";\n";
				TcGen += "\tuv_" + currentStage + ".x = 0.5 + UV_" + currentStage + ".y * 0.5;\n";
				TcGen += "\tuv_" + currentStage + ".y = 0.5 - UV_" + currentStage + ".x * 0.5;\n";
			}
			else if (qShader.qShaderStages[currentStage].map != null)
			{
				if (qShader.qShaderStages[currentStage].isLightmap)
				{
					lightmapStage = currentStage;
					TcGen = "\tvec2 uv_" + currentStage + " = UV2;\n";
				}
				else
					TcGen = "\tvec2 uv_" + currentStage + " = UV;\n";
			}
			else
				TcGen = "\tvec2 uv_" + currentStage + " = UV;\n";
		}

		return TcGen;
	}

	public static string GetTcMod(QShaderData qShader, int currentStage, ref bool helperRotate)
	{
		string TcMod = "";

		if (qShader.qShaderStages[currentStage].tcMod == null)
			return TcMod;

		for (int i = 0; i < qShader.qShaderStages[currentStage].tcMod.Count; i++)
		{
			QShaderStage.QShaderTCMod shaderTCMod = qShader.qShaderStages[currentStage].tcMod[i];

			switch(shaderTCMod.type)
			{
				case QShaderStage.TCModType.Rotate:
				{
					if (helperRotate == false)
						helperRotate = true;
					float deg = TryToParseFloat(shaderTCMod.value[0]);
					TcMod += "\tuv_" + currentStage + " = rotate(uv_" + currentStage + ", vec2(0.5), radians(" + deg.ToString("0.00") + ") * Time*0.5);\n";
				}
				break;
				case QShaderStage.TCModType.Scale:
				{
					float SScale = TryToParseFloat(shaderTCMod.value[0]);
					float TScale = TryToParseFloat(shaderTCMod.value[1]);
					TcMod += "\tuv_" + currentStage + " *= vec2(" + SScale.ToString("0.00") + "," + TScale.ToString("0.00") + "); \n";
				}
				break;
				case QShaderStage.TCModType.Scroll:
				{
					float SSpeed = TryToParseFloat(shaderTCMod.value[0]);
					float TSpeed = TryToParseFloat(shaderTCMod.value[1]);
					TcMod += "\tuv_" + currentStage + " += vec2(" + SSpeed.ToString("0.00") + "," + TSpeed.ToString("0.00") + ") * Time*0.5; \n";
				}
				break;
				case QShaderStage.TCModType.Stretch:
				{
					string func = shaderTCMod.value[0];
					float basis = TryToParseFloat(shaderTCMod.value[1]);
					float amp = TryToParseFloat(shaderTCMod.value[2]);
					float phase = TryToParseFloat(shaderTCMod.value[3]);
					float freq = TryToParseFloat(shaderTCMod.value[4]);
					TcMod += "\tfloat str_" + currentStage + " = 1.0 / (" + basis.ToString("0.00") + " + " + amp.ToString("0.00") + " * (sin((Time)*" + freq.ToString("0.00") + "*6.28)+" + phase.ToString("0.00") + "));\n";
					TcMod += "\tuv_" + currentStage + "  = uv_" + currentStage + " *(str_" + currentStage + ") - vec2(1.0,1.0)*str_" + currentStage + "*0.5 + vec2(0.5,0.5);\n";
				}
				break;
				case QShaderStage.TCModType.Transform:
				{
					float M00 = TryToParseFloat(shaderTCMod.value[0]);
					float M01 = TryToParseFloat(shaderTCMod.value[1]);
					float M10 = TryToParseFloat(shaderTCMod.value[2]);
					float M11 = TryToParseFloat(shaderTCMod.value[3]);
					float T0 = TryToParseFloat(shaderTCMod.value[4]);
					float T1 = TryToParseFloat(shaderTCMod.value[5]);
					if (qShader.qShaderGlobal.skyParms != null)
					{
						T0 *= 5;
						T1 *= 5;
					}
					string transX = "(uv_" + currentStage + ".x * " + M00.ToString("0.00") + " + uv_" + currentStage + ".y * " + M10.ToString("0.00") + " + " + T0.ToString("0.00") + ")";
					string transY = "(uv_" + currentStage + ".x * " + M01.ToString("0.00") + " + uv_" + currentStage + ".y * " + M11.ToString("0.00") + " + " + T1.ToString("0.00") + ")";
					TcMod += "\tuv_" + currentStage + " = vec2(" + transX + "," + transY + "); \n";
				}
				break;
				case QShaderStage.TCModType.Turb:
				{
//					float basis = TryToParseFloat(shaderTCMod.value[0]);
					float amp = TryToParseFloat(shaderTCMod.value[1]);
					float phase = TryToParseFloat(shaderTCMod.value[2]);
					float freq = TryToParseFloat(shaderTCMod.value[3]);
					string turbX = "(sin( (2.0 *" + freq.ToString("0.00") + ") * (Time * 6.28) + " + phase.ToString("0.00") + ") * " + amp.ToString("0.00") + " )";
					string turbY = "(cos( (2.0 *" + freq.ToString("0.00") + ") * (Time * 6.28) + " + phase.ToString("0.00") + ") * " + amp.ToString("0.00") + " )";
					TcMod += "\tuv_" + currentStage + " += vec2(" + turbX + "," + turbY + "); \n";
				}
				break;
			}
		}
		return TcMod;
	}

	public static string GetGenFunc(QShaderData qShader, int currentStage, GenFuncType type, ref bool entityColor)
	{
		string GenType = ".rgb";
		string[] GenFunc = qShader.qShaderStages[currentStage].rgbGen;
		
		if (type == GenFuncType.Alpha)
		{
			GenType = ".a";
			GenFunc = qShader.qShaderStages[currentStage].alphaGen;
		}

		string StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType +" * 1.0 ; \n";
		if (GenFunc == null)
			return StageGen;

		if (GenFunc[0] == "WAVE")
		{
			string RGBFunc = GenFunc[1];
			float offset = TryToParseFloat(GenFunc[2]);
			float amp = TryToParseFloat(GenFunc[3]);
			float phase = TryToParseFloat(GenFunc[4]);
			float freq = TryToParseFloat(GenFunc[5]);
			if (RGBFunc == "SIN")
			{
				StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType + " * (";
				StageGen += offset.ToString("0.00") + " + sin(6.28 * " + freq.ToString("0.00") + " * (Time +" + phase.ToString("0.00") + "))  * " + amp.ToString("0.00") + "); \n";
			}
			else if (RGBFunc == "SQUARE")
			{
				StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType + " * (";
				StageGen += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * round(fract(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + "))); \n";
			}
			else if (RGBFunc == "TRIANGLE")
			{
				StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType + " * (";
				StageGen += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (abs(2.0 * (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " - floor(0.5 + Time * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + "))))); \n";
			}
			else if (RGBFunc == "SAWTOOTH")
			{
				StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType + " * (";
				StageGen += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " - floor(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + "))); \n";
			}
			else if (RGBFunc == "INVERSESAWTOOTH")
			{
				StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType + " * (";
				StageGen += offset.ToString("0.00") + " + " + amp.ToString("0.00") + " * (1.0 - (Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + " - floor(Time  * " + freq.ToString("0.00") + " + " + phase.ToString("0.00") + ")))); \n";
			}
		}
		else if (GenFunc.Length > 0)
		{
			string Func = GenFunc[0];
			if (Func == "VERTEX")
			{
				if (type == GenFuncType.RGB)
					StageGen = "\tStage_" + currentStage + ".rgb = Stage_" + currentStage + ".rgb * vertx_color.rgb; \n";
				else
					StageGen = "\tStage_" + currentStage + ".a = vertx_color.a; \n";
			}
			else if (Func == "ENTITY")
			{
				StageGen = "\tStage_" + currentStage + GenType + " = Stage_" + currentStage + GenType + " * modulate" + GenType + " ; \n";
				entityColor = true;
			}
			if (Func == "CONST")
			{
				if (type == GenFuncType.RGB)
				{
					float r = TryToParseFloat(GenFunc[2]);
					float g = TryToParseFloat(GenFunc[3]);
					float b = TryToParseFloat(GenFunc[4]);
					StageGen = "\tvec3 ColorGen_" + currentStage + " = vec3(" + r.ToString("0.00") + ", " + g.ToString("0.00") + ", " + b.ToString("0.00") + ");\n";
					StageGen += "\tStage_" + currentStage + ".rgb = Stage_" + currentStage + ".rgb * ColorGen_" + currentStage + ";\n";
				}
				else
				{
					float a = TryToParseFloat(GenFunc[1]);
					StageGen = "\tStage_" + currentStage + ".a = " + a.ToString("0.00") + "; \n";
				}
			}
		}
		return StageGen;
	}

	public static string GetAlphaFunc(QShaderData qShader, int currentStage, List<int> multiPassList, ref int needMultiPass)
	{
		string AlphaFunc = "";
		if (qShader.qShaderStages[currentStage].alphaFunc == QShaderStage.AlphaFuncType.NONE)
			return AlphaFunc;

		int fistStage = 0;
		if (multiPassList != null)
			fistStage = multiPassList[0];
		if (currentStage != fistStage)
		{
			needMultiPass = currentStage;
			return AlphaFunc;
		}


		AlphaFunc = "\tif (Stage_" + currentStage + ".a ";		
		switch (qShader.qShaderStages[currentStage].alphaFunc)
		{
			case QShaderStage.AlphaFuncType.GT0:
				AlphaFunc += "== 0.0)\n";
			break;
			case QShaderStage.AlphaFuncType.LT128:
				AlphaFunc += ">= 0.5)\n";
			break;
			case QShaderStage.AlphaFuncType.GE128:
				AlphaFunc += "< 0.5)\n";
			break;
		}
		AlphaFunc += "\t{\n\t\tdiscard;\n\t}\n";

		return AlphaFunc;
	}
	public static string GetBlend(QShaderData qShader, int currentStage, int numStage, List<int> multiPassList, ref int needMultiPass, ref bool alphaIsTransparent)
	{
		string Blend = "";
		if (qShader.qShaderStages[currentStage].blendFunc != null)
		{
			int firstStage = 0;
			if (multiPassList != null)
				firstStage = multiPassList[0];

			string BlendWhat = qShader.qShaderStages[currentStage].blendFunc[0];
			if (BlendWhat == "ADD")
			{
				Blend = "\tcolor = Stage_" + currentStage + " + color; \n";
				if (currentStage == firstStage)
					qShader.qShaderGlobal.sort = QShaderGlobal.SortType.Additive;
			}
			else if (BlendWhat == "FILTER")
			{

				Blend = "\tcolor = Stage_" + currentStage + " * color; \n";
				if (currentStage == firstStage)
				{
					Blend = "\tcolor = Stage_" + currentStage + "; \n";
					qShader.qShaderGlobal.sort = QShaderGlobal.SortType.Additive;
				}
			}
			else if (BlendWhat == "BLEND")
			{
				Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * Stage_" + currentStage + ".a + color.rgb * (1.0 - Stage_" + currentStage + ".a); \n";
				Blend += "\tcolor.a = Stage_" + currentStage + ".a *   Stage_" + currentStage + ".a + color.a *  (1.0 -  Stage_" + currentStage + ".a); \n";
				if (currentStage == firstStage)
				{
					if (firstStage == 0)
					{
						Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * Stage_" + currentStage + ".a + color.rgb * (1.0 - Stage_" + currentStage + ".a); \n";
						Blend += "\tcolor.a = Stage_" + currentStage + ".a *   Stage_" + currentStage + ".a;\n";
					}
					else
						Blend = "\tcolor = Stage_" + currentStage + ";\n";
					alphaIsTransparent = true;
				}
			}
			else
			{
				string src = qShader.qShaderStages[currentStage].blendFunc[0];
				string dst = qShader.qShaderStages[currentStage].blendFunc[1];
				string asrc = "";
				string adst = "";
				string csrc = "";
				string cdst = "";

				//SOURCE
				if (src == "GL_ONE")
				{
					csrc = " 1.0 ";
					asrc = " 1.0 ";
				}
				else if (src == "GL_ZERO")
				{
					csrc = " 0.0 ";
					asrc = " 0.0 ";
				}
				else if (src == "GL_DST_COLOR")
				{
					csrc = " color.rgb ";
					asrc = " color.a ";
				}
				else if (src == "GL_ONE_MINUS_DST_COLOR")
				{
					csrc = " 1.0 - color.rgb ";
					asrc = " 1.0 - color.a ";
				}
				else if (src == "GL_SRC_ALPHA")
				{
					csrc = "  Stage_" + currentStage + ".a ";
					asrc = "  Stage_" + currentStage + ".a ";
				}
				else if (src == "GL_ONE_MINUS_SRC_ALPHA")
				{
					csrc = " (1.0 -  Stage_" + currentStage + ".a) ";
					asrc = " (1.0 -  Stage_" + currentStage + ".a) ";
				}
				else if (src == "GL_DST_ALPHA")
				{
					csrc = " color.a ";
					asrc = " color.a ";
				}
				else if (src == "GL_ONE_MINUS_DST_ALPHA")
				{
					csrc = " (1.0 - color.a) ";
					asrc = " (1.0 - color.a) ";
				}

				//DEST
				if (dst == "GL_ONE")
				{
					cdst = " 1.0 ";
					adst = " 1.0 ";
					if (currentStage == firstStage)
						qShader.qShaderGlobal.sort = QShaderGlobal.SortType.Additive;
				}
				else if (dst == "GL_ZERO")
				{
					cdst = " 0.0 ";
					adst = " 0.0 ";
				}
				else if (dst == "GL_SRC_COLOR")
				{
					cdst = " Stage_" + currentStage + ".rgb ";
					adst = " Stage_" + currentStage + ".a ";
				}
				else if (dst == "GL_ONE_MINUS_SRC_COLOR")
				{
					cdst = " (1.0 - Stage_" + currentStage + ".rgb) ";
					adst = " (1.0 - Stage_" + currentStage + ".a) ";
				}
				else if (dst == "GL_DST_ALPHA")
				{
					cdst = " color.a ";
					adst = " color.a ";
				}
				else if (dst == "GL_ONE_MINUS_DST_ALPHA")
				{
					cdst = " (1.0 - color.a) ";
					adst = " (1.0 - color.a) ";
				}
				else if (dst == "GL_SRC_ALPHA")
				{
					cdst = "  Stage_" + currentStage + ".a ";
					adst = "  Stage_" + currentStage + ".a ";
				}
				else if (dst == "GL_ONE_MINUS_SRC_ALPHA")
				{
					cdst = " (1.0 -  Stage_" + currentStage + ".a) ";
					adst = " (1.0 -  Stage_" + currentStage + ".a) ";
				}

				//Check FirstStage
				if (currentStage == firstStage)
				{
					if (src == "GL_ZERO")
					{
						if (dst == "GL_SRC_COLOR")
						{
							Blend = "\tcolor = Stage_" + currentStage + "; \n";
							qShader.qShaderGlobal.sort = QShaderGlobal.SortType.Additive;
						}
						else if (dst == "GL_ONE_MINUS_SRC_COLOR")
						{
							Blend = "\tcolor.rgb = " + cdst + ";\n";
							qShader.qShaderGlobal.sort = QShaderGlobal.SortType.Multiplicative;
						}
						else
						{
							Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * " + csrc + " + color.rgb * " + cdst + ";\n";
							Blend += "\tcolor.a = Stage_" + currentStage + ".a * " + asrc + " + color.a * " + adst + ";\n";
						}
					}
					else if (src == "GL_DST_COLOR")
					{
						{
							if (dst == "GL_ZERO")
							{
								Blend = "\tcolor = Stage_" + currentStage + "; \n";
								qShader.qShaderGlobal.sort = QShaderGlobal.SortType.Additive;
							}
							else
							{
								Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * " + csrc + " + color.rgb * " + cdst + ";\n";
								Blend += "\tcolor.a = Stage_" + currentStage + ".a * " + asrc + " + color.a * " + adst + ";\n";
							}
						}
					}
					else if (src == "GL_SRC_ALPHA")
					{
						if (dst == "GL_ONE_MINUS_SRC_ALPHA")
						{
							if (firstStage == 0)
							{
								Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * Stage_" + currentStage + ".a + color.rgb * (1.0 - Stage_" + currentStage + ".a); \n";
								Blend += "\tcolor.a = Stage_" + currentStage + ".a *   Stage_" + currentStage + ".a;\n";
							}
							else
								Blend = "\tcolor = Stage_" + currentStage + ";\n";
							alphaIsTransparent = true;
						}
						else
						{
							Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * " + csrc + " + color.rgb * " + cdst + ";\n";
							Blend += "\tcolor.a = Stage_" + currentStage + ".a * " + asrc + " + color.a * " + adst + ";\n";
						}
					}
					else
					{
						Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * " + csrc + " + color.rgb * " + cdst + ";\n";
						Blend += "\tcolor.a = Stage_" + currentStage + ".a * " + asrc + " + color.a * " + adst + ";\n";
					}
				}
				else
				{
					Blend = "\tcolor.rgb = Stage_" + currentStage + ".rgb * " + csrc + " + color.rgb * " + cdst + ";\n";
					Blend += "\tcolor.a = Stage_" + currentStage + ".a * " + asrc + " + color.a * " + adst + ";\n";
				}
			}
		}
		else
		{
			if (numStage != 0)
				needMultiPass = currentStage;
			Blend = "\tcolor = Stage_" + currentStage + ";\n";
		}

		Blend += "\tcolor = clamp(color,black,white);\n";
		return Blend;
	}

	public static void ReadShaderData(byte[] shaderData)
	{
		MemoryStream ms = new MemoryStream(shaderData);
		ReadShaderData(ms);
		ms.Close();
	}

	public static void ReadShaderData(Stream ms)
	{
		StreamReader stream = new StreamReader(ms);
		string strWord;
		char[] line = new char[1024];

		int p;
		int stage = 0;
		int node = 0;

		QShaderData qShaderData = null;
		while (!stream.EndOfStream)
		{
			strWord = stream.ReadLine();
			if (string.IsNullOrEmpty(strWord))
				continue;

			p = 0;
			for (int i = 0; i < strWord.Length; i++)
			{
				char c = strWord[i];
				switch (c)
				{
					default:
						line[p++] = c;
					break;
					case '{':
					{
						p = 0;
						node++;
						if (node == 2)
							stage++;
					}
					break;
					case '}':
					{
						p = 0;
						node--;
						if (node == 0)
						{
							if (qShaderData.qShaderGlobal.isFog)
							{
								if (FogShaders.ContainsKey(qShaderData.Name))
								{
//									GameManager.Print("Fog Shader already on the list: " + qShaderData.Name, GameManager.PrintType.Info);
									FogShaders[qShaderData.Name] = qShaderData;
								}
								else
									FogShaders.Add(qShaderData.Name, qShaderData);
								MaterialManager.AddFog(qShaderData.Name);
							}
							else
							{
								if (qShaderData.qShaderGlobal.skyParms != null)
								{
									if (qShaderData.qShaderGlobal.skyParms[0] != "-")
									{
										GameManager.Print("ADDING SKY: "+ qShaderData.qShaderGlobal.skyParms[0] + " TO SHADER: " + qShaderData.Name);
										qShaderData.AddFirstStage("SKYMAP", qShaderData.qShaderGlobal.skyParms[0]);										}
									}
								if (QShaders.ContainsKey(qShaderData.Name))
								{
//									GameManager.Print("Shader already on the list: " + qShaderData.Name, GameManager.PrintType.Info);
									QShaders[qShaderData.Name] = qShaderData;
								}
								else
									QShaders.Add(qShaderData.Name, qShaderData);
								if (qShaderData.qShaderGlobal.billboard != QShaderGlobal.SpriteType.Disabled)
									MaterialManager.AddBillBoard(qShaderData.Name);
								if (qShaderData.qShaderGlobal.portal)
									MaterialManager.AddPortalMaterial(qShaderData.Name);
							}
							qShaderData = null;
							stage = 0;
						}
						i = strWord.Length;
					}
					break;
					case '\t':
						if (p > 0)
							line[p++] = ' ';
					break;
					case ' ':
						if (p > 0)
							line[p++] = c;
					break;
					case '/':
					{
						int next = i + 1;
						if (next < strWord.Length)
						{
							if (strWord[next] == '/')
								i = strWord.Length;
							else
								line[p++] = c;
						}
						else
							line[p++] = c;
					}
					break;
				}
			}

			if (p == 0)
				continue;

			line[p] = '\0';
			strWord = new string(line, 0 , p);
			
			if (strWord.Length == 0)
				continue;

			strWord = strWord.ToUpper();

			if (qShaderData == null)
			{
				if (node == 0)
				{
					qShaderData = new QShaderData();
					qShaderData.Name = strWord.Trim(' ');
				}
				continue;
			}

			string[] keyValue = strWord.Split(' ' , 2);

			if (keyValue.Length < 2)
				keyValue = new string[2] { keyValue[0], "" };

			if (keyValue.Length == 2)
			{
				//Sanitizing extra spaces 
				p = 0;
				for (int i = 0; i < keyValue[1].Length; i++)
				{
					char c = keyValue[1][i];
					switch (c)
					{
						default:
							line[p++] = c;
						break;
						case ' ':
							if (p > 0)
							{
								if ((line[p - 1]) != ' ')
									line[p++] = c;
							}
						break;
					}
				}
				if ((p > 0) && ((line[p - 1]) == ' '))
					p--;

				line[p] = '\0';
				keyValue[1] = new string(line, 0, p);

				if (keyValue[0].Length > 0)
				{
					if (node == 1)
						qShaderData.AddGlobal(keyValue[0], keyValue[1]);
					if (node == 2)
						qShaderData.AddStage(stage, keyValue[0], keyValue[1]);
				}
			}
		}
		stream.Close();
	}

	public static float TryToParseFloat(string Number)
	{
		int inum;
		float fNum;

		if (int.TryParse(Number, out inum))
			fNum = inum;
		else
			fNum = float.Parse(Number);
		return fNum;
	}
}

public class QShaderData
{
	public string Name;
	public QShaderGlobal qShaderGlobal = new QShaderGlobal();
	public List<QShaderStage> qShaderStages = new List<QShaderStage>();

	public void AddGlobal(string Params, string Value)
	{
		qShaderGlobal.AddGlobal(Params, Value);
	}

	public void AddFirstStage(string Params, string Value)
	{
		QShaderStage qShaderStage;
		qShaderStage = new QShaderStage();
		qShaderStage.AddStageParams(Params, Value);
		if (qShaderStages.Count == 0)
			qShaderStages.Add(qShaderStage);
		else
		{
			List<QShaderStage> shaderStages = new List<QShaderStage>()
			{
				qShaderStage
			};
			shaderStages.AddRange(qShaderStages);
			qShaderStages = shaderStages;
		}
	}

	public void AddStage(int currentStage, string Params, string Value)
	{
		QShaderStage qShaderStage;
		if (qShaderStages.Count < currentStage)
		{
			qShaderStage = new QShaderStage();
			qShaderStage.AddStageParams(Params, Value);
			qShaderStages.Add(qShaderStage);
		}
		else
		{
			qShaderStage = qShaderStages[currentStage-1];
			qShaderStage.AddStageParams(Params, Value);
		}
	}
}

public class QShaderGlobal
{
	public List<string> surfaceParms = null;
	public List<string> skyParms = null;
	public List<string[]> deformVertexes = null;
	public string[] fogParms = null;
	public SortType sort = SortType.Opaque;
	public string[] sunParams = null;
	public List<string> tessSize = null;
	public List<string> q3map_BackShader = null;
	public List<string> q3map_GlobalTexture = null;
	public List<string> q3map_SurfaceLight = null;
	public List<string> q3map_LightImage = null;
	public List<string> q3map_LightSubdivide = null;
	public string editorImage = "";
	public CullType cullType = CullType.Back;
	public SpriteType billboard = SpriteType.Disabled;
	public bool isSky = false;
	public bool isFog = false;
	public bool unShaded = false;
	public bool trans = false;
	public bool lava = false;
	public bool water = false;
	public bool noPicMip = false;
	public bool portal = false;
	public bool noMipMap = false;
	public bool polygonOffset = false;

	public enum SpriteType
	{
		Disabled,
		FixedY,
		Enabled
	}
	public enum CullType
	{
		Back,
		Front,
		Disable
	}
	public enum SortType
	{
		Opaque,
		Additive,
		Multiplicative
	}
	public void AddGlobal(string Params, string Value)
	{
		if (Params == "SURFACEPARM")
		{
			if (surfaceParms == null)
				surfaceParms = new List<string>();
			surfaceParms.Add(Value);
			if (Value == "TRANS")
			{
				if (!lava)
					trans = true;
			}
			else if (Value == "NODLIGHT")
				unShaded = true;
			else if (Value == "SKY")
				isSky = true;
			else if (Value == "LAVA")
			{
				lava = true;
				if (trans)
					trans = false;
			}
			else if (Value == "WATER")
				water = true;
		}
		else if (Params == "SKYPARMS")
		{
//			Some shader overwrite their first skyparams as those are invalid
//			if (skyParms == null)
				skyParms = new List<string>();
			skyParms.AddRange(Value.Split(' '));
			if ((skyParms[0] == "FULL") || (skyParms[0] == "HALF"))
				skyParms[0] = "-";
		}
		else if (Params == "CULL")
		{
			if (Value == "FRONT")
				cullType = CullType.Back;
			else if (Value == "BACK")
				cullType = CullType.Front;
			else
				cullType = CullType.Disable;
		}
		else if (Params == "DEFORMVERTEXES")
		{
			if (Value.Contains("AUTOSPRITE"))
			{
				if (Value.Contains('2'))
					billboard = SpriteType.FixedY;
				else
					billboard = SpriteType.Enabled;
			}
			else
			{
				if (deformVertexes == null)
					deformVertexes = new List<string[]>();
				deformVertexes.Add(Value.Split(' '));
			}
		}
		else if (Params == "FOGPARMS")
		{
			fogParms = Value.Split(' ');
			isFog = true;
		}
		else if (Params == "SORT")
		{
			if (Value == "ADDITIVE")
				sort = SortType.Additive;
			else
				sort = SortType.Opaque;
		}
		else if (Params == "TESSSIZE")
		{
			if (tessSize == null)
				tessSize = new List<string>();
			tessSize.Add(Value);
		}
		else if (Params == "Q3MAP_BACKSHADER")
		{
			if (q3map_BackShader == null)
				q3map_BackShader = new List<string>();
			q3map_BackShader.Add(Value);
		}
		else if (Params == "Q3MAP_GLOBALTEXTURE")
		{
			if (q3map_GlobalTexture == null)
				q3map_GlobalTexture = new List<string>();
			q3map_GlobalTexture.Add(Value);
		}
		else if (Params == "Q3MAP_SUN")
		{
			if (sunParams == null)
				sunParams = Value.Split(' ');
		}
		else if (Params == "Q3MAP_SURFACELIGHT")
		{
			if (q3map_SurfaceLight == null)
				q3map_SurfaceLight = new List<string>();
			q3map_SurfaceLight.Add(Value);
		}
		else if (Params == "Q3MAP_LIGHTIMAGE")
		{
			if (q3map_LightImage == null)
				q3map_LightImage = new List<string>();
			q3map_LightImage.Add(Value);
		}
		else if (Params == "Q3MAP_LIGHTSUBDIVIDE")
		{
			if (q3map_LightSubdivide == null)
				q3map_LightSubdivide = new List<string>();
			q3map_LightSubdivide.Add(Value);
		}
		else if (Params == "NOPICMIP")
			noPicMip = true;
		else if (Params == "NOMIPMAP")
			noMipMap = true;
		else if (Params == "POLYGONOFFSET")
			polygonOffset = true;
		else if (Params == "PORTAL")
			portal = true;
		else if (Params == "QER_EDITORIMAGE")
			editorImage = Value.StripExtension().ToUpper();
	}
}
public class QShaderStage
{
	public string[] map = null;
	public bool clamp = false;
	public bool isLightmap = false;
	public float animFreq = 0;
	public bool skyMap = false;
	public string[] blendFunc = null;
	public string[] rgbGen = null;
	public string[] alphaGen = null;
	public string[] tcGen = null;
	public List<QShaderTCMod> tcMod = null;
	public DepthFuncType depthFunc = DepthFuncType.LEQUAL;
	public bool depthWrite = false;
	public bool environment = false;
	public AlphaFuncType alphaFunc = AlphaFuncType.NONE;

	public void AddStageParams(string Params, string Value)
	{
		if (Params == "MAP")
		{
			map = new string[1] { Value.StripExtension() };
			if (map[0].Contains("$LIGHTMAP"))
				isLightmap = true;
		}
		else if (Params == "CLAMPMAP")
		{
			clamp = true;
			map = new string[1] { Value.StripExtension() };
		}
		else if (Params == "ANIMMAP")
		{
			string[] keyValue = Value.Split(' ');
			animFreq = QShaderManager.TryToParseFloat(keyValue[0]);
			map = new string[keyValue.Length - 1];
			for (int i = 1; i < keyValue.Length; i++)
				map[i - 1] = keyValue[i].StripExtension();
		}
		else if (Params == "SKYMAP")
		{
			skyMap = true;
			map = new string[1] { Value.StripExtension() };
		}
		else if (Params == "BLENDFUNC")
		{
			if (blendFunc == null)
				blendFunc = Value.Split(' ');
		}
		else if (Params == "RGBGEN")
		{
			if (rgbGen == null)
				rgbGen = Value.Split(' ');
		}
		else if (Params == "ALPHAGEN")
		{
			if (alphaGen == null)
				alphaGen = Value.Split(' ');
		}
		else if (Params == "TCGEN")
		{
			if (tcGen == null)
				tcGen = Value.Split(' ');

			if (Value == "ENVIRONMENT")
				environment = true;
		}
		else if (Params == "TCMOD")
		{
			string[] keyValue = Value.Split(' ', 2);
			if (keyValue.Length == 2)
			{
				if (tcMod == null)
					tcMod = new List<QShaderTCMod>();
				QShaderTCMod shaderTCMod = new QShaderTCMod();
				string func = keyValue[0];
				if (func == "ROTATE")
					shaderTCMod.type = TCModType.Rotate;
				else if (func == "SCALE")
					shaderTCMod.type = TCModType.Scale;
				else if (func == "SCROLL")
					shaderTCMod.type = TCModType.Scroll;
				else if (func == "STRETCH")
					shaderTCMod.type = TCModType.Stretch;
				else if (func == "TRANSFORM")
					shaderTCMod.type = TCModType.Transform;
				else if (func == "TURB")
					shaderTCMod.type = TCModType.Turb;
				shaderTCMod.value = keyValue[1].Split(' ');
				tcMod.Add(shaderTCMod);
			}
		}
		else if (Params == "DEPTHFUNC")
		{
			if (Value == "LEQUAL")
				depthFunc = DepthFuncType.LEQUAL;
			else if (Value == "EQUAL")
				depthFunc = DepthFuncType.EQUAL;
		}
		else if (Params == "DEPTHWRITE")
			depthWrite = true;
		else if (Params == "ALPHAFUNC")
		{
			if (Value == "GT0")
				alphaFunc = AlphaFuncType.GT0;
			else if (Value == "LT128")
				alphaFunc = AlphaFuncType.LT128;
			else if (Value == "GE128")
				alphaFunc = AlphaFuncType.GE128;
		}
	}
	public class QShaderTCMod
	{
		public TCModType type;
		public string[] value = null;
	}
	public enum TCModType
	{
		Rotate,
		Scale,
		Scroll,
		Stretch,
		Transform,
		Turb
	}
	public enum AlphaFuncType
	{
		NONE,
		GT0,
		LT128,
		GE128
	}
	public enum DepthFuncType
	{
		LEQUAL,
		EQUAL
	}
	
}

```

./Assets/Scripts/Managers/PakManager.cs:
```
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;
using Microsoft.Win32;
using ExtensionMethods;

public static class PakManager
{
	public static Dictionary<string, string> ZipFiles = new Dictionary<string, string>();
	public static Dictionary<string, FileStream> QuakeFiles = new Dictionary<string, FileStream>();
	private static Dictionary<string, ZipArchive> OpenedZippedFiles = new Dictionary<string, ZipArchive>();
	private static List<FileStream> OpenedPK3Files = new List<FileStream>();
	public static Dictionary<string, int> EntryByIndex = new Dictionary<string, int>();

	public static List<string> mapList = new List<string>();
	public static List<string> playerModelList = new List<string>();
	public static List<string> playerSkinList = new List<string>();

	private const string pak0Demo = "0613b3d4ef05e613a2b470571498690f";		//pak0.pk3 QUAKE 3 DEMO
	private const string pak0Retail = "1197ca3df1e65f3c380f8abc10ca43bf";	//pak0.pk3 QUAKE 3
	private const string pak1Patch = "48911719d91be25adb957f2d325db4a0";	//pak1.pk3 QUAKE 3
	private const string pak2Patch = "d550ce896130c47166ca44b53f8a670a";	//pak2.pk3 QUAKE 3
	private const string pak3Patch = "968dfd0f30dad67056115c8e92344ddc";	//pak3.pk3 QUAKE 3
	private const string pak4Patch = "24bb1f4fcabd95f6e320c0e2f62f19ca";	//pak4.pk3 QUAKE 3
	private const string pak5Patch = "734dcd06d2cbc7a16432ff6697f1c5ba";	//pak5.pk3 QUAKE 3
	private const string pak6Patch = "873888a73055c023f6c38b8ca3f2ce05";	//pak6.pk3 QUAKE 3
	private const string pak7Patch = "8fd38c53ed814b64f6ab03b5290965e4";	//pak7.pk3 QUAKE 3
	private const string pak8Patch = "d8b96d429ca4a9c289071cb7e77e14d2";	//pak8.pk3 QUAKE 3
	private const string pak0TA = "e8ba9e3bf06210930bc0e7fdbcdd01c2";		//pak0.pk3 QUAKE 3 TEAM ARENA
	private const string pak00Live = "75aaae7c836b9ebdb1d4cfd53ba1c958";	//pak00.pk3 QUAKE LIVE

	private static readonly string[] basePaks = { pak0Demo, pak0Retail, pak1Patch, pak2Patch, pak3Patch, pak4Patch, pak5Patch, pak6Patch, pak7Patch, pak8Patch, pak0TA, pak00Live};
	public static GameManager.BasePak basePak = GameManager.BasePak.All;
	public static void LoadPK3Files()
	{
		string filePath;
		DirectoryInfo dir;
		FileInfo[] files;

		//Try to get Steam Pk3 First
		if (OperatingSystem.IsWindows())
		{
			string SteamPath = (string)Registry.GetValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Valve\\Steam", "InstallPath", null);
			if (SteamPath != null)
			{
				SteamPath = SteamPath.Replace("\\", "/");
				//Check Quake Live
				if (File.Exists(SteamPath + "/steamapps/appmanifest_282440.acf"))
				{
					filePath = SteamPath + "/steamapps/common/Quake Live/baseq3/";
					GameManager.Print("Open Directory " + filePath);
					dir = new DirectoryInfo(filePath);
					if (dir.Exists)
					{
						files = dir.GetFiles("*.pk3");
						CheckPK3Files(filePath, files);
					}
				}
				//Check Quake 3
				if (File.Exists(SteamPath + "/steamapps/appmanifest_2200.acf"))
				{
					filePath = SteamPath + "/steamapps/common/Quake 3 Arena/baseq3/";
					GameManager.Print("Open Directory " + filePath);
					dir = new DirectoryInfo(filePath);
					if (dir.Exists)
					{
						files = dir.GetFiles("*.pk3");
						CheckPK3Files(filePath, files);
					}
					//Check TeamArena
					filePath = SteamPath + "/steamapps/common/Quake 3 Arena/missionpack/";
					GameManager.Print("Open Directory " + filePath);
					dir = new DirectoryInfo(filePath);
					if (dir.Exists)
					{
						files = dir.GetFiles("*.pk3");
						CheckPK3Files(filePath, files);
					}
				}
			}
		}

		filePath = Directory.GetCurrentDirectory() + "/StreamingAssets/";
		GameManager.Print("Open Directory " + filePath);
		dir = new DirectoryInfo(filePath);
		files = dir.GetFiles("*.pk3");
		CheckPK3Files(filePath, files);

		int start = 0;
		int end = basePaks.Length;
		if (GameManager.Instance.gameConfig.GameSelect == GameManager.BasePak.All)
			GameManager.Instance.gameConfig.GameSelect = basePak;
		else
		{
			if (GameManager.Instance.gameConfig.GameSelect > basePak)
				GameManager.Instance.gameConfig.GameSelect = basePak;
			else
				basePak = GameManager.Instance.gameConfig.GameSelect;

			switch (basePak)
			{
				default:
				{
					LogError("NO CORRECT PAK0.PK3 FOUND IN " + filePath);
					GameManager.QuitGame();
					return;
				}
				break;
				case GameManager.BasePak.Demo:
					end = 1;
				break;
				case GameManager.BasePak.Quake3:
					start = 1;
					end = 10;
				break;
				case GameManager.BasePak.TeamArena:
					start = 1;
					end = 11;
				break;
				case GameManager.BasePak.QuakeLive:
					start = 11;
					end = 12;
				break;
			}
		}
		for (int i = 0; i < basePaks.Length; i++) 
		{
			if (QuakeFiles.TryGetValue(basePaks[i], out FileStream file))
			{
				if ((i >= start) && (i < end))
					AddPK3Files(file);
				QuakeFiles.Remove(basePaks[i]);
			}
		}

		foreach (FileStream file in QuakeFiles.Values)
			AddPK3Files(file);
		QuakeFiles.Clear();
	}

	public static void CheckPK3Files(string path, FileInfo[] files)
	{
		var fileList = files.OrderBy(file => Regex.Replace(file.Name, @"\d+", match => match.Value.PadLeft(4, '0')));
		foreach (FileInfo zipfile in files)
		{
			string FileName = path + zipfile.Name;

			FileStream file = File.Open(FileName, FileMode.Open, FileAccess.Read);
			AddPK3(file);
		}
	}

	public static void AddPK3Files(FileStream file)
	{
		ZipArchive reader = new ZipArchive(file, ZipArchiveMode.Read);
		GameManager.Print("Checking file " + file.Name);


		for (int index = 0; index < reader.Entries.Count; index++)
		{
			ZipArchiveEntry e = reader.Entries[index];
			//Only Files
			if (e.FullName.Contains("."))
			{
				string logName = e.FullName.ToUpper();
				//Process Shaders and continue
				if (logName.Contains(".SHADER"))
				{
					QShaderManager.ReadShaderData(e.Open());
					continue;
				}

				if (ZipFiles.ContainsKey(logName))
				{
//					GameManager.Print("Updating pak file with name " + logName);
					ZipFiles[logName] = file.Name;
					EntryByIndex[logName] = index;
				}
				else
				{
					ZipFiles.Add(logName, file.Name);
					EntryByIndex.Add(logName, index);
				}

				if (logName.Contains(".BSP"))
					AddMapToList(logName);
				else if (logName.Contains(".SKIN"))
					AddPlayerSkin(logName);
			}
		}
		reader.Dispose();
	}
	public static string Md5Sum(FileStream file)
	{
		// encrypt bytes
		MD5 md5 = MD5.Create();
		byte[] hashBytes = md5.ComputeHash(file);

		// Convert the encrypted bytes back to a string (base 16)
		string hashString = "";

		for (int i = 0; i < hashBytes.Length; i++)
		{
			hashString += Convert.ToString(hashBytes[i], 16).PadLeft(2, '0');
		}
		return hashString.PadLeft(32, '0');
	}

	public static void AddPK3(FileStream pak)
	{
		string md5 = Md5Sum(pak);
		
		switch (md5)
		{
			default:
			{
				if (!QuakeFiles.ContainsKey(md5))
				{
					QuakeFiles.Add(md5, pak);
					GameManager.Print("Adding File: " + pak.Name + " MD5: " + md5);
				}
			}
			break;
			case pak00Live:
			{
				if (!QuakeFiles.ContainsKey(md5))
				{
					QuakeFiles.Add(md5, pak);
					GameManager.Print("Adding File: " + pak.Name + " is QUAKE Live BasePak");
				}
				basePak = GameManager.BasePak.QuakeLive;
			}
			break;
			case pak0Retail:
			{
				if (!QuakeFiles.ContainsKey(md5))
				{
					QuakeFiles.Add(md5, pak);
					GameManager.Print("Adding File: " + pak.Name + " is QUAKE3 BasePak");
				}
				if (basePak < GameManager.BasePak.TeamArena)
					basePak = GameManager.BasePak.Quake3;
			}
			break;
			case pak1Patch:
			case pak2Patch:
			case pak3Patch:
			case pak4Patch:
			case pak5Patch:
			case pak6Patch:
			case pak7Patch:
			case pak8Patch:
			{
				if (!QuakeFiles.ContainsKey(md5))
				{
					QuakeFiles.Add(md5, pak);
					GameManager.Print("Adding File: " + pak.Name + " is QUAKE3 patch loading");
				}
			}
			break;
			case pak0TA:
			{
				if (!QuakeFiles.ContainsKey(md5))
				{
					QuakeFiles.Add(md5, pak);
					GameManager.Print("Adding File: " + pak.Name + " is QUAKE3 Team Arena");
				}
				if (basePak != GameManager.BasePak.QuakeLive)
					basePak = GameManager.BasePak.TeamArena;
			}
			break;
			case pak0Demo:
			{
				if (!QuakeFiles.ContainsKey(md5))
				{
					QuakeFiles.Add(md5, pak);
					GameManager.Print("Adding File: " + pak.Name + " is QUAKE3 Demo");
				}
				if (basePak == GameManager.BasePak.All)
					basePak = GameManager.BasePak.Demo;
			}
			break;
		}
	}

	public static void AddMapToList(string mapName)
	{
		string[] fullPath = mapName.Split('/');
		if (fullPath.Length > 1)
			mapName = fullPath[1];
		else
			mapName = fullPath[0];
		mapName = mapName.StripExtension();
		if (!mapList.Contains(mapName))
			mapList.Add(mapName);
	}

	public static void OrderLists()
	{
		mapList = mapList.OrderBy(mapName => mapName).ToList();
		playerModelList = playerModelList.OrderBy(modelName => modelName).ToList();
		playerSkinList = playerSkinList.OrderBy(skinName => skinName).ToList();
	}

	public static void KeepDemoList(List<string> demoList)
	{
		mapList = demoList.OrderBy(mapName => mapName).ToList();
	}

	public static void AddPlayerModels(string path)
	{
		string[] strword = path.Split('/');
		if (strword.Length > 3)
		{
			string model = strword[2];
			if (!playerModelList.Contains(model))
				playerModelList.Add(model);
		}
	}

	public static void AddPlayerSkin(string path)
	{
		if (!path.Contains("LOWER_"))
			return;

		string skin = path.StripExtension().Replace("LOWER_", "");
		if (!playerSkinList.Contains(skin))
			playerSkinList.Add(skin);

		AddPlayerModels(skin);
	}

	public static void LogError(string error)
	{
		string errorFileName = Directory.GetCurrentDirectory() + "/error.log";
		FileStream errorFile = File.Open(errorFileName, FileMode.OpenOrCreate, FileAccess.ReadWrite);
		errorFile.Seek(0, SeekOrigin.End);
		byte[] writeError = System.Text.Encoding.UTF8.GetBytes(DateTime.Now.ToString() + " : " + error + "\n").ToArray();
		errorFile.Write(writeError);
		errorFile.Close();
	}

	public static List<string> LoadMapRotation()
	{
		string FileName = "/";
		switch(basePak)
		{
			default:
			case GameManager.BasePak.Demo:
				return new List<string>();
			break;
			case GameManager.BasePak.Quake3:
				FileName += "q3_";
			break;
			case GameManager.BasePak.TeamArena:
				FileName += "ta_";
			break;
			case GameManager.BasePak.QuakeLive:
				FileName += "ql_";
			break;
		}
		switch (GameManager.Instance.gameConfig.GameType)
		{
			default:
			case GameManager.GameType.FreeForAll:
			case GameManager.GameType.QuadHog:
				FileName += "ffa.txt";
			break;
			case GameManager.GameType.Tournament:
			case GameManager.GameType.SinglePlayer:
				FileName += "duel.txt";
			break;
			case GameManager.GameType.TeamDeathmatch:
				FileName += "tdm.txt";
			break;
			case GameManager.GameType.CaptureTheFlag:
			case GameManager.GameType.OneFlagCTF:
			case GameManager.GameType.Overload:
			case GameManager.GameType.Harvester:
				FileName += "ctf.txt";
			break;
		}
		string rotationFileName = Directory.GetCurrentDirectory() + FileName;

		if (!File.Exists(rotationFileName))
			return new List<string>();

		FileStream rotationFile = File.Open(rotationFileName, FileMode.Open, FileAccess.Read);
		StreamReader stream = new StreamReader(rotationFile);
		string mapName;

		List<string> mapRotation = new List<string>();
		stream.BaseStream.Seek(0, SeekOrigin.Begin);

		while (!stream.EndOfStream)
		{
			mapName = stream.ReadLine().Split('|')[0].ToUpper();
			if (mapList.Contains(mapName))
				mapRotation.Add(mapName);
		}
		stream.Close();
		rotationFile.Close();

		return mapRotation;
	}

	public static byte[] GetPK3FileData(string FileName, string PK3FileName)
	{
		ZipArchive reader;
		if (!OpenedZippedFiles.TryGetValue(PK3FileName, out reader))
		{
			FileStream file = File.Open(PK3FileName, FileMode.Open, FileAccess.Read);
			reader = new ZipArchive(file, ZipArchiveMode.Read);
			OpenedZippedFiles.Add(PK3FileName, reader);
			OpenedPK3Files.Add(file);
		}

		ZipArchiveEntry entry = reader.Entries[EntryByIndex[FileName]];

		using (MemoryStream ms = new MemoryStream())
		{
			entry.Open().CopyTo(ms);
			return ms.ToArray();
		}
	}

	public static void ClosePK3Files()
	{
		foreach (ZipArchive reader in OpenedZippedFiles.Values)
			reader.Dispose();
		OpenedZippedFiles.Clear();

		foreach (FileStream file in OpenedPK3Files)
			file.Dispose();
		OpenedPK3Files.Clear();
	}
}
```

./Assets/Scripts/Managers/ModelsManager.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;

public static class ModelsManager
{
	public static Dictionary<string, MD3> Models = new Dictionary<string, MD3>();
	public static Dictionary<string, MeshProcessed.dataMeshes> Sprites = new Dictionary<string, MeshProcessed.dataMeshes>();
	public static HashSet<ModelController> ActiveModels = new HashSet<ModelController>();

	public static Dictionary<string, ModelAnimationData> AnimationData = new Dictionary<string, ModelAnimationData>();
	public static Dictionary<string, Dictionary<string, string>> SkinData = new Dictionary<string, Dictionary<string, string>>();

	public static Dictionary<string, string> GetSkinData(string skinName)
	{
		Dictionary<string, string> meshToSkin;
		if (SkinData.TryGetValue(skinName, out meshToSkin))
			return meshToSkin;
		return null;
	}

	public static void AddSkinData(string skinName, Dictionary<string, string> meshToSkin)
	{
		if (!SkinData.ContainsKey(skinName))
		{
			Dictionary<string, string> added = new Dictionary<string, string>();
			foreach (var value in meshToSkin)
			{
				if (!added.ContainsKey(value.Key))
					added.Add(value.Key, value.Value);
			}
			SkinData.Add(skinName, added);
		}
	}

	public static ModelAnimationData GetAnimationData(string animation)
	{
		if (AnimationData.TryGetValue(animation, out ModelAnimationData animationData))
			return animationData;
		return null;
	}

	public static void AddAnimationData(string animation, List<PlayerModel.ModelAnimation> Upper, List<PlayerModel.ModelAnimation> Lower, PlayerThing.FootStepType FootSteps)
	{
		if (AnimationData.ContainsKey(animation))
			return;

		ModelAnimationData animationData = new ModelAnimationData(Upper, Lower, FootSteps);
		AnimationData.Add(animation, animationData);
	}
	
	public static void ClearModels()
	{
		ActiveModels = new HashSet<ModelController>();
	}
	public static void AddModel(ModelController controller)
	{
		if (ActiveModels.Contains(controller))
			return;
		ActiveModels.Add(controller);
	}

	public static void RemoveModel(ModelController controller)
	{
		if (ActiveModels.Contains(controller))
			ActiveModels.Remove(controller);
	}


	public static void CacheModel(string modelName, bool forceSkinAlpha = false)
	{
		if (Models.ContainsKey(modelName))
			return;

		MD3 model = MD3.ImportModel(modelName, forceSkinAlpha);
		if (model == null)
			return;

		Models.Add(modelName, model);
		return;
	}
	public static MD3 GetModel(string modelName, bool forceSkinAlpha = false)
	{
		MD3 model;
		if (Models.TryGetValue(modelName, out model))
			return model;

		model = MD3.ImportModel(modelName, forceSkinAlpha);
		if (model == null)
			return null;

		Models.Add(modelName, model);
		return model;
	}

	public static void FrameProcessModels(float deltaTime)
	{
		foreach (var model in ActiveModels)
			model.Process(deltaTime);

	}

	public class ModelAnimationData
	{
		public List<PlayerModel.ModelAnimation> Upper;
		public List<PlayerModel.ModelAnimation> Lower;
		public PlayerThing.FootStepType FootSteps;

		public ModelAnimationData (List<PlayerModel.ModelAnimation> Upper, List<PlayerModel.ModelAnimation> Lower, PlayerThing.FootStepType FootSteps)
		{
			this.Upper = Upper;
			this.Lower = Lower;
			this.FootSteps = FootSteps;
		}	
	}
}

```

./Assets/Scripts/Managers/ConsoleManager.cs:
```
using Godot;
using System;
using System.Collections.Generic;
using System.Linq;
using ExtensionMethods;
public partial class ConsoleManager : Control
{
	[Export]
	public LineEdit commandLine;
	[Export]
	public RichTextLabel history;
	public int moveSpeed = 1000;

	private GameManager.FuncState currentState = GameManager.FuncState.None;
	private List<string> commandSubmited = new List<string>();

	public const int lineHeight = 23;
	public bool visible = false;
	private Vector2 tempPosition;
	private Vector2 tempSize;
	private int halfHeight;
	private int totalLines = 0;
	private int focusLine = 0;
	private int lastCommand = 0;
	public void Init()
	{
		tempPosition = DisplayServer.WindowGetSize();
		halfHeight = Mathf.CeilToInt(tempPosition.Y / 2);
		tempPosition = new Vector2(0, -halfHeight);

		tempSize = new Vector2(Size.X, 0);
		SetDeferred("Size", new Vector2(Size.X, halfHeight));
		history.CustomMinimumSize = tempSize;
		Position = tempPosition;
		commandLine.TextSubmitted += CommandSubmited;
	}

	public override void _Input(InputEvent @event)
	{
		if (!GameManager.Console.visible)
			return;

		if (@event is InputEventKey)
		{
			if (Input.IsActionJustPressed("Console_Prev"))
				RecallCommand(true);
			else if (Input.IsActionJustPressed("Console_Next"))
				RecallCommand(false);
		}

	}

	public void ChangeConsole(bool forceHide = false)
	{
		if (currentState != GameManager.FuncState.End)
			return;

		visible = !visible;
		if (visible)
		{
			focusLine = totalLines;
			tempSize.Y = focusLine * lineHeight;
			history.CustomMinimumSize = tempSize;
			commandLine.FocusMode = FocusModeEnum.All;
			Show();
		}
		else
		{
			if (forceHide)
				Hide();
			commandLine.FocusMode = FocusModeEnum.None;
		}

		currentState = GameManager.FuncState.Start;
	}

	public void CommandSubmited(string command)
	{
		if (string.IsNullOrEmpty(command))
			return;
		commandLine.Text = "";
		commandSubmited.Add(command);
		lastCommand++;
		ProcessCommand(command.ToUpper());
	}

	public void RecallCommand(bool previous)
	{
		if (commandSubmited.Count == 0)
			return;

		if (previous)
		{
			lastCommand--;
			if (lastCommand < 0)
				lastCommand = 0;
		}
		else
		{
			lastCommand++;
			if (lastCommand > commandSubmited.Count)
				lastCommand = commandSubmited.Count;
		}

		if (commandSubmited.Count > lastCommand)
		{
			commandLine.Text = commandSubmited[lastCommand];
			commandLine.CaretColumn = commandSubmited[lastCommand].Length;
		}
	}

	public void ChangeAutoHop(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing [b]true/false[/b] to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string autohop = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				autohop = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (autohop == "TRUE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.AutoHop = true;
		else if (autohop == "FALSE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.AutoHop = false;
		else
		{
			AddToConsole("Command: " + args[0] + " failed: " + autohop + " is not [b]true/false[/b]", GameManager.PrintType.Warning);
			return;
		}

		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeAutoSwap(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing [b]true/false[/b] to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string autoSwap = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				autoSwap = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (autoSwap == "TRUE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.AutoSwap = true;
		else if (autoSwap == "FALSE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.AutoSwap = false;
		else
		{
			AddToConsole("Command: " + args[0] + " failed: " + autoSwap + " is not [b]true/false[/b]", GameManager.PrintType.Warning);
			return;
		}

		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeBloodScreen(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing [b]true/false[/b] to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string bloodscreen = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				bloodscreen = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (bloodscreen == "TRUE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.BloodScreen = true;
		else if (bloodscreen == "FALSE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.BloodScreen = false;
		else
		{
			AddToConsole("Command: " + args[0] + " failed: " + bloodscreen + " is not [b]true/false[/b]", GameManager.PrintType.Warning);
			return;
		}

		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeColor(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing color to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string color = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				color = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		Color modulate = Colors.White;
		bool failed = false;
		try
		{
			modulate = new Color(color);
		}
		catch (Exception)
		{
			AddToConsole("Command: " + args[0] + " failed: " + color + " is an invalid color", GameManager.PrintType.Warning);
			failed = true;
		}
		if (!failed)
		{
			modulate.R = Mathf.Max(0.1f, modulate.R);
			modulate.G = Mathf.Max(0.1f, modulate.G);
			modulate.B = Mathf.Max(0.1f, modulate.B);
			GameManager.Instance.Players[playerNum].modulate = modulate;
			AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
			GameManager.Instance.Players[playerNum].playerInfo.configData.ModulateColor = color;
			GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
		}
	}

	public void ChangeCrossHair(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing weapon and crosshair type to change", GameManager.PrintType.Warning);
			return;
		}
		if (args.Length < 3)
		{
			AddToConsole("Command: " + command + " missing crosshair type to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string weapon = args[1];
		string crosshair = args[2];
		if (args.Length > 3)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				weapon = args[2];
				crosshair = args[3];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		int weaponNum = 0;
		if (weapon == "ALL")
			weaponNum = -1;
		else if (weapon == "GAUNTLET")
			weaponNum = 0;
		else if (weapon == "MACHINEGUN")
			weaponNum = 1;
		else if (weapon == "SHOTGUN")
			weaponNum = 2;
		else if ((weapon == "GRENADE") || (weapon == "GRENADELAUNCHER"))
			weaponNum = 3;
		else if ((weapon == "ROCKET") || (weapon == "ROCKETLAUNCHER"))
			weaponNum = 4;
		else if ((weapon == "LIGHTNING") || (weapon == "LIGHTNINGGUN"))
			weaponNum = 5;
		else if ((weapon == "RAIL") || (weapon == "RAILGUN"))
			weaponNum = 6;
		else if ((weapon == "PLASMA") || (weapon == "PLASMAGUN"))
			weaponNum = 7;
		else if ((weapon == "BFG") || (weapon == "BFG10K"))
			weaponNum = 8;
		else if ((weapon == "NAIL") || (weapon == "NAILGUN"))
			weaponNum = 10;
		else if ((weapon == "CHAIN") || (weapon == "CHAINGUN"))
			weaponNum = 11;
		else if ((weapon == "PROXIMITY") || (weapon == "PROXIMITYLAUNCHER"))
			weaponNum = 12;
		else if ((weapon == "HMG") || (weapon == "HEAVYMACHINEGUN"))
			weaponNum = 13;
		else
		{
			AddToConsole("Command: " + args[0] + " was not changed. Weapon " + weapon + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		string[] type = crosshair.Split('_');
		if (type.Length < 2)
		{
			AddToConsole("Command: " + command + " invalid crosshair type", GameManager.PrintType.Warning);
			return;
		}

		int CrossHair = 0;
		if (type[0] == "SMALL")
		{
			if (int.TryParse(type[1], out CrossHair))
			{
				if (CrossHair > 50)
				{
					AddToConsole("Command: " + command + " invalid crosshair type", GameManager.PrintType.Warning);
					return;
				}
			}
			else
			{
				AddToConsole("Command: " + command + " invalid crosshair type", GameManager.PrintType.Warning);
				return;
			}
		}
		else if (type[0] == "LARGE")
		{
			if (int.TryParse(type[1], out CrossHair))
			{
				if (CrossHair > 50)
				{
					AddToConsole("Command: " + command + " invalid crosshair type", GameManager.PrintType.Warning);
					return;
				}
				else
					CrossHair += 100;
			}
			else
			{
				AddToConsole("Command: " + command + " invalid crosshair type", GameManager.PrintType.Warning);
				return;
			}
		}
		else
		{
			AddToConsole("Command: " + command + " invalid crosshair type", GameManager.PrintType.Warning);
			return;
		}

		int[] CroosHairs = GameManager.Instance.Players[playerNum].playerInfo.configData.CroosHair;
		if (weaponNum < 0)
		{
			for (int i = 0; i < CroosHairs.Length; i++)
				CroosHairs[i] = CrossHair;
			GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.ChangeCrossHair(CrossHair);
		}
		else
		{
			CroosHairs[weaponNum] = CrossHair;
			if (weaponNum == GameManager.Instance.Players[playerNum].playerControls.CurrentWeapon)
				GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.ChangeCrossHair(CrossHair);
		}
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeCrossHairAlpha(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing alpha value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string alpha = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				alpha = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		bool failed = true;
		int Alpha = 0;
		if (int.TryParse(alpha, out Alpha))
			failed = false;

		if ((failed) || (Alpha < 0) || (Alpha > 100))
		{
			AddToConsole("Command: " + command + " alpha is not in correct format [b]0-100[/b]", GameManager.PrintType.Warning);
			return;
		}

		GameManager.Instance.Players[playerNum].playerInfo.configData.CroosHairAlpha = Alpha;
		GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.ChangeCrossHairAlpha(Alpha);
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeCrossHairScale(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing scale value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string scale = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				scale = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		bool failed = true;
		int Scale = 0;
		if (int.TryParse(scale, out Scale))
			failed = false;

		if ((failed) || (Scale < 10) || (Scale > 100))
		{
			AddToConsole("Command: " + command + " scale is not in correct format [b]10-100[/b]", GameManager.PrintType.Warning);
			return;
		}
		GameManager.Instance.Players[playerNum].playerInfo.configData.CroosHairScale = Scale;
		GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.ChangeCrossHairScale(Scale);
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeFragLimit(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing frag to set", GameManager.PrintType.Warning);
			return;
		}
		if (int.TryParse(args[1], out int value))
		{
			if (value < 1)
			{
				AddToConsole("Command: " + args[0] + " was not changed. " + args[1] + " must be positive", GameManager.PrintType.Warning);
				return;
			}
			GameManager.Instance.ChangeFragLimit(value);
			AddToConsole("Command: " + args[0] + " sucesfully changed to " + args[1], GameManager.PrintType.Success);
		}
		else
			AddToConsole("Command: " + args[0] + " was not changed. " + args[1] + " is not an integer", GameManager.PrintType.Warning);
	}

	public void ChangeFOV(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing scale value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string fov = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				fov = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		bool failed = true;
		int Fov = 0;
		if (int.TryParse(fov, out Fov))
			failed = false;

		if ((failed) || (Fov < 30) || (Fov > 130))
		{
			AddToConsole("Command: " + command + " FOV is not in correct format [b]30-130[/b]", GameManager.PrintType.Warning);
			return;
		}
		GameManager.Instance.Players[playerNum].playerInfo.playerCamera.ViewCamera.Fov = Fov;
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void GiveItem(string[] args, string command)
	{
		if (!MapLoader.UseCheats)
		{
			AddToConsole("Cheats are not enabled on this server", GameManager.PrintType.Warning);
			return;
		}

		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing item to give", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string item = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " failed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " failed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				item = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " failed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		item = item.ToLower();
		bool found = false;
		if (ThingsManager.itemName.TryGetValue(item, out string foundItem))
		{
			item = foundItem;
			found = true;
		}
		else if (!item.Contains('_'))
		{
			string[] checks = new string[5] { "weapon_", "ammo_", "item_", "item_armor_", "item_health_" };
			for (int i = 0; i < checks.Length; i++) 
			{
				string newItem = checks[i] + item;
				if (ThingsManager.pickablePrefabs.ContainsKey(newItem))
				{
					item = newItem;
					found = true;
					break;
				}
			}
		}
		else if (ThingsManager.pickablePrefabs.ContainsKey(item))
			found = true;

		if (found)
		{
			switch (GameManager.Instance.gameConfig.GameSelect)
			{
				default:
					break;
				case GameManager.BasePak.TeamArena:
					if (ThingsManager.teamArenaIgnoreItems.Any(s => s == item))
						found = false;
					break;
				case GameManager.BasePak.Quake3:
					if (ThingsManager.retailIgnoreItems.Any(s => s == item))
						found = false;
				break;
				case GameManager.BasePak.Demo:
					if (ThingsManager.demoIgnoreItems.Any(s => s == item))
						found = false;
				break;
			}
		}

		if (!found)
		{
			AddToConsole("Command: " + args[0] + " failed. Item " + item + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		ThingController thingObject = (ThingController)ThingsManager.pickablePrefabs[item].Instantiate();
		if (thingObject == null)
		{
			AddToConsole("Command: " + args[0] + " failed. Item " + item + " is invalid", GameManager.PrintType.Warning);
			return;
		}
		ItemPickup itemPickup = thingObject.itemPickup;
		if (itemPickup == null)
		{
			AddToConsole("Command: " + args[0] + " failed. Item " + item + " is invalid", GameManager.PrintType.Warning);
			thingObject.QueueFree();
			return;
		}
		thingObject.initDisabled = true;
		thingObject.SpawnCheck(item);
		GameManager.Instance.TemporaryObjectsHolder.AddChild(thingObject);
		thingObject.GlobalPosition = GameManager.Instance.Players[playerNum].GlobalPosition;
		thingObject.SetRespawnTime(-1);
		if (!itemPickup.PickUp(GameManager.Instance.Players[playerNum]))
			thingObject.QueueFree();
		AddToConsole("Command: " + args[0] + " executed sucesfully for Player " + playerNum, GameManager.PrintType.Success);
	}

	public void ChangeGodMode(string[] args, string command)
	{
		if (!MapLoader.UseCheats)
		{
			AddToConsole("Cheats are not enabled on this server", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " failed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " failed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " failed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}
		bool godMode = GameManager.Instance.Players[playerNum].playerInfo.godMode;
		GameManager.Instance.Players[playerNum].playerInfo.godMode = !godMode;
		if (godMode)
			AddToConsole("Command: " + args[0] + " OFF for Player " + playerNum, GameManager.PrintType.Success);
		else
			AddToConsole("Command: " + args[0] + " ON for Player " + playerNum, GameManager.PrintType.Success);
	}
	public void ShowCommands(string command)
	{
		AddToConsole("Command: " + command, GameManager.PrintType.Success);
		AddToConsole("The following is a list of commands:", GameManager.PrintType.Log);
		AddToConsole("AUTOHOP [i]0-7[/i] [b]true/false[/b] -> Set AutoHop [b]true/false[/b] for the [i]player[/i], default: [b]false[/b]", GameManager.PrintType.Log);
		AddToConsole("AUTOSWAP [i]0-7[/i] [b]true/false[/b] -> Automatically swap to new weapon when pickedup [b]true/false[/b] for the [i]player[/i], default: [b]true[/b]", GameManager.PrintType.Log);
		AddToConsole("BLOODSCREEN [i]0-7[/i] [b]true/false[/b] -> Set pain visual feedback [b]true/false[/b] for the [i]player[/i], default: [b]true[/b]", GameManager.PrintType.Log);
		AddToConsole("CROSSHAIR [i]0-7[/i] [b]gauntlet-bfg10k/all[/b] [b]small_/large_1-50[/b] -> Set Crosshair for the [i]player[/i], default: [b]all small_5, railgun large_7[/b]", GameManager.PrintType.Log);
		AddToConsole("CROSSHAIRALPHA [i]0-7[/i] [b]0-100[/b] -> Set CrossHair [b]Transparency[/b] for the [i]player[/i], default: [b]25[/b]", GameManager.PrintType.Log);
		AddToConsole("CROSSHAIRSCALE [i]0-7[/i] [b]10-100[/b] -> Set 2D CrossHair [b]Scale[/b] for the [i]player[/i], default: [b]100[/b]", GameManager.PrintType.Log);
		AddToConsole("COLOR [i]0-7[/i] [b]color[/b] -> Change the [b]color[/b] (color can be #hex or by name) for the [i]player[/i], default: [b]#50a1cd[/b]", GameManager.PrintType.Log);
		AddToConsole("DEVMAP [b]mapName[/b] -> Load [b]map[/b] with Cheats Enabled", GameManager.PrintType.Log);
		AddToConsole("FRAGLIMIT [b]limit[/b] -> Set the [b]fraglimit[/b] per map, default: [b]15[/b]", GameManager.PrintType.Log);
		AddToConsole("FOV [i]0-7[/i] [b]30-130[/b] -> Set [b]Fov[/b] for the [i]player[/i], default: [b]90[/b]", GameManager.PrintType.Log);
		AddToConsole("GIVE [i]0-7[/i] [b]itemName[/b] -> Give [b]Item[/b] for the [i]player[/i]", GameManager.PrintType.Log);
		AddToConsole("GOD [i]0-7[/i] -> Switch GOD Mode for the [i]player[/i]", GameManager.PrintType.Log);
		AddToConsole("HUD2DSCALE [i]0-7[/i] [b]10-100[/b] -> Set 2D HUD Elements [b]Scale[/b] for the [i]player[/i], default: [b]100[/b]", GameManager.PrintType.Log);
		AddToConsole("HUD3DSCALE [i]0-7[/i] [b]10-100[/b] -> Set 3D HUD Elements [b]Scale[/b] for the [i]player[/i], default: [b]100[/b]", GameManager.PrintType.Log);
		AddToConsole("HUDSHOW [i]0-7[/i] [b]true/false[/b] -> Set HUD Visibility [b]true/false[/b] for the [i]player[/i], default: [b]true[/b]", GameManager.PrintType.Log);
		AddToConsole("INVERTVIEW [i]0-7[/i] [b]true/false[/b] -> Set Invert view control [b]true/false[/b] for the [i]player[/i], default: [b]false[/b]", GameManager.PrintType.Log);
		AddToConsole("KILL [i]0-7[/i] -> Kill the [i]player[/i]", GameManager.PrintType.Log);
		AddToConsole("LISTMAPS -> List all the posible maps that can be played", GameManager.PrintType.Log);
		AddToConsole("LISTMODELS -> List all the posible player models that can be used", GameManager.PrintType.Log);
		AddToConsole("LISTSKINS [i]0-7[/i] -> List all the posible skins for the current [i]player[/i] model", GameManager.PrintType.Log);
		AddToConsole("MAP [b]mapName[/b] -> Load [b]map[/b]", GameManager.PrintType.Log);
		AddToConsole("MODEL [i]0-7[/i] [b]modelName[/b] -> Change the [b]model[/b] for the [i]player[/i]", GameManager.PrintType.Log);
		AddToConsole("MOUSESENSITIVITY [i]0-7[/i] [b]X,Y[/b] -> Change the mouse sensitivity [b]X,Y[/b] for the [i]player[/i], default: [b].5,.5[/b]", GameManager.PrintType.Log);
		AddToConsole("NEXTMAP -> Change to the next map in the map rotation list", GameManager.PrintType.Log);
		AddToConsole("PLAYERNAME [i]0-7[/i] [b]name[/b] -> Change the [b]name[/b] for the [i]player[/i]", GameManager.PrintType.Log);
		AddToConsole("QUIT -> Quits the game", GameManager.PrintType.Log);
		AddToConsole("REMOVEPLAYER [i]0-7[/i] -> Remove the [i]player[/i] from the game", GameManager.PrintType.Log);
		AddToConsole("SAFESWAP [i]0-7[/i] [b]true/false[/b] -> Swap to safe weapon when out of ammo [b]true/false[/b] for the [i]player[/i], default: [b]true[/b]", GameManager.PrintType.Log);
		AddToConsole("SKIN [i]0-7[/i] [b]skinName[/b] -> Change the [b]skin[/b] for the [i]player[/i]", GameManager.PrintType.Log);
		AddToConsole("STICKSENSITIVITY [i]0-7[/i] [b]X,Y[/b] -> Change the controller sticks sensitivity [b]X,Y[/b] for the [i]player[/i], default: [b]4,3[/b]", GameManager.PrintType.Log);
		AddToConsole("TIMELIMIT [b]limit[/b] -> Set the [b]timelimit[/b] per map, default: [b]7[/b]", GameManager.PrintType.Log);
		AddToConsole("[b]bold[/b] -> Denotes [b]Obligatory[/b]", GameManager.PrintType.Log);
		AddToConsole("[i]italic[/i] -> Denotes [i]Optional[/i]", GameManager.PrintType.Log);
	}

	public void ChangeHUD2DScale(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing scale value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string scale = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				scale = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		bool failed = true;
		int Scale = 0;
		if (int.TryParse(scale, out Scale))
			failed = false;

		if ((failed) || (Scale < 10) || (Scale > 100))
		{
			AddToConsole("Command: " + command + " scale is not in correct format [b]10-100[/b]", GameManager.PrintType.Warning);
			return;
		}
		GameManager.Instance.Players[playerNum].playerInfo.configData.HUD2DScale = Scale;
		GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.ChangeSpriteScale(Scale);
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeHUD3DScale(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing scale value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string scale = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				scale = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		bool failed = true;
		int Scale = 0;
		if (int.TryParse(scale, out Scale))
			failed = false;

		if ((failed) || (Scale < 10) || (Scale > 100))
		{
			AddToConsole("Command: " + command + " scale is not in correct format [b]10-100[/b]", GameManager.PrintType.Warning);
			return;
		}
		GameManager.Instance.Players[playerNum].playerInfo.configData.HUD3DScale = Scale;
		GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.ChangeModelScale(Scale);
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeHUDVisibility(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing [b]true/false[/b] to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string hudshow = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				hudshow = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (hudshow == "TRUE")
		{
			GameManager.Instance.Players[playerNum].playerInfo.configData.HUDShow = true;
			GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.UpdateLayersHud(GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.UIMask);
		}
		else if (hudshow == "FALSE")
		{
			GameManager.Instance.Players[playerNum].playerInfo.configData.HUDShow = false;
			GameManager.Instance.Players[playerNum].playerInfo.playerPostProcessing.playerHUD.UpdateLayersHud(1 << GameManager.UINotVisibleLayer);
		}
		else
		{
			AddToConsole("Command: " + args[0] + " failed: " + hudshow + " is not [b]true/false[/b]", GameManager.PrintType.Warning);
			return;
		}

		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeInvertView(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing [b]true/false[/b] to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string invert = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				invert = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (invert == "TRUE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.InvertView = true;
		else if (invert == "FALSE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.InvertView = false;
		else
		{
			AddToConsole("Command: " + args[0] + " failed: " + invert + " is not [b]true/false[/b]", GameManager.PrintType.Warning);
			return;
		}

		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void KillPlayer(string[] args, string command)
	{
		int playerNum = 0;
		if (args.Length > 1)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not applied. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not applied. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not applied. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		GameManager.Instance.Players[playerNum].Damage(1000, DamageType.Telefrag);
		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
	}

	public void ListMaps(string command)
	{
		AddToConsole("Command: " + command, GameManager.PrintType.Success);
		for (int i = 0; i < PakManager.mapList.Count; i++)
		{
			string mapName = PakManager.mapList[i];
			AddToConsole(mapName, GameManager.PrintType.Log, false);
		}
	}

	public void ListModels(string command)
	{
		AddToConsole("Command: " + command, GameManager.PrintType.Success);
		for (int i = 0; i < PakManager.playerModelList.Count; i++)
		{
			string modelName = PakManager.playerModelList[i];
			AddToConsole(modelName, GameManager.PrintType.Log, false);
		}
	}

	public void ListSkins(string[] args, string command)
	{
		AddToConsole("Command: " + command, GameManager.PrintType.Success);
		int playerNum = 0;

		if (args.Length > 1)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " . Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " . Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
			}
		}

		string currentModel = "MODELS/PLAYERS/" + GameManager.Instance.defaultModels[playerNum].ToUpper() + "/";
		if (playerNum < GameManager.Instance.Players.Count)
			currentModel = "MODELS/PLAYERS/" + GameManager.Instance.Players[playerNum].modelName.ToUpper() + "/";

		for (int i = 0; i < PakManager.playerSkinList.Count; i++)
		{
			string path = PakManager.playerSkinList[i];
			if (path.Contains(currentModel))
			{
				string skinName = path.Replace(currentModel, "");
				AddToConsole(skinName, GameManager.PrintType.Log, false);
			}
		}
	}

	public void ChangeMap(string[] args, string command, bool cheats = false)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing map to change", GameManager.PrintType.Warning);
			return;
		}

		string mapName = args[1];
		if (!PakManager.mapList.Contains(mapName))
		{
			AddToConsole("Command: " + command + " map not found", GameManager.PrintType.Warning);
			return;
		}
		GameManager.Instance.ChangeMap(mapName, cheats);
	}

	public void ChangeModel(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing model to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string model = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.defaultModels.Length)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				model = args[2];
			}
		}

		if (!PakManager.playerModelList.Contains(model))
		{
			AddToConsole("Command: " + command + " model not found", GameManager.PrintType.Warning);
			return;
		}

		if (playerNum >= GameManager.Instance.Players.Count)
			GameManager.Instance.defaultModels[playerNum] = model;
		else
			GameManager.Instance.Players[playerNum].modelName = model;
		AddToConsole("Command: " + args[0] + " sucesfully changed to " + model + " for Player " + playerNum, GameManager.PrintType.Success);
	}

	public void ChangeMouseSensitivity(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing sensitivity value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string sensitivity = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				sensitivity = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (!sensitivity.Contains(','))
		{
			AddToConsole("Command: " + command + " sensitivity is not in correct format [b]X,Y[/b]", GameManager.PrintType.Warning);
			return;
		}


		string[] check = sensitivity.Split(',');
		if (check.Length != 2)
		{
			AddToConsole("Command: " + command + " sensitivity is not in correct format [b]X,Y[/b]", GameManager.PrintType.Warning);
			return;
		}

		string[] sens = new string[2];
		for (int i = 0; i < check.Length; i++)
		{
			sens[i] = "";
			for (int j = 0; j < check[i].Length; j++)
			{
				if (char.IsDigit(check[i][j]))
					sens[i] += check[i][j];
				else if (check[i][j] == '.')
					sens[i] += check[i][j];
				else
				{
					AddToConsole("Command: " + command + " sensitivity is not in correct format [b]X,Y[/b]", GameManager.PrintType.Warning);
					return;
				}
			}
		}

		Vector2 Sensitivity = new Vector2(sens[0].GetNumValue(), sens[1].GetNumValue());
		GameManager.Instance.Players[playerNum].playerInfo.configData.MouseSensitivity[0] = Sensitivity.X;
		GameManager.Instance.Players[playerNum].playerInfo.configData.MouseSensitivity[1] = Sensitivity.Y;
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangePlayerName(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing name to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string playerName = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				playerName = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		GameManager.Instance.ChangePlayerName(playerNum, playerName);
		AddToConsole("Command: " + args[0] + " sucesfully changed to " + playerName + " for Player " + playerNum, GameManager.PrintType.Success);
	}

	public void RemovePlayer(string[] args, string command)
	{
		int playerNum = 0;
		if (args.Length > 1)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not applied. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not applied. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not applied. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		GameManager.Instance.RemovePlayer(playerNum);
		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
	}

	public void ChangeSafeSwap(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing [b]true/false[/b] to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string safeSwap = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				safeSwap = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (safeSwap == "TRUE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.SafeSwap = true;
		else if (safeSwap == "FALSE")
			GameManager.Instance.Players[playerNum].playerInfo.configData.SafeSwap = false;
		else
		{
			AddToConsole("Command: " + args[0] + " failed: " + safeSwap + " is not [b]true/false[/b]", GameManager.PrintType.Warning);
			return;
		}

		AddToConsole("Command: " + command + " was succesfully applied", GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeSkin(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing skin to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string skin = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.defaultSkins.Length)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				skin = args[2];
			}
		}

		string pathSkin = "MODELS/PLAYERS/" + GameManager.Instance.defaultModels[playerNum].ToUpper() + "/" + skin;
		if (playerNum < GameManager.Instance.Players.Count)
			pathSkin = "MODELS/PLAYERS/" + GameManager.Instance.Players[playerNum].modelName.ToUpper() + "/" + skin;

		if (!PakManager.playerSkinList.Contains(pathSkin))
		{
			AddToConsole("Command: " + command + " skin not found", GameManager.PrintType.Warning);
			return;
		}

		if (playerNum >= GameManager.Instance.Players.Count)
			GameManager.Instance.defaultSkins[playerNum] = skin;
		else
			GameManager.Instance.Players[playerNum].skinName = skin;
		AddToConsole("Command: " + args[0] + " sucesfully changed to " + skin + " for Player " + playerNum, GameManager.PrintType.Success);
	}

	public void ChangeStickSensitivity(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing sensitivity value to change", GameManager.PrintType.Warning);
			return;
		}

		int playerNum = 0;
		string sensitivity = args[1];
		if (args.Length > 2)
		{
			if (int.TryParse(args[1], out int value))
			{
				if (value < 0)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " must be positive", GameManager.PrintType.Warning);
					return;
				}
				if (value > GameManager.Instance.Players.Count)
				{
					AddToConsole("Command: " + args[0] + " was not changed. Player " + args[1] + " doesn't exist", GameManager.PrintType.Warning);
					return;
				}
				playerNum = value;
				sensitivity = args[2];
			}
		}

		if (playerNum == GameManager.Instance.Players.Count)
		{
			AddToConsole("Command: " + args[0] + " was not changed. Player " + playerNum + " doesn't exist", GameManager.PrintType.Warning);
			return;
		}

		if (!sensitivity.Contains(','))
		{
			AddToConsole("Command: " + command + " sensitivity is not in correct format [b]X,Y[/b]", GameManager.PrintType.Warning);
			return;
		}


		string[] check = sensitivity.Split(',');
		if (check.Length != 2)
		{
			AddToConsole("Command: " + command + " sensitivity is not in correct format [b]X,Y[/b]", GameManager.PrintType.Warning);
			return;
		}

		string[] sens = new string[2];
		for (int i = 0; i < check.Length; i++)
		{
			sens[i] = "";
			for (int j = 0; j < check[i].Length; j++)
			{
				if (char.IsDigit(check[i][j]))
					sens[i] += check[i][j];
				else if (check[i][j] == '.')
					sens[i] += check[i][j];
				else
				{
					AddToConsole("Command: " + command + " sensitivity is not in correct format [b]X,Y[/b]", GameManager.PrintType.Warning);
					return;
				}
			}
		}

		Vector2 Sensitivity = new Vector2(sens[0].GetNumValue(), sens[1].GetNumValue());
		GameManager.Instance.Players[playerNum].playerInfo.configData.StickSensitivity[0] = Sensitivity.X;
		GameManager.Instance.Players[playerNum].playerInfo.configData.StickSensitivity[1] = Sensitivity.Y;
		AddToConsole("Command: " + args[0] + " sucesfully changed for Player " + playerNum, GameManager.PrintType.Success);
		GameManager.Instance.Players[playerNum].playerInfo.SaveConfigData();
	}

	public void ChangeTimeLimit(string[] args, string command)
	{
		if (args.Length < 2)
		{
			AddToConsole("Command: " + command + " missing time to set", GameManager.PrintType.Warning);
			return;
		}

		string limit = args[1];
		if (int.TryParse(limit, out int value))
		{
			if (value < 1)
			{
				AddToConsole("Command: " + args[0] + " was not changed. " + args[1] + " must be positive", GameManager.PrintType.Warning);
				return;
			}

			GameManager.Instance.ChangeTimeLimit(value);
			AddToConsole("Command: " + args[0] + " sucesfully changed to " + args[1], GameManager.PrintType.Success);
		}
		else
			AddToConsole("Command: " + args[0] + " was not changed. " + args[1] + " is not an integer", GameManager.PrintType.Warning);
	}
	public void ProcessCommand(string command)
	{
		string[] args = command.Split(' ');

		if (args[0] == "AUTOHOP")
			ChangeAutoHop(args, command);
		else if (args[0] == "AUTOSWAP")
			ChangeAutoSwap(args, command);
		else if (args[0] == "BLOODSCREEN")
			ChangeBloodScreen(args, command);
		else if (args[0] == "COLOR")
			ChangeColor(args, command);
		else if (args[0] == "CROSSHAIR")
			ChangeCrossHair(args, command);
		else if (args[0] == "CROSSHAIRALPHA")
			ChangeCrossHairAlpha(args, command);
		else if (args[0] == "CROSSHAIRSCALE")
			ChangeCrossHairScale(args, command);
		else if (args[0] == "DEVMAP")
			ChangeMap(args, command, true);
		else if (args[0] == "FRAGLIMIT")
			ChangeFragLimit(args, command);
		else if (args[0] == "FOV")
			ChangeFOV(args, command);
		else if (args[0] == "GIVE")
			GiveItem(args, command);
		else if (args[0] == "GOD")
			ChangeGodMode(args, command);
		else if (args[0] == "HELP")
			ShowCommands(command);
		else if (args[0] == "HUD2DSCALE")
			ChangeHUD2DScale(args, command);
		else if (args[0] == "HUD3DSCALE")
			ChangeHUD3DScale(args, command);
		else if (args[0] == "HUDSHOW")
			ChangeHUDVisibility(args, command);
		else if (args[0] == "INVERTVIEW")
			ChangeInvertView(args, command);
		else if (args[0] == "KILL")
			KillPlayer(args, command);
		else if (args[0] == "LISTMAPS")
			ListMaps(command);
		else if (args[0] == "LISTMODELS")
			ListModels(command);
		else if (args[0] == "LISTSKINS")
			ListSkins(args, command);
		else if (args[0] == "MAP")
			ChangeMap(args, command);
		else if (args[0] == "MODEL")
			ChangeModel(args, command);
		else if (args[0] == "MOUSESENSITIVITY")
			ChangeMouseSensitivity(args, command);
		else if (args[0] == "NEXTMAP")
			GameManager.Instance.ChangeMap("");
		else if (args[0] == "PLAYERNAME")
			ChangePlayerName(args, command);
		else if (args[0] == "QUIT")
			GameManager.QuitGame();
		else if (args[0] == "REMOVEPLAYER")
			RemovePlayer(args, command);
		else if (args[0] == "SAFESWAP")
			ChangeSafeSwap(args, command);
		else if (args[0] == "SKIN")
			ChangeSkin(args, command);
		else if (args[0] == "STICKSENSITIVITY")
			ChangeStickSensitivity(args, command);
		else if (args[0] == "TIMELIMIT")
			ChangeTimeLimit(args, command);
		else
			AddToConsole("Unknown Command: " + command + " type HELP for a list of commands", GameManager.PrintType.Warning);
	}

	public void AddToConsole(string String, GameManager.PrintType type, bool addNumLines = true)
	{
		if (addNumLines)
			String = totalLines + ": " + String;

		switch (type)
		{
			default:
				history.AppendText(String + "\n");
			break;
			case GameManager.PrintType.Warning:
				history.AppendText("[color=\"yellow\"]" + String + "[/color]\n");
			break;
			case GameManager.PrintType.Error:
				history.AppendText("[color=\"red\"]" + String + "[/color]\n");
			break;
			case GameManager.PrintType.Success:
				history.AppendText("[color=\"lightskyblue\"]" + String + "[/color]\n");
			break;

		}
		totalLines++;
		focusLine++;
		tempSize.Y = focusLine * lineHeight;
		history.CustomMinimumSize = tempSize;
	}

	public void ClearConsole()
	{
		history.Clear();
		history.Text = String.Empty;
		totalLines = 0;
		focusLine = 0;
	}

	public override void _Process(double delta)
	{
		float deltaTime = (float)delta;
		switch (currentState)
		{
			default:
			break;
			case GameManager.FuncState.None:
				if (MaterialManager.consoleMaterial != null)
				{
					Material = MaterialManager.consoleMaterial;
					currentState = GameManager.FuncState.End;
				}
			break;
			case GameManager.FuncState.Start:
				if (visible)
				{
					tempPosition.Y += moveSpeed * deltaTime;
					if (tempPosition.Y > 0)
					{
						tempPosition.Y = 0;
						currentState = GameManager.FuncState.End;
						commandLine.GrabFocus();
					}
					Position = tempPosition;
				}
				else
				{
					tempPosition.Y -= moveSpeed * deltaTime;
					if (tempPosition.Y  < -halfHeight)
					{
						tempPosition.Y = -halfHeight;
						Hide();
						currentState = GameManager.FuncState.End;
					}
					Position = tempPosition;
				}
				break;
			case GameManager.FuncState.End:

				if (Input.IsActionJustPressed("Action_WeaponSwitch_Down_0"))
					Scroll(false);
				else if (Input.IsActionJustPressed("Action_WeaponSwitch_Up_0"))
					Scroll(true);
				break;
		}
	}

	public void Scroll(bool up)
	{
		if ((up) && (focusLine > 0))
			focusLine--;
		else if (focusLine != totalLines)
			focusLine++;
		tempSize.Y = focusLine * lineHeight;
		history.CustomMinimumSize = tempSize;
	}
	
}
```

./Assets/Scripts/Managers/SoundManager.cs:
```
﻿using Godot;
using System;
using System.IO;
using System.Collections.Generic;
public static class SoundManager
{
	public static Dictionary<string, AudioStream> Sounds = new Dictionary<string, AudioStream>();

	public static void AddSounds(SoundData[] sounds)
	{
		if (sounds.Length == 0)
			return;

		foreach (var sound in sounds)
			Sounds.Add(sound.name, sound.sound);
	}

	public static AudioStream LoadSound(string soundName, bool loop = false, bool music = false)
	{
		AudioStream clip;
		if (Sounds.TryGetValue(soundName, out clip))
			return clip;

		string FileName;
		string dir = "sound/";
		if (music)
			dir = "";

		byte[] WavSoudFile;
		string path = Directory.GetCurrentDirectory() + "/StreamingAssets/"+ dir + soundName + ".wav";
		if (File.Exists(path))
		{
			WavSoudFile = File.ReadAllBytes(path);
			string[] soundFileName = path.Split('/');
			clip = ToAudioStream(WavSoudFile, 0, soundFileName[soundFileName.Length - 1], loop);
		}
		else if (PakManager.ZipFiles.TryGetValue(path = (dir + soundName + ".wav").ToUpper(), out FileName))
		{
			WavSoudFile = PakManager.GetPK3FileData(path, FileName);
			string[] soundFileName = path.Split('/');
			clip = ToAudioStream(WavSoudFile, 0, soundFileName[soundFileName.Length - 1], loop);
		}
		else if (PakManager.ZipFiles.TryGetValue(path = (dir + soundName + ".ogg").ToUpper(), out FileName))
		{
			WavSoudFile = PakManager.GetPK3FileData(path, FileName);
			AudioStreamOggVorbis audio = AudioStreamOggVorbis.LoadFromBuffer(WavSoudFile);
			audio.Loop = loop;
			clip = audio;
		}
		else
			GameManager.Print("LoadSound: " + path + " not found", GameManager.PrintType.Warning);

		//If clip is null we are also adding it so we don't have to check again
		Sounds.Add(soundName, clip);
		return clip;
	}
	private static AudioStreamWav ToAudioStream(byte[] fileBytes, int offsetSamples = 0, string name = "wav", bool loop = false)
	{
		int subchunk1 = BitConverter.ToInt32(fileBytes, 16);
		ushort audioFormat = BitConverter.ToUInt16(fileBytes, 20);

		string formatCode = FormatCode(audioFormat);
		if ((audioFormat != 1) && (audioFormat != 2) && (audioFormat != 65534))
		{
			GameManager.Print("Detected format code '" + audioFormat + "' " + formatCode + ", but only PCM and WaveFormatExtensable uncompressed formats are currently supported.", GameManager.PrintType.Warning);
			return null;
		}

		ushort channels = BitConverter.ToUInt16(fileBytes, 22);
		int sampleRate = BitConverter.ToInt32(fileBytes, 24);
		ushort bitDepth = BitConverter.ToUInt16(fileBytes, 34);

		int headerOffset = 16 + 4 + subchunk1 + 4;
		int totalSamples = BitConverter.ToInt32(fileBytes, headerOffset);

		var byteArray = new byte[totalSamples];
		Buffer.BlockCopy(fileBytes, 44, byteArray, 0, byteArray.Length);

		AudioStreamWav audioStream= new AudioStreamWav();
		if (audioFormat == 2)
			audioStream.Format = AudioStreamWav.FormatEnum.ImaAdpcm;
		else
		{
			if (bitDepth == 8)
			{
				audioStream.Format = AudioStreamWav.FormatEnum.Format8Bits;
				//Change data to Signed PCM8
				for (int i = 0; i < byteArray.Length; i++)
					byteArray[i] -= 128;
			}
			else
			{
				audioStream.Format = AudioStreamWav.FormatEnum.Format16Bits;
				totalSamples = (totalSamples >> 1); //block size = 2;
			}
		}
		audioStream.Data = byteArray;
		audioStream.MixRate = sampleRate;
		if (channels == 2)
		{
			audioStream.Stereo = true;
			totalSamples = (totalSamples >> 1);
		}
		if (loop)
		{
			audioStream.LoopBegin = 0;
			audioStream.LoopEnd = totalSamples;
			audioStream.LoopMode = AudioStreamWav.LoopModeEnum.Forward;
		}
		GameManager.Print("AudioStreamWav " + name + " created. Channels " + channels + " sampleRate " + sampleRate + " totalSamples "+ totalSamples + " format " + FormatCode(audioFormat) + (loop? " Loop" : " No Looping"));
		return audioStream;
	}
	public static MultiAudioStream Create2DSound(AudioStream audio, Node3D parent = null, bool destroyAfterSound = true)
	{
		return Create3DSound(Vector3.Zero, audio, parent, destroyAfterSound, true);
	}
	public static MultiAudioStream Create3DSound(Vector3 position, AudioStream audio, Node3D parent = null, bool destroyAfterSound = true, bool is2DAudio = false)
	{
		MultiAudioStream sound = new MultiAudioStream();
		sound.Name = "3D Sound";
		if (parent == null)
			parent = GameManager.Instance.TemporaryObjectsHolder;
		
		parent.AddChild(sound);
		sound.Is2DAudio = is2DAudio;
		sound.GlobalPosition = position;
		sound.Bus = "FXBus";
		sound.Stream = audio;
		sound.DestroyAfterSoundPlayed = destroyAfterSound;
		sound.Play();
		return sound;
	}
	private static string FormatCode(ushort code)
	{
		switch (code)
		{
			case 1:
				return "PCM";
			case 2:
				return "ADPCM";
			case 3:
				return "IEEE";
			case 7:
				return "μ-law";
			case 65534:
				return "WaveFormatExtensable";
			default:
				GameManager.Print("Unknown wav code format:" + code, GameManager.PrintType.Warning);
			return "";
		}
	}
}
```

./Assets/Scripts/Managers/ClusterPVSManager.cs:
```
using Godot;
using System.Collections.Generic;

public partial class ClusterPVSManager : Node
{
	public static ClusterPVSManager Instance;
	private GeometryInstance3D[] SurfaceToCluster;
	private Dictionary<GeometryInstance3D, uint> AllClusters = new Dictionary<GeometryInstance3D, uint>();
	private const int RenderFrameMask = (0xFFFFFF << GameManager.MaxLocalPlayers);
	private const uint NoRenderLayer = (1 << GameManager.NotVisibleLayer);
	private static uint currentFrame = 0;
	public void ResetClusterList(int count)
	{
		AllClusters = new Dictionary<GeometryInstance3D, uint>();
		SurfaceToCluster = new GeometryInstance3D[count];
	}
	public override void _Ready()
	{
		Instance = this;
		RenderingServer.FramePreDraw += () => OnPreRender();
	}

	public void OnPreRender()
	{
		foreach (var (cluster, layer) in AllClusters)
		{
			if ((layer & RenderFrameMask) == currentFrame)
				cluster.Layers = (layer & 0xFF);
			else
				cluster.Layers = NoRenderLayer;
		}	
	}

	public void RegisterClusterAndSurface(GeometryInstance3D cluster, QSurface surface)
	{
		SurfaceToCluster[surface.surfaceId] = cluster;
		AllClusters.Add(cluster, 0);
	}
	public void RegisterClusterAndSurfaces(GeometryInstance3D cluster, QSurface[] surfaces)
	{
		for (int i = 0; i < surfaces.Length; i++)
			SurfaceToCluster[surfaces[i].surfaceId] = cluster;
		AllClusters.Add(cluster, 0);
	}

	public void ActivateClusterBySurface(int surface, uint layer)
	{
		uint currentLayer;
		GeometryInstance3D cluster = SurfaceToCluster[surface];
		if (cluster == null)
			return;

		currentLayer = AllClusters[cluster];
		if ((currentLayer & RenderFrameMask) == currentFrame)
			AllClusters[cluster] = currentLayer | layer;
		else
			AllClusters[cluster] = currentFrame | layer;
	}
	private static int FindCurrentLeaf(Vector3 currentPos)
	{
		// Search trought the BSP tree until the index is negative, and indicate it's a leaf.
		int i = 0;
		while (i >= 0)
		{
			// Retrieve the node and slit Plane
			QNode node = MapLoader.nodes[i];
			Plane slitPlane = MapLoader.planes[node.plane];

			// Determine whether the current position is on the front or back side of this plane.
			if (slitPlane.IsPointOver(currentPos))
			{
				// If the current position is on the front side this is the index our new tree node
				i = node.front;
			}
			else
			{
				// Otherwise, the back is the index our new tree node
				i = node.back;
			}
		}
		//  abs(index value + 1) is our leaf
		return ~i;
	}

	private static bool IsClusterVisible(int current, int test)
	{
		// If the bitSets array is empty, make all the clusters as visible
		if (MapLoader.visData.bitSets.Length == 0)
			return true;

		// If the player is no-clipping then don't draw
		if (current < 0)
			return false;

		// Calculate the index of the test cluster in the bitSets array
		int testIndex = test / 8;

		// Retrieve the appropriate byte from the bitSets array
		byte visTest = MapLoader.visData.bitSets[(current * MapLoader.visData.bytesPerCluster) + (testIndex)];

		// Check if the test cluster is marked as visible in the retrieved byte
		bool visible = ((visTest & (1 << (test & 7))) != 0);

		// Return whether or not the cluster is visible
		return visible;
	}

	public static void CheckPVS(uint viewLayer, Vector3 currentPos)
	{
		// Find the index of the current leaf
		int leafIndex = FindCurrentLeaf(currentPos);

		// Get the cluster the current leaf belongs to
		int cluster = MapLoader.leafs[leafIndex].cluster;

		// Loop through all leafs in the map
		int i = MapLoader.leafs.Count;
		while (i-- != 0)
		{
			QLeaf leaf = MapLoader.leafs[i];

			//If negative, then leaf is back leaf and contains no visibility data
			if (leaf.cluster < 0)
				continue;

			// Check if the leaf's cluster is visible from the current leaf's cluster
			if (!IsClusterVisible(cluster, leaf.cluster))
				continue;

			// Loop through all the surfaces in the leaf
			int surfaceCount = leaf.numOfLeafFaces;
			while (surfaceCount-- != 0)
			{
				int surfaceId = MapLoader.leafsSurfaces[leaf.leafSurface + surfaceCount];

				// Check if the surface has already been added to be render in the current frame
				// and that the layer mask is not visible to the player
				if ((MapLoader.leafRenderFrameLayer[surfaceId] & RenderFrameMask) == currentFrame)
				{
					if ((MapLoader.leafRenderFrameLayer[surfaceId] & viewLayer) != 0)
						continue;
					// Add the player layer mask to the surface in the current frame
					MapLoader.leafRenderFrameLayer[surfaceId] |= viewLayer;
				}
				else // Add the player layer mask and the current frame to the surface
					MapLoader.leafRenderFrameLayer[surfaceId] = currentFrame | viewLayer;

				// Activate the cluster associated with the surface
				Instance.ActivateClusterBySurface(surfaceId, (uint)viewLayer);
			}
		}
	}

	public override void _Process(double delta)
	{
		if (GameManager.CurrentState != GameManager.FuncState.Start)
			return;

		currentFrame = (uint)(Engine.GetFramesDrawn() << GameManager.MaxLocalPlayers);
		foreach (PlayerThing player in GameManager.Instance.Players)
			CheckPVS(player.playerInfo.viewLayer, player.playerInfo.playerCamera.CurrentCamera.GlobalPosition);

	}
}
```

./Assets/Scripts/Managers/MaterialManager.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;

public partial class MaterialManager : Node
{
	public static MaterialManager Instance;
	[Export]
	public ShaderMaterial illegal;
	[Export]
	public ShaderMaterial fogMaterial;
	[Export]
	public ShaderMaterial defaultMaterial;
	[Export]
	public ShaderMaterial defaultTransparentMaterial;
	[Export]
	public ShaderMaterial defaultLightMapMaterial;
	[Export]
	public ShaderMaterial defaultTransparentLightMapMaterial;
	[Export]
	public ShaderMaterial decalsMapMaterial;
	[Export]
	public ShaderMaterial baseCameraMaterial;
	[Export]
	public ShaderMaterial underWaterMaterial;
	[Export]
	public ShaderMaterial painModelMaterial;
	[Export]
	public Resource[] _extraTextures;
	[Export]
	public string[] _decalsNames;
	[Export]
	public string[] _extraQShaders;

	//PowerUps FX Material
	public static ShaderMaterial quadFxMaterial;
	public static string quadFxShader = "POWERUPS/QUAD";
	public static ShaderMaterial quadWeaponFxMaterial;
	public static string quadWeaponFxShader = "POWERUPS/QUADWEAPON";
	public static ShaderMaterial battleSuitFxMaterial;
	public static string battleSuitFxShader = "POWERUPS/BATTLESUIT";
	public static ShaderMaterial battleSuitWeaponFxMaterial;
	public static string battleSuitWeaponFxShader = "POWERUPS/BATTLEWEAPON";
	public static ShaderMaterial battleSuitAndQuadFxMaterial;
	public static ShaderMaterial battleSuitAndQuadWeaponFxMaterial;
	public static ShaderMaterial invisFxMaterial;
	public static ShaderMaterial invisWeaponFxMaterial;
	public static string invisFxShader = "POWERUPS/INVISIBILITY";
	public static ShaderMaterial regenFxMaterial;
	public static string regenFxShader = "POWERUPS/REGEN";
	public static ShaderMaterial regenWeaponFxMaterial;
	public static string regenWeaponFxShader = "POWERUPS/REGENWEAPON";

	public static ShaderMaterial consoleMaterial;
	public static string consoleShader = "CONSOLE";
	public static FogMaterial waterFogMaterial;
	public static FogMaterial lavaFogMaterial;
	public static FogMaterial slimeFogMaterial;

	[Export]
	public bool applyLightmaps = true;

	public static string shadowProperty = "ShadowIntensity";
	public static string lightMapProperty = "shader_parameter/LightMap";
	public static string opaqueTexProperty = "shader_parameter/Tex_0";
	public static string screenTexure = "screen_texture";
	public static string normalDepthTexture = "normal_depth_texture";
	public static string painTexure = "pain_texture";
	public static string pickUpTexture = "pick_up_texture";
	public static string advertisementTexture = "TEXTURES/AD_CONTENT/AD2X1";

	public static List<string> Decals = new List<string>();
	public static List<string> FogShaders = new List<string>();
	public static HashSet<string> HasBillBoard = new HashSet<string>() { "FLARESHADER" };
	public static List<string> PortalMaterials = new List<string>();
	public static List<ShaderMaterial> AllMaterials = new List<ShaderMaterial>();
	public static HashSet<string> AdsMaterials = new HashSet<string>();
	public static Dictionary<string, ShaderMaterial> Materials = new Dictionary<string, ShaderMaterial>();
	public static Dictionary<string, ShaderMaterial> MirrorMaterials = new Dictionary<string, ShaderMaterial>();
	public static Dictionary<string, QShader> AditionalTextures = new Dictionary<string, QShader>();

	public override void _Ready()
	{
		Instance = this;
		Image image = ((CompressedTexture2D)illegal.Get("shader_parameter/Tex_0")).GetImage();
		TextureLoader.illegal = ImageTexture.CreateFromImage(image);
		foreach (string name in _decalsNames)
		{
			string upperName = name.ToUpper();
			GameManager.Print("Decal Texture Name: " + upperName);
			Decals.Add(upperName);
		}

		waterFogMaterial = new FogMaterial();
		waterFogMaterial.Density = .25f;
		waterFogMaterial.Albedo = new Color(.16f, .46f, .52f);
		waterFogMaterial.Emission = new Color(.3f, .3f, .35f);

		lavaFogMaterial = new FogMaterial();
		lavaFogMaterial.Density = .3f;
		lavaFogMaterial.Albedo = new Color(.91f, .18f, .18f);
		lavaFogMaterial.Emission = new Color(.75f, .38f, .0f);

		slimeFogMaterial = new FogMaterial();
		slimeFogMaterial.Density = .3f;
		slimeFogMaterial.Albedo = new Color(.12f, .45f, .25f);
		slimeFogMaterial.Emission = new Color(.10f, .87f, .40f);

		foreach (Resource res in _extraTextures)
			TextureLoader.LoadTexturesFromResource(res);

		TextureLoader.CreateWhiteImage();
	}

	public void AddExtraShaders()
	{
		foreach (string FileName in _extraQShaders)
		{
			var file = FileAccess.Open(FileName, FileAccess.ModeFlags.Read);
			if (file != null)
			{
				byte[] content = file.GetBuffer((long)file.GetLength());
				QShaderManager.ReadShaderData(content);
			}
		}
	}

	public static void SetAmbient()
	{
		RenderingServer.GlobalShaderParameterSet("AmbientColor", GameManager.Instance.ambientLightColor);
		RenderingServer.GlobalShaderParameterSet("mixBrightness", GameManager.Instance.mixBrightness);
	}

	public static void LoadFXShaders()
	{
		bool useAlpha = false;
		bool hasPortal = false;
		List<int> stage = new List<int>
		{
			0
		};
		quadFxMaterial = QShaderManager.GetShadedMaterial(quadFxShader, -1, ref useAlpha, ref hasPortal, stage);
		quadWeaponFxMaterial = QShaderManager.GetShadedMaterial(quadWeaponFxShader, -1, ref useAlpha, ref hasPortal, stage, true);
		battleSuitFxMaterial = QShaderManager.GetShadedMaterial(battleSuitFxShader, -1, ref useAlpha, ref hasPortal, stage);
		battleSuitWeaponFxMaterial = QShaderManager.GetShadedMaterial(battleSuitWeaponFxShader, -1, ref useAlpha, ref hasPortal, stage, true);
		invisFxMaterial = QShaderManager.GetShadedMaterial(invisFxShader, -1, ref useAlpha, ref hasPortal, stage);
		invisWeaponFxMaterial = QShaderManager.GetShadedMaterial(invisFxShader, -1, ref useAlpha, ref hasPortal, stage, true);
		regenFxMaterial = QShaderManager.GetShadedMaterial(regenFxShader, -1, ref useAlpha, ref hasPortal, stage);
		regenWeaponFxMaterial = QShaderManager.GetShadedMaterial(regenWeaponFxShader, -1, ref useAlpha, ref hasPortal, stage, true);

		consoleMaterial = QShaderManager.GetShadedMaterial(consoleShader, -1, ref useAlpha, ref hasPortal, null, false, true);

		battleSuitAndQuadFxMaterial = (ShaderMaterial)battleSuitFxMaterial.Duplicate(true);
		battleSuitAndQuadFxMaterial.NextPass = quadFxMaterial;

		battleSuitAndQuadWeaponFxMaterial = (ShaderMaterial)battleSuitWeaponFxMaterial.Duplicate(true);
		battleSuitAndQuadWeaponFxMaterial.NextPass = quadWeaponFxMaterial;
	}

	public static void AddBillBoard(string shaderName)
	{
		if (HasBillBoard.Contains(shaderName))
			return;
		HasBillBoard.Add(shaderName);
	}

	public static void AddFog(string shaderName)
	{
		if (FogShaders.Contains(shaderName))
			return;
		FogShaders.Add(shaderName);
	}

	public static void AddPortalMaterial(string shaderName)
	{
		if (PortalMaterials.Contains(shaderName))
			return;
		PortalMaterials.Add(shaderName);
	}
	public static bool IsPortalMaterial(string shaderName)
	{
		if (PortalMaterials.Contains(shaderName))
			return true;
		return false;
	}
	public static bool IsSkyTexture(string textureName)
	{
		if (textureName.Contains("/SKIES/"))
			return true;
		return false;
	}

	public static bool IsFogMaterial(string shaderName)
	{
		if (FogShaders.Contains(shaderName))
			return true;
		return false;
	}

	void AddAditionalTextures(string textureName, bool addAlpha = false)
	{
		QShader shader = new QShader(textureName, 0, 0, addAlpha);
		if (!AditionalTextures.ContainsKey(textureName))
			AditionalTextures.Add(textureName, shader);
	}
	public static ShaderMaterial GetMaterials(string textureName, int lm_index)
	{
		bool forceSkinAlpha = false;
		bool hasPortal = false;
		return GetMaterials(textureName, lm_index, ref forceSkinAlpha, ref hasPortal);
	}
	public static ShaderMaterial GetMaterials(string textureName, int lm_index, ref bool forceSkinAlpha)
	{
		bool hasPortal = false;
		return GetMaterials(textureName, lm_index, ref forceSkinAlpha, ref hasPortal);
	}
	public static ShaderMaterial GetMaterials(string textureName, int lm_index , ref bool forceSkinAlpha, ref bool hasPortal)
	{
		ShaderMaterial mat;
		ImageTexture lmap = null;

		// Lightmapping is on, so calc the lightmaps
		if (lm_index >= 0 && Instance.applyLightmaps)
			lmap = MapLoader.lightMaps[lm_index];

		if (Materials.TryGetValue(textureName, out ShaderMaterial sourceMat))
		{
			if (hasPortal = IsPortalMaterial(textureName))
			{
				mat = (ShaderMaterial)sourceMat.Duplicate(true);
				if (lm_index >= 0 && Instance.applyLightmaps)
					mat.Set(lightMapProperty, lmap);
				return mat;
			}

			if (lm_index >= 0 && Instance.applyLightmaps)
			{
				mat = (ShaderMaterial)sourceMat.Duplicate(true);
				ShaderMaterial lastMaterial = mat;
				while ((lastMaterial != null) && (lm_index >= 0 && Instance.applyLightmaps))
				{
					lastMaterial.Set(lightMapProperty, lmap);
					lastMaterial = (ShaderMaterial)lastMaterial.NextPass;
				}
			}
			else
				mat = sourceMat;
			return mat;
		}

		if (Decals.Contains(textureName))
		{
			GD.Print("Decal found: " + textureName);
			if (!TextureLoader.Textures.ContainsKey(textureName))
				TextureLoader.AddNewTexture(textureName, false);
			ImageTexture tex = TextureLoader.GetTexture(textureName);
			mat = (ShaderMaterial)Instance.decalsMapMaterial.Duplicate(true);
			mat.Set(opaqueTexProperty, tex);
		}
		else
		{
			mat = QShaderManager.GetShadedMaterial(textureName, lm_index, ref forceSkinAlpha, ref hasPortal);
			ShaderMaterial lastMaterial = mat;
			while ((lastMaterial != null) && (lm_index >= 0 && Instance.applyLightmaps))
			{
				lastMaterial.Set(lightMapProperty, lmap);
				lastMaterial = (ShaderMaterial)lastMaterial.NextPass;
			}
		}
		if (mat == null)
		{
			if (lm_index >= 0 && Instance.applyLightmaps)
			{
				if (forceSkinAlpha)
					mat = (ShaderMaterial)Instance.defaultTransparentLightMapMaterial.Duplicate(true);
				else
					mat = (ShaderMaterial)Instance.defaultLightMapMaterial.Duplicate(true);
				mat.Set(lightMapProperty, lmap);
			}
			else
			{
				if (forceSkinAlpha)
					mat = (ShaderMaterial)Instance.defaultTransparentMaterial.Duplicate(true);
				else
					mat = (ShaderMaterial)Instance.defaultMaterial.Duplicate(true);
			}

			ImageTexture tex = TextureLoader.GetTexture(textureName);
			mat.Set(opaqueTexProperty, tex);
		}
		else if (lm_index >= 0 && Instance.applyLightmaps)
			mat.Set(lightMapProperty, lmap);

		//Don't reuse Quake Live Ads Materials
		if (!AdsMaterials.Contains(textureName))
			Materials.Add(textureName, mat);
		return mat;
	}
	public static ShaderMaterial GetMirrorMaterial(string shaderName)
	{
		ShaderMaterial mat;
		if (MirrorMaterials.TryGetValue(shaderName, out mat))
			return (ShaderMaterial)mat.Duplicate(true);

		mat = QShaderManager.MirrorShader(shaderName);
		MirrorMaterials.Add(shaderName, mat);
		return mat;
	}
}
```

./Assets/Scripts/Managers/ThingsManager.cs:
```
using Godot;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using ExtensionMethods;

public partial class ThingsManager : Node
{
	[Export]
	public PackedScene[] _fxPrefabs;
	[Export]
	public PackedScene[] _projectilesPrefabs;
	[Export]
	public PackedScene[] _decalsPrefabs;
	[Export]
	public PackedScene[] _ammoPrefabs;
	[Export]
	public PackedScene[] _debrisPrefabs;
	[Export]
	public PackedScene[] _gibsPrefabs;
	[Export]
	public PackedScene[] _weaponsPrefabs;
	[Export]
	public PackedScene[] _healthsPrefabs;
	[Export]
	public PackedScene[] _armorPrefabs;
	[Export]
	public PackedScene[] _powerUpsPrefabs;
	[Export]
	public PackedScene[] _funcPrefabs;
	[Export]
	public PackedScene[] _infoPrefabs;
	[Export]
	public PackedScene[] _miscPrefabs;
	[Export]
	public PackedScene[] _targetPrefabs;
	[Export]
	public PackedScene[] _triggerPrefabs;
	[Export]
	public Texture2D[] _smallCrosshairs;
	[Export]
	public Texture2D[] _largeCrosshairs;

	public static Dictionary<string, PackedScene> pickablePrefabs = new Dictionary<string, PackedScene>();
	public static Dictionary<string, PackedScene> thingsPrefabs = new Dictionary<string, PackedScene>();
	public static List<Entity> entitiesOnMap = new List<Entity>();
	public static List<PortalSurface> portalSurfaces = new List<PortalSurface>();
	public static Dictionary<string, List<Target>> targetsOnMap = new Dictionary<string, List<Target>>();
	public static Dictionary<string, Camera3D> portalCameras = new Dictionary<string, Camera3D>();
	public static Dictionary<string, TriggerController> triggerToActivate = new Dictionary<string, TriggerController>();
	public static Dictionary<string, Dictionary<string, string>> timersOnMap = new Dictionary<string, Dictionary<string, string>>();
	public static Dictionary<string, List<Dictionary<string, string>>> triggersOnMap = new Dictionary<string, List<Dictionary<string, string>>>();
	public static Dictionary<string, ItemPickup> giveItemPickup = new Dictionary<string, ItemPickup>();
	public static Dictionary<string, ConvexPolygonShape3D> gibsShapes = new Dictionary<string, ConvexPolygonShape3D>();
	public static Dictionary<string, ThingController> uniqueThingsOnMap = new Dictionary<string, ThingController>();
	public static Dictionary<string, ThingController> potentialuniqueThingsOnMap = new Dictionary<string, ThingController>();
	public static HashSet<string> uniqueGamePlayThings = new HashSet<string>();
	public static List<Texture2D> smallCrosshairs = new List<Texture2D>();
	public static List<Texture2D> largeCrosshairs = new List<Texture2D>();
	public static Texture2D defaultCrosshair;

	public static readonly Dictionary<string, string> itemName = new Dictionary<string, string>
	{
		{ "shotgun", "weapon_shotgun" },
		{ "grenade", "weapon_grenadelauncher" }, { "grenadelauncher", "weapon_grenadelauncher" }, 
		{ "rocket", "weapon_rocketlauncher" }, { "rocketlauncher", "weapon_rocketlauncher" }, 
		{ "lightninggun", "weapon_lightning" },
		{ "rail", "weapon_railgun" }, { "railgun", "weapon_railgun" },
		{ "plasma", "weapon_plasmagun" }, { "plasmagun", "weapon_plasmagun" },
		{ "bfg10k", "weapon_bfg" },
		{ "nail", "weapon_nailgun" }, { "nailgun", "weapon_nailgun" },
		{ "chain", "weapon_chaingun" }, { "chaingun", "weapon_chaingun" },
		{ "proximity", "weapon_prox_launcher" }, { "proximitylauncher", "weapon_prox_launcher" },
		{ "hmg", "weapon_hmg" }, { "heavymachinegun", "weapon_hmg" },
		{ "bfg", "ammo_bfg" },
		{ "lightning", "ammo_lightning" },
		{ "mega", "item_health_mega" },
		{ "armor", "item_armor_body" },
	};

	public static readonly string[] quadHogReplacement = { "item_haste", "item_regen", "item_flight", "item_invis", "item_enviro", "item_health_mega", "item_armor_body", "item_armor_combat" };

	public static readonly string[] demoIgnoreItems = { "item_haste", "item_regen", "item_flight", "item_invis", "item_enviro", "weapon_grenadelauncher", "weapon_bfg", "ammo_grenades", "ammo_bfg", "weapon_nailgun", "ammo_nails","weapon_chaingun", "ammo_belt", "weapon_prox_launcher", "ammo_mines", "weapon_hmg", "ammo_hmg","ammo_pack" };
	public static readonly string[] retailIgnoreItems = { "weapon_nailgun", "ammo_nails", "weapon_chaingun", "ammo_belt", "weapon_prox_launcher", "ammo_mines", "weapon_hmg", "ammo_hmg", "ammo_pack" };
	public static readonly string[] teamArenaIgnoreItems = { "weapon_hmg", "ammo_hmg", "ammo_pack" };

	public static readonly string[] gibsParts = { "GibSkull", "GibBrain", "GibAbdomen", "GibArm", "GibChest", "GibFist", "GibFoot", "GibForearm", "GibIntestine", "GibLeg", "GibLeg" };
	public static readonly string[] ignoreThings = { "misc_model", "light", "func_group", "info_null", "info_spectator_start", "info_firstplace", "info_secondplace", "info_thirdplace" };
	public static readonly string[] triggerThings = { "func_timer", "trigger_always", "trigger_multiple", "target_relay" , "target_delay", "target_give" };
	public static readonly string[] targetThings = { "func_timer", "trigger_multiple", "target_relay", "target_delay", "target_give", "target_position", "target_location", "info_notnull", "misc_teleporter_dest", "target_teleporter", "target_push" };
	public static List<Portal> portalsOnMap = new List<Portal>();
	public static readonly string ItemDrop = "ItemDrop";
	public static readonly string Blood = "Blood";
	public static readonly string BloodTrail = "BloodTrail";
	public static readonly string Puff = "Puff";

	//Drop To Floor
	private static Rid Sphere;
	private static PhysicsShapeQueryParameters3D SphereCast;
	public override void _Ready()
	{
		foreach (var thing in _fxPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("FX Name: "+ prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _projectilesPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Projectile Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _decalsPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Decal Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _ammoPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Item Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
			pickablePrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _debrisPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Debris Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _gibsPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Gib Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _weaponsPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Weapon Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
			pickablePrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _healthsPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Health Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
			pickablePrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _armorPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Armor Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
			pickablePrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _powerUpsPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("PowerUp Name: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
			pickablePrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _funcPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Func: " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _infoPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Info : " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _miscPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Misc : " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _targetPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Target : " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var thing in _triggerPrefabs)
		{
			SceneState sceneState = thing.GetState();
			string prefabName = sceneState.GetNodeName(0);
			GameManager.Print("Trigger : " + prefabName);
			thingsPrefabs.Add(prefabName, thing);
		}
		foreach (var crosshair in _smallCrosshairs)
			smallCrosshairs.Add(crosshair);
		foreach (var crosshair in _largeCrosshairs)
			largeCrosshairs.Add(crosshair);
		defaultCrosshair = smallCrosshairs[5];
		BFGTracers.SetTracers();

		Sphere = PhysicsServer3D.SphereShapeCreate();
		SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;
		PhysicsServer3D.ShapeSetData(Sphere, .2f);

	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;

		ModelsManager.FrameProcessModels(deltaTime);
		Mesher.ProcessSprites(deltaTime);
		if ((Engine.GetFramesDrawn() % 360) == 0)
			Mesher.UpdateChangedMultiMeshes();
	}
	public static void AddGibsShapes(string name, ConvexPolygonShape3D shape3D)
	{
		gibsShapes[name] = shape3D;
	}

	public static void ReadEntities(byte[] entities)
	{
		MemoryStream ms = new MemoryStream(entities);
		StreamReader stream = new StreamReader(ms);
		string strWord;

		stream.BaseStream.Seek(0, SeekOrigin.Begin);

		while (!stream.EndOfStream)
		{
			strWord = stream.ReadLine();

			if (strWord.Length == 0)
				continue;

			if (strWord[0] != '{')
				continue;

			strWord = stream.ReadLine();
			Dictionary<string, string> entityData = new Dictionary<string, string>();
			while (strWord[0] != '}')
			{
				string[] keyValue = strWord.Split('"');
				entityData[keyValue[1].Trim('"')] = keyValue[3].Trim('"');
				strWord = stream.ReadLine();
			}
			string ClassName;
			if (!entityData.TryGetValue("classname", out ClassName))
				continue;

			if (ignoreThings.Any(s => s == ClassName))
				continue;

			if (!thingsPrefabs.ContainsKey(ClassName))
			{
				GameManager.Print(ClassName + " not found", GameManager.PrintType.Warning);
				continue;
			}

			switch (GameManager.Instance.gameConfig.GameSelect)
			{
				default:
					break;
				case GameManager.BasePak.TeamArena:
					if (teamArenaIgnoreItems.Any(s => s == ClassName)) 
						continue;
				break;
				case GameManager.BasePak.Quake3:
					if (retailIgnoreItems.Any(s => s == ClassName))
						continue;
				break;
				case GameManager.BasePak.Demo:
					if (demoIgnoreItems.Any(s => s == ClassName))
						continue;
				break;
			}

			int angle = 0;
			float fangle = 0;
			if (entityData.TryGetValue("angle", out strWord))
			{
				if (strWord.Contains(" "))
					GameManager.Print("CLASSNAME: " + ClassName + " ANGLE IS VECTOR", GameManager.PrintType.Warning);
				else if (entityData.TryGetNumValue("angle", out fangle))
					angle = (int)fangle;
			}

			Vector3 origin = Vector3.Zero;
			if (entityData.TryGetValue("origin", out strWord))
			{
				string[] values = new string[3] { "", "", "", };
				bool lastDigit = true;
				for (int i = 0, j = 0; i < strWord.Length; i++)
				{
					if ((char.IsDigit(strWord[i])) || (strWord[i] == '-') || (strWord[i] == '.'))
					{
						if (lastDigit)
							values[j] += strWord[i];
						else
						{
							j++;
							values[j] += strWord[i];
							lastDigit = true;
						}
					}
					else
						lastDigit = false;
					if ((j == 2) && (!lastDigit))
						break;
				}
				float x = values[0].GetNumValue();
				float y = values[1].GetNumValue();
				float z = values[2].GetNumValue();
				origin = new Vector3(-x, z, y);
				origin *= GameManager.sizeDividor;
			}

			bool found = false;
			if (targetThings.Any(s => s == ClassName))
			{
				found = true;
				if (entityData.TryGetValue("targetname", out string target))
				{
					List<Target> targetList = null;
					if (targetsOnMap.TryGetValue(target, out targetList))
						targetList.Add(new Target(origin, angle, entityData));
					else
					{
						targetList = new List<Target>
						{
							new Target(origin, angle, entityData)
						};
						targetsOnMap.Add(target, targetList);
					}
				}
				if (ClassName == "target_push") //Not completly done
					found = false;
			}

			if (triggerThings.Any(s => s == ClassName))
			{
				found = true;
				if (entityData.TryGetValue("target", out string target))
				{
					if (ClassName == "func_timer") //Timers
						timersOnMap.Add(target, entityData);
					else
					{
						if (ClassName == "trigger_always")
							entityData.Add("activate", "true");
						else if ((ClassName == "target_delay") || (ClassName == "target_relay") || (ClassName == "target_give")) //Need to add the delay/relay and give after
							found = false;
						List<Dictionary<string, string>> triggersList = null;
						if (triggersOnMap.TryGetValue(target, out triggersList))
							triggersList.Add(entityData);
						else
						{
							triggersList = new List<Dictionary<string, string>>
							{
								entityData
							};
							triggersOnMap.Add(target, triggersList);
						}
					}
				}
			}

			if (!found)
				entitiesOnMap.Add(new Entity(ClassName, origin, entityData));
		}

		stream.Close();
		return;
	}

	public static void UnloadThings()
	{
		entitiesOnMap = new List<Entity>();
		portalSurfaces = new List<PortalSurface>();
		targetsOnMap = new Dictionary<string, List<Target>>();
		portalCameras = new Dictionary<string, Camera3D>();
		triggerToActivate = new Dictionary<string, TriggerController>();
		timersOnMap = new Dictionary<string, Dictionary<string, string>>();
		triggersOnMap = new Dictionary<string, List<Dictionary<string, string>>>();
		giveItemPickup = new Dictionary<string, ItemPickup>();
		portalsOnMap = new List<Portal>();
		uniqueThingsOnMap = new Dictionary<string, ThingController>();
		potentialuniqueThingsOnMap = new Dictionary<string, ThingController>();
	}

	public static void AddThingsToMap()
	{
		AddTriggersOnMap();
		AddEntitiesToMap();
		AddTimersToMap();
		AddPortalsToMap();
		SpawnerManager.CheckSpawnLocations();
		//Map Creator didn't put an intermission point
		if (GameManager.Instance.interMissionCamera == null)
			CreateInterMission();

	}
	public static void CreateInterMission()
	{
		Target target = SpawnerManager.deathMatchSpawner[GD.RandRange(0, SpawnerManager.deathMatchSpawner.Count - 1)];
		Camera3D camera = new Camera3D();
		camera.Position = target.destination;
		GameManager.Instance.TemporaryObjectsHolder.AddChild(camera);
		camera.CullMask = GameManager.AllPlayerViewMask | (1 << GameManager.NotVisibleLayer);
		ScoreBoard scoreBoard = (ScoreBoard)GameManager.Instance.scoreBoard.Instantiate();
		camera.AddChild(scoreBoard);
		camera.Quaternion = Quaternion.FromEuler(new Vector3(0, Mathf.DegToRad(target.angle), 0));
		GameManager.Instance.interMissionCamera = camera;
		GameManager.Instance.SetViewPortToCamera(camera, GameManager.Instance.IntermissionViewPort);
	}

	public static void AddPortalToMap(Portal portal)
	{
		if (portalsOnMap.Contains(portal))
			return;

		portalsOnMap.Add(portal);
		GameManager.Print("Got Portal at X: " + portal.position.X + " Y: " + portal.position.Y + " Z: " + portal.position.Z);
	}

	public static void AddTriggersOnMap()
	{
		foreach (KeyValuePair<string, List<Dictionary<string, string>>> trigger in triggersOnMap)
		{
			string target = trigger.Key;
			List <Dictionary<string, string>> entityDataList = trigger.Value;

			Node3D thingObject = new Node3D();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(thingObject);
			thingObject.Name = "Trigger " + target;
			TriggerController tc = new TriggerController();
			thingObject.AddChild(tc);
			string gameType;

			foreach (Dictionary<string, string> entityData in entityDataList)
			{
				switch (GameManager.Instance.gameConfig.GameType)
				{
					default:
						break;
					case GameManager.GameType.FreeForAll:
					case GameManager.GameType.QuadHog:
					{
						if (entityData.ContainsKey("notfree"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("ffa"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("ffa"))
								continue;
						}
					}
					break;
					case GameManager.GameType.Tournament:
					{
						if (entityData.ContainsKey("notfree"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("duel"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("duel"))
								continue;
						}
					}
					break;
					case GameManager.GameType.TeamDeathmatch:
					{
						if (entityData.ContainsKey("notteam"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("tdm"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("tdm"))
								continue;
						}
					}
					break;
					case GameManager.GameType.OneFlagCTF:
					{
						if (entityData.ContainsKey("notfree"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("1f"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("1f"))
								continue;
						}
					}
					break;
					case GameManager.GameType.CaptureTheFlag:
					{
						if (entityData.ContainsKey("notteam"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("ctf"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("ctf"))
								continue;
						}
					}
					break;
					case GameManager.GameType.Overload:
					{
						if (entityData.ContainsKey("notteam"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("ob"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("ob"))
								continue;
						}
					}
					break;
					case GameManager.GameType.Harvester:
					{
						if (entityData.ContainsKey("notteam"))
							continue;
						if (entityData.TryGetValue("gametype", out gameType))
						{
							if (!gameType.Contains("har"))
								continue;
						}
						else if (entityData.TryGetValue("not_gametype", out gameType))
						{
							if (gameType.Contains("har"))
								continue;
						}
					}
					break;
					case GameManager.GameType.SinglePlayer:
					{
						if (entityData.ContainsKey("notsingle"))
							continue;
					}
					break;
				}


				if (entityData.ContainsKey("activate"))
					tc.activateOnInit = true;

				//Delays/Relays
				if (entityData["classname"].Contains("elay"))
				{
					tc.Repeatable = true;
					tc.AutoReturn = true;
					tc.AutoReturnTime = .5f;
				}

				float wait;
				if (entityData.TryGetNumValue("wait", out wait))
				{
					tc.Repeatable = true;
					tc.AutoReturn = true;
					tc.AutoReturnTime = wait;
				}

				//If this trigger is a target, then is useless to setup a dummy Area3D
				string strWord;
				if (entityData.TryGetValue("targetname", out strWord))
				{
					GameManager.Print("Skipping Area3D for " + entityData["classname"] + " as it's already targetted, targetName: " + strWord);
					continue;
				}

				if (entityData.TryGetValue("model", out strWord))
				{
					int model = int.Parse(strWord.Trim('*'));
					Area3D objCollider = new Area3D();
					thingObject.AddChild(objCollider);
					MapLoader.GenerateGeometricCollider(thingObject, objCollider, model, ContentFlags.Trigger);
					objCollider.BodyEntered += tc.OnBodyEntered;
					tc.Areas.Add(objCollider);
					if (tc.destroyPhysicsNodes)
						objCollider.CollisionMask |= (1 << GameManager.PhysicCollisionLayer);
				}
			}
			triggerToActivate.Add(target, tc);
		}
	}

	public static void AddTimersToMap()
	{
		foreach (KeyValuePair<string, Dictionary<string, string>> timer in timersOnMap)
		{
			string target = timer.Key;
			TriggerController tc;
			if (!triggerToActivate.TryGetValue(target, out tc))
				continue;

			Dictionary<string, string> entityData = timer.Value;
			Node3D node = new Node3D();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(node);
			node.Name = "Timer " + target;
			float random, wait;

			entityData.TryGetNumValue("random", out random);
			entityData.TryGetNumValue("wait", out wait);

			TimerController timerController = new TimerController();
			node.AddChild(timerController);
			timerController.Init(wait, random, tc);
		}
	}

	public static void AddEntitiesToMap()
	{
		string strWord;
		List<ThingController> thingsDroppedToFloor = new List<ThingController>();
		foreach (Entity entity in entitiesOnMap)
		{
			switch (GameManager.Instance.gameConfig.GameType)
			{
				default:
				break;
				case GameManager.GameType.FreeForAll:
				case GameManager.GameType.QuadHog:
				{
					if (entity.entityData.ContainsKey("notfree"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("ffa"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("ffa"))
							continue;
					}
				}
				break;
				case GameManager.GameType.Tournament:
				{
					if (entity.entityData.ContainsKey("notfree"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("duel"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("duel"))
							continue;
					}
				}
				break;
				case GameManager.GameType.TeamDeathmatch:
				{
					if (entity.entityData.ContainsKey("notteam"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("tdm"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("tdm"))
							continue;
					}
				}
				break;
				case GameManager.GameType.OneFlagCTF:
				{
					if (entity.entityData.ContainsKey("notfree"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("1f"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("1f"))
							continue;
					}
				}
				break;
				case GameManager.GameType.CaptureTheFlag:
				{
					if (entity.entityData.ContainsKey("notteam"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("ctf"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("ctf"))
							continue;
					}
				}
				break;
				case GameManager.GameType.Overload:
				{
					if (entity.entityData.ContainsKey("notteam"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("ob"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("ob"))
							continue;
					}
				}
				break;
				case GameManager.GameType.Harvester:
				{
					if (entity.entityData.ContainsKey("notteam"))
						continue;
					if (entity.entityData.TryGetValue("gametype", out strWord))
					{
						if (!strWord.Contains("har"))
							continue;
					}
					else if (entity.entityData.TryGetValue("not_gametype", out strWord))
					{
						if (strWord.Contains("har"))
							continue;
					}
				}
				break;
				case GameManager.GameType.SinglePlayer:
				{
					if (entity.entityData.ContainsKey("notsingle"))
						continue;
				}
				break;
			}

			ThingController thingObject = (ThingController)thingsPrefabs[entity.name].Instantiate();
			if (thingObject == null)
				continue;

			//Check for Unique Things according to GamePlay rules
			bool skip = false;
			foreach(string uniqueItem in uniqueGamePlayThings)
			{
				if (entity.name == uniqueItem)
				{
					thingObject.initDisabled = false;
					if (uniqueThingsOnMap.ContainsKey(entity.name))
						skip = true;
					else
					{
						thingObject.uniqueItem = true;
						uniqueThingsOnMap.Add(entity.name, thingObject);
					}
				}
				if (uniqueThingsOnMap.Count != uniqueGamePlayThings.Count)
				{
					switch (GameManager.Instance.gameConfig.GameType)
					{
						default:
						break;
						case GameManager.GameType.QuadHog:
						{
							if (quadHogReplacement.Any(s => s == entity.name))
								potentialuniqueThingsOnMap[entity.name] = thingObject;
						}
						break;
					}
				}
			}
			if (skip)
			{
				thingObject.QueueFree();
				continue;
			}

			thingObject.SpawnCheck(entity.name);

			GameManager.Instance.TemporaryObjectsHolder.AddChild(thingObject);
			thingObject.Name = entity.name;

			switch (thingObject.thingType)
			{
				default:
				case ThingController.ThingType.Item:
				{
					float num;
					thingObject.GlobalPosition = entity.origin;
					if (entity.entityData.TryGetValue("spawnflags", out strWord))
					{
						//check if 'suspended'
						if (strWord[0] != 's')
						{
							int spawnflags = int.Parse(strWord);
							//Suspended
							if ((spawnflags & 1) == 0)
								thingsDroppedToFloor.Add(thingObject);
						}
					}
					else
						thingsDroppedToFloor.Add(thingObject);

					if (entity.entityData.TryGetNumValue("wait", out num))
						thingObject.SetRespawnTime(num);

					if (entity.entityData.TryGetNumValue("random", out num))
						thingObject.SetRandomTime(num);

					if (thingObject.thingType != ThingController.ThingType.Item)
						break;

					ItemPickup itemPickup = thingObject.itemPickup;
					if (itemPickup == null)
						break;

					//GamePlay Rules:
					if ((GameManager.Instance.gameConfig.GameType == GameManager.GameType.QuadHog) && (thingObject.uniqueItem))
					{
						itemPickup.amount = 60;
						thingObject.SetRespawnTime(float.MaxValue);
					}
					else if (entity.entityData.TryGetNumValue("count", out num))
						itemPickup.amount = (int)num;

					if (entity.entityData.TryGetValue("targetname", out string target))
					{
						List<Target> targetList = null;
						if (targetsOnMap.TryGetValue(target, out targetList))
							targetList.Add(new Target(entity.origin, 0, entity.entityData));
						else
						{
							targetList = new List<Target>
							{
								new Target(entity.origin, 0, entity.entityData)
							};
							targetsOnMap.Add(target, targetList);
						}
						giveItemPickup[entity.entityData["classname"]] = itemPickup;
					}
				}
				break;
				case ThingController.ThingType.Spawn:
				{
					thingObject.GlobalPosition = entity.origin;

					if (entity.entityData.ContainsKey("nohumans"))
						continue;

					float angle = 0;
					entity.entityData.TryGetNumValue("angle", out angle);

					SpawnPosition spawnPosition = (SpawnPosition)thingObject;
					//Red Team spawning  location
					if(entity.name == "team_CTF_redspawn")
						spawnPosition.Init((int)angle, entity.entityData, SpawnPosition.SpawnType.Red);
					//Blue Team spawning  location
					else if (entity.name == "team_CTF_bluespawn")
						spawnPosition.Init((int)angle, entity.entityData, SpawnPosition.SpawnType.Blue);
					//Deathmatch spawning  location
					else
						spawnPosition.Init((int)angle, entity.entityData);
					}
				break;
				case ThingController.ThingType.Blocking:
				{
					//Advertisement
					if (entity.name == "advertisement")
					{
						if (entity.entityData.TryGetValue("model", out strWord))
						{
							int model = int.Parse(strWord.Trim('*'));
							MapLoader.GenerateGeometricSurface(thingObject, model);
							MapLoader.GenerateGeometricCollider(thingObject, null, model, 0, false);
						}
					}
					// Solid Model
					else if (entity.name == "func_static")
					{
						if (entity.entityData.TryGetValue("model", out strWord))
						{
							int model = int.Parse(strWord.Trim('*'));
							MapLoader.GenerateGeometricSurface(thingObject, model);
							MapLoader.GenerateGeometricCollider(thingObject, null, model, 0, false);
						}
						else if (entity.entityData.TryGetValue("model2", out strWord))
						{
							thingObject.GlobalPosition = entity.origin;
							ModelController modelController = new ModelController();
							thingObject.AddChild(modelController);
							modelController.modelName = strWord.Split('.')[0].Split("models/")[1];
							modelController.Init();
						}
					}
					//Platform
					else if (entity.name == "func_bobbing")
					{
						Vector3 center = Vector3.Zero;
						int model = -1;
						int angle = 0, spawnflags = 0, height = 32;
						float speed = 4, phase = 0;
						string noise;

						ModelController modelController = null;
						if (entity.entityData.TryGetValue("model", out strWord))
							model = int.Parse(strWord.Trim('*'));
						if (entity.entityData.TryGetValue("model2", out strWord))
						{
							model = -1;
							modelController = new ModelController();
							modelController.modelName = strWord.Split('.')[0].Split("models/")[1];
							modelController.Init();
							thingObject.GlobalPosition = entity.origin;
						}

						entity.entityData.TryGetNumValue("speed", out speed);
						entity.entityData.TryGetNumValue("phase", out phase);

						if (speed == 0)
						{
							if (model >= 0)
							{
								MapLoader.GenerateGeometricSurface(thingObject, model);
								MapLoader.GenerateGeometricCollider(thingObject, null, model, 0, false);
							}
							else if (modelController != null)
								thingObject.AddChild(modelController);
							break;
						}

						PlatformController platform = new PlatformController();
						thingObject.AddChild(platform);

						if (modelController != null)
							platform.AddChild(modelController);

						Node3D SourceTransform = new Node3D();
						platform.AddChild(SourceTransform);

						InterpolatedTransform interpolatedTransform = new InterpolatedTransform();
						interpolatedTransform.SetSource(SourceTransform);
						thingObject.AddChild(interpolatedTransform);

						if (entity.entityData.TryGetValue("angle", out strWord))
							angle = int.Parse(strWord);
						if (entity.entityData.TryGetValue("height", out strWord))
							height = int.Parse(strWord);
						if (entity.entityData.TryGetValue("spawnflags", out strWord))
							spawnflags = int.Parse(strWord);
						if (entity.entityData.TryGetValue("noise", out noise))
							noise = GetSoundName(noise);

						Vector3 direction = Vector3.Up;
						if ((spawnflags & 1) != 0)
							direction = Vector3.Right;
						else if ((spawnflags & 2) != 0)
							direction = Vector3.Forward;

						bool isCrusher = false;
						if (model >= 0)
						{
							uint OwnerShapeId = 0;
							CollisionObject3D shapesOwner = null;
							int shapes = 0;
							
							(OwnerShapeId, shapesOwner) = MapLoader.GenerateGeometricCollider(thingObject, platform, model, 0, false);
							if (shapesOwner == null)
							{
								shapesOwner = platform;
								OwnerShapeId = MapLoader.GenerateGeometricSurface(interpolatedTransform, shapesOwner, model);
								shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
								if (shapes == 0)
								{
									GameManager.Print("Platform model: " + model + " is not solid, no collider was generated", GameManager.PrintType.Warning);
//									thingObject.QueueFree();
//									break;
								}
							}
							else
							{
								MapLoader.GenerateGeometricSurface(interpolatedTransform, shapesOwner, OwnerShapeId, model);
								shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
							}
							Aabb BigBox = new Aabb();

							for (int i = 0; i < shapes; i++)
							{
								Shape3D shape = shapesOwner.ShapeOwnerGetShape(OwnerShapeId, i);
								Aabb box = shape.GetDebugMesh().GetAabb();
								if (i == 0)
									BigBox = new Aabb(box.Position, box.Size);
								else
									BigBox = BigBox.Merge(box);
							}
							center = BigBox.GetCenter();
							if (shapes > 0)
								isCrusher = true;
						}
						platform.Init(direction, speed, phase, height, isCrusher, center, noise);
					}
				}
				break;
				case ThingController.ThingType.Decor:
				{
					thingObject.GlobalPosition = entity.origin;

					//Rotating Object
					if (entity.name == "func_rotating")
					{
						int speed = 100;
						NodeAnimation nodeAnim = new NodeAnimation();
						thingObject.AddChild(nodeAnim);
						if (entity.entityData.TryGetValue("speed", out strWord))
							speed = int.Parse(strWord);
						nodeAnim.rotFPS = speed;
						nodeAnim.rotEnable = true;
						if (entity.entityData.TryGetValue("model2", out strWord))
						{
							ModelController modelController = new ModelController();
							thingObject.AddChild(modelController);
							modelController.modelName = strWord.Split('.')[0].Split("models/")[1];
							modelController.Init();
						}
						nodeAnim.Init();
					}
					//Intermission Camera
					else if (entity.name == "info_player_intermission")
					{
						Camera3D camera = new Camera3D();
						thingObject.AddChild(camera);
						camera.CullMask = GameManager.AllPlayerViewMask | (1 << GameManager.NotVisibleLayer);
						ScoreBoard scoreBoard = (ScoreBoard)GameManager.Instance.scoreBoard.Instantiate();
						camera.AddChild(scoreBoard);

						int angle = 0;
						Vector3 lookAt = Vector3.Forward;

						if (entity.entityData.TryGetValue("target", out strWord))
							if (targetsOnMap.ContainsKey(strWord))
							{
								lookAt = targetsOnMap[strWord][0].destination;
								if (Mathf.IsZeroApprox(lookAt.Dot(Vector3.Forward)))
									thingObject.LookAt(lookAt, Vector3.Forward);
								else
									thingObject.LookAt(lookAt, Vector3.Up);
								angle = targetsOnMap[strWord][0].angle;
							}
						GameManager.Instance.interMissionCamera = camera;
						GameManager.Instance.SetViewPortToCamera(camera, GameManager.Instance.IntermissionViewPort);
					}
				}
				break;
				case ThingController.ThingType.Teleport:
				{
					//Portal Camera
					if (entity.name == "misc_portal_camera")
					{
						thingObject.GlobalPosition = entity.origin;

						int angle = 0;
						Vector3 lookAt = Vector3.Forward;

						if (entity.entityData.TryGetValue("target", out strWord))
							if (targetsOnMap.ContainsKey(strWord))
							{
								lookAt = targetsOnMap[strWord][0].destination;
								if (Mathf.IsZeroApprox(lookAt.Dot(Vector3.Forward)))
									thingObject.LookAt(lookAt, Vector3.Forward);
								else
									thingObject.LookAt(lookAt, Vector3.Up);
								angle = targetsOnMap[strWord][0].angle;
							}

						if (entity.entityData.TryGetValue("targetname", out strWord))
						{
							Camera3D camera = new Camera3D();
							thingObject.AddChild(camera);
							camera.CullMask = GameManager.AllPlayerViewMask;
							portalCameras.Add(strWord, camera);
						}
					}
					//Portal Surface
					else if (entity.name == "misc_portal_surface")
					{
						PortalSurface portalSurface = new PortalSurface();
						GameManager.Instance.TemporaryObjectsHolder.AddChild(portalSurface);
						portalSurface.GlobalPosition = entity.origin;
						if (entity.entityData.TryGetValue("target", out strWord))
						{
							portalSurface.targetName = strWord;
							GameManager.Print("TargetName " + strWord);
						}
						portalSurfaces.Add(portalSurface);
						thingObject.QueueFree();
					}
					//Teleporter
					else if (entity.name == "trigger_teleport")
					{
						string target;
						List<Target> dest;
						if (!entity.entityData.TryGetValue("target", out target))
							continue;
						if (!targetsOnMap.TryGetValue(target, out dest))
							continue;
						if (!entity.entityData.TryGetValue("model", out strWord))
							continue;

						TeleporterThing teleporter = new TeleporterThing();
						thingObject.AddChild(teleporter);
						int model = int.Parse(strWord.Trim('*'));
						MapLoader.GenerateGeometricCollider(thingObject, teleporter, model, ContentFlags.Teleporter);
						teleporter.Init(dest, entity.entityData);
					}
				}
				break;
				case ThingController.ThingType.Door:
				{
					//Switch
					if (entity.name == "func_button")
					{
						strWord = entity.entityData["model"];
						int model = int.Parse(strWord.Trim('*'));
						int angle = 0, hitpoints = 0, speed = 40, lip = 4;
						float wait;

						SwitchController sw = new SwitchController();
						thingObject.AddChild(sw);

						sw.startSound = "movers/switches/butn2";
						sw.endSound = "";

						if (entity.entityData.TryGetValue("angle", out strWord))
							angle = int.Parse(strWord);
						if (entity.entityData.TryGetValue("health", out strWord))
							hitpoints = int.Parse(strWord);
						if (entity.entityData.TryGetValue("speed", out strWord))
							speed = int.Parse(strWord);
						if (!entity.entityData.TryGetNumValue("wait", out wait))
							wait = 1;
						if (entity.entityData.TryGetValue("lip", out strWord))
							lip = int.Parse(strWord);

						uint OwnerShapeId = 0;
						CollisionObject3D shapesOwner = null;
						int shapes = 0;
							
						(OwnerShapeId, shapesOwner) = MapLoader.GenerateGeometricCollider(thingObject, sw, model, ContentFlags.Solid, false);
						if (shapesOwner == null)
						{
							shapesOwner = sw;
							OwnerShapeId = MapLoader.GenerateGeometricSurface(sw, shapesOwner, model);
							shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
							if (shapes == 0)
							{
								GameManager.Print("Switch model: " + model + " is not valid, no collider was generated", GameManager.PrintType.Warning);
								thingObject.QueueFree();
								break;
							}
						}
						else
						{
							MapLoader.GenerateGeometricSurface(sw, shapesOwner, OwnerShapeId, model);
							shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
						}
						Aabb BigBox = new Aabb();
						for (int i = 0; i < shapes; i++)
						{
							Shape3D boxShape = shapesOwner.ShapeOwnerGetShape(OwnerShapeId, i);
							Aabb box = boxShape.GetDebugMesh().GetAabb();
							if (i == 0)
								BigBox = new Aabb(box.Position, box.Size);
							else
								BigBox = BigBox.Merge(box);
						}
						sw.Init(angle, hitpoints, speed, wait, lip, BigBox);

						//If it's not damagable, then create trigger collider
						if (hitpoints == 0)
						{
							float max = BigBox.GetLongestAxisSize();
							Area3D triggerCollider = new Area3D();
							sw.AddChild(triggerCollider);
							CollisionShape3D mc = new CollisionShape3D();
							mc.Name = "Switch Trigger";
							triggerCollider.AddChild(mc);
							triggerCollider.CollisionLayer = (1 << GameManager.WalkTriggerLayer);
							triggerCollider.CollisionMask = GameManager.TakeDamageMask;
							triggerCollider.InputRayPickable = false;

							SphereShape3D sphere = new SphereShape3D();
							sphere.Radius = max;
							mc.Shape = sphere;
							triggerCollider.GlobalPosition = BigBox.GetCenter();
							triggerCollider.BodyEntered += sw.internalSwitch.OnBodyEntered;
							sw.internalSwitch.Areas.Add(triggerCollider);
						}

						if (entity.entityData.TryGetValue("target", out strWord))
						{
							string target = strWord;
							TriggerController tc;
							if (!triggerToActivate.TryGetValue(target, out tc))
								tc = null;
							sw.tc = tc;

							sw.internalSwitch.SetController(target, (p) =>
							{
								if (sw.tc == null)
								{
									TriggerController swTrigger;
									if (!triggerToActivate.TryGetValue(sw.internalSwitch.triggerName, out swTrigger))
										return;
									sw.tc = swTrigger;
								}
								sw.CurrentState = DoorController.State.Opening;
								sw.tc.Activate(null);
							});
						}
					}
					//Elevator
					else if (entity.name == "func_plat")
					{
						int model = -1;
						int height = 0, speed = 150, lip = 16, dmg = 4;

						ModelController modelController = null;

						if (entity.entityData.TryGetValue("model", out strWord))
							model = int.Parse(strWord.Trim('*'));
						if (entity.entityData.TryGetValue("model2", out strWord))
						{
							model = -1;
							modelController = new ModelController();
							modelController.modelName = strWord.Split('.')[0].Split("models/")[1];
							modelController.Init();
							thingObject.GlobalPosition = entity.origin;
						}

						ElevatorController elevator = new ElevatorController();
						thingObject.AddChild(elevator);

						if (modelController != null)
							elevator.AddChild(modelController);
						
						Node3D SourceTransform = new Node3D();
						elevator.AddChild(SourceTransform);

						InterpolatedTransform interpolatedTransform = new InterpolatedTransform();
						interpolatedTransform.SetSource(SourceTransform);
						thingObject.AddChild(interpolatedTransform);

						if (entity.entityData.TryGetValue("height", out strWord))
							height = int.Parse(strWord);
						if (entity.entityData.TryGetValue("speed", out strWord))
							speed = int.Parse(strWord);
						if (entity.entityData.TryGetValue("lip", out strWord))
							lip = int.Parse(strWord);
						if (entity.entityData.TryGetValue("dmg", out strWord))
							dmg = int.Parse(strWord);

						Aabb BigBox = new Aabb();
						if (model >= 0)
						{
							uint OwnerShapeId = 0;
							CollisionObject3D shapesOwner = null;
							int shapes = 0;

							(OwnerShapeId, shapesOwner) = MapLoader.GenerateGeometricCollider(thingObject, elevator, model, 0, false);
							if (shapesOwner == null)
							{
								shapesOwner = elevator;
								OwnerShapeId = MapLoader.GenerateGeometricSurface(interpolatedTransform, shapesOwner, model);
								shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
								if (shapes == 0)
								{
									GameManager.Print("Elevator model: " + model + " is not solid, no collider was generated", GameManager.PrintType.Warning);
//									thingObject.QueueFree();
//									break;
								}
							}
							else
							{
								MapLoader.GenerateGeometricSurface(interpolatedTransform, shapesOwner, OwnerShapeId, model);
								shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
							}

							for (int i = 0; i < shapes; i++)
							{
								Shape3D shape = shapesOwner.ShapeOwnerGetShape(OwnerShapeId, i);
								Aabb box = shape.GetDebugMesh().GetAabb();
								if (i == 0)
									BigBox = new Aabb(box.Position, box.Size);
								else
									BigBox = BigBox.Merge(box);
							}
						}

						elevator.Init(speed, height, lip, BigBox, model, dmg);

						if (entity.entityData.TryGetValue("targetname", out string target))
						{
							TriggerController tc;
							if (!triggerToActivate.TryGetValue(target, out tc))
							{
								tc = new TriggerController();
								thingObject.AddChild(tc);
								triggerToActivate.Add(target, tc);
							}
							tc.Repeatable = true;
							tc.AutoReturn = true;
							tc.AutoReturnTime = 1;
							tc.SetController(target, (p) =>
							{
								switch(elevator.CurrentState)
								{
									default:
										elevator.CurrentState = ElevatorController.State.Rising;
									break;
									case ElevatorController.State.Up:
										elevator.CurrentState = ElevatorController.State.Up;
									break;
									case ElevatorController.State.Rising:
									break;
								}
							});
						}
						else //If it's not external trigger
						{
							Area3D triggerCollider = new Area3D();
							elevator.AddChild(triggerCollider);
							CollisionShape3D mc = new CollisionShape3D();
							mc.Name = "Elevator Trigger";
							triggerCollider.AddChild(mc);
							triggerCollider.CollisionLayer = (1 << GameManager.WalkTriggerLayer);
							triggerCollider.CollisionMask = GameManager.TakeDamageMask;
							triggerCollider.InputRayPickable = false;

							BoxShape3D box = new BoxShape3D();
							box.Size = BigBox.Size;
							mc.Shape = box;

							TriggerController tc = new TriggerController();
							thingObject.AddChild(tc);
							tc.Repeatable = true;
							tc.AutoReturn = true;
							tc.AutoReturnTime = 1;
							tc.SetController("", (p) =>
							{
								switch (elevator.CurrentState)
								{
									default:
										elevator.CurrentState = ElevatorController.State.Rising;
									break;
									case ElevatorController.State.Up:
										elevator.CurrentState = ElevatorController.State.Up;
									break;
									case ElevatorController.State.Rising:
									break;
								}
							});

							if (model >= 0)
								triggerCollider.GlobalPosition = BigBox.GetCenter();
							else
								triggerCollider.GlobalPosition = entity.origin;

							triggerCollider.BodyEntered += tc.OnBodyEntered;
							tc.Areas.Add(triggerCollider);
						}
					}
					//Door
					else if (entity.name == "func_door")
					{
						strWord = entity.entityData["model"];
						int model = int.Parse(strWord.Trim('*'));
						int angle = 0, hitpoints = 0, speed = 200, lip = 8, dmg = 4;
						float wait;

						DoorController door = new DoorController();
						thingObject.AddChild(door);

						Node3D SourceTransform = new Node3D();
						door.AddChild(SourceTransform);

						InterpolatedTransform interpolatedTransform = new InterpolatedTransform();
						interpolatedTransform.SetSource(SourceTransform);
						thingObject.AddChild(interpolatedTransform);

						if (entity.entityData.TryGetValue("angle", out strWord))
							angle = int.Parse(strWord);
						if (entity.entityData.TryGetValue("health", out strWord))
							hitpoints = int.Parse(strWord);
						if (entity.entityData.TryGetValue("speed", out strWord))
							speed = int.Parse(strWord);
						if (!entity.entityData.TryGetNumValue("wait", out wait))
							wait = 2;
						if (entity.entityData.TryGetValue("lip", out strWord))
							lip = int.Parse(strWord);
						if (entity.entityData.TryGetValue("dmg", out strWord))
							dmg = int.Parse(strWord);

						uint OwnerShapeId = 0;
						CollisionObject3D shapesOwner = null;
						int shapes = 0;
						
						(OwnerShapeId, shapesOwner) = MapLoader.GenerateGeometricCollider(thingObject, door, model, ContentFlags.Solid, false);
						if (shapesOwner == null)
						{
							shapesOwner = door;
							OwnerShapeId = MapLoader.GenerateGeometricSurface(interpolatedTransform, shapesOwner, model);
							shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
							if (shapes == 0)
							{
								GameManager.Print("Door model: " + model + " is not solid, no collider was generated", GameManager.PrintType.Warning);
								thingObject.QueueFree();
								break;
							}
						}
						else
						{
							MapLoader.GenerateGeometricSurface(interpolatedTransform, shapesOwner, OwnerShapeId, model);
							shapes = shapesOwner.ShapeOwnerGetShapeCount(OwnerShapeId);
						}
						Aabb BigBox = new Aabb();

						for (int i = 0; i < shapes; i++)
						{
							Shape3D shape = shapesOwner.ShapeOwnerGetShape(OwnerShapeId, i);
							Aabb box = shape.GetDebugMesh().GetAabb();
							if (i == 0)
								BigBox = new Aabb(box.Position, box.Size);
							else
								BigBox = BigBox.Merge(box);
						}
						door.Init(angle, hitpoints, speed, wait, lip, BigBox, dmg);

						if (entity.entityData.TryGetValue("targetname", out string target))
						{
							TriggerController tc;
							if (!triggerToActivate.TryGetValue(target, out tc))
							{
								tc = new TriggerController();
								thingObject.AddChild(tc);
								triggerToActivate.Add(target, tc);
							}
							tc.Repeatable = true;
							tc.AutoReturn = true;
							tc.AutoReturnTime = wait;
							tc.SetController(target, (p) =>
							{
								door.CurrentState = DoorController.State.Opening;
							});
						}
						else //If it's not external trigger
						{
							if (hitpoints == 0)//If  not damagable, then create a trigger and collider
							{
								float max = BigBox.GetLongestAxisSize();
								Area3D triggerCollider = new Area3D();
								door.AddChild(triggerCollider);
								CollisionShape3D mc = new CollisionShape3D();
								mc.Name = "Door Trigger";
								triggerCollider.AddChild(mc);
								triggerCollider.CollisionLayer = (1 << GameManager.WalkTriggerLayer);
								triggerCollider.CollisionMask = GameManager.TakeDamageMask;
								triggerCollider.InputRayPickable = false;

								SphereShape3D sphere = new SphereShape3D();
								sphere.Radius = max * .5f;
								mc.Shape = sphere;

								TriggerController tc = new TriggerController();
								thingObject.AddChild(tc);
								tc.Repeatable = true;
								tc.AutoReturn = true;
								tc.AutoReturnTime = wait;
								tc.SetController("", (p) =>
								{
									door.CurrentState = DoorController.State.Opening;
								});

								triggerCollider.GlobalPosition = BigBox.GetCenter();
								triggerCollider.BodyEntered += tc.OnBodyEntered;
								tc.Areas.Add(triggerCollider);
							}
						}
					}
				}
				break;
				case ThingController.ThingType.Target:
				{
					//Delay
					if (entity.name == "target_delay")
					{
						string target;
						if (!entity.entityData.TryGetValue("target", out target))
							continue;
						if (entity.entityData.TryGetValue("targetname", out strWord))
						{
							float wait = 0;
							entity.entityData.TryGetNumValue("wait", out wait);

							string targetName = strWord;
							TriggerController source, relay;
							if (!triggerToActivate.TryGetValue(targetName, out source))
							{
								source = new TriggerController();
								thingObject.AddChild(source);
								triggerToActivate.Add(targetName, source);
							}

							if (!triggerToActivate.TryGetValue(target, out relay))
								relay = null;

							source.SetController(targetName, (p) =>
							{
								if (relay == null)
								{
									if (!triggerToActivate.TryGetValue(target, out relay))
										return;
								}

								relay.ActivateAfterTime(wait, p);
							});
						}
					}
					//Relay
					else if (entity.name == "target_relay")
					{
						string target;
						if (!entity.entityData.TryGetValue("target", out target))
							continue;
						if (entity.entityData.TryGetValue("targetname", out string targetName))
						{
							TriggerController source, relay;
							if (!triggerToActivate.TryGetValue(targetName, out source))
							{
								source = new TriggerController();
								thingObject.AddChild(source);
								triggerToActivate.Add(targetName, source);
							}

							if (!triggerToActivate.TryGetValue(target, out relay))
								relay = null;

							source.SetController(targetName, (p) =>
							{
								if (relay == null)
								{
									if (!triggerToActivate.TryGetValue(target, out relay))
										return;
								}
								relay.Activate(p);
							});
						}
					}
					//Give
					else if (entity.name == "target_give")
					{
						string target;
						if (!entity.entityData.TryGetValue("target", out target))
							continue;
						if (entity.entityData.TryGetValue("targetname", out string targetName))
						{
							TriggerController tc;
							if (!triggerToActivate.TryGetValue(targetName, out tc))
							{
								tc = new TriggerController();
								thingObject.AddChild(tc);
								triggerToActivate.Add(targetName, tc);
							}

							tc.SetController(targetName, (p) =>
							{
								if (p == null)
									return;

								List<Target> targetList = null;
								if (!targetsOnMap.TryGetValue(target, out targetList))
									return;
								foreach (Target target in targetList)
								{
									ItemPickup itemPickup;
									if (giveItemPickup.TryGetValue(target.entityData["classname"], out itemPickup))
										itemPickup.PickUp(p, false);
								}
							});
						}
					}
					//Location
					else if (entity.name == "target_location")
					{
						thingObject.GlobalPosition = entity.origin;
						if (entity.entityData.TryGetValue("message", out string message))
							thingObject.EditorDescription = message;
						MapLoader.Locations.Add(thingObject);
					}
					//Speaker
					else if (entity.name == "target_speaker")
					{
						strWord = GetSoundName(entity.entityData["noise"]);
						bool isAudio3d = true;
						AudioStreamPlayer audioStream2D = null;
						MultiAudioStream audioStream = null;

						thingObject.GlobalPosition = entity.origin;
						if (entity.entityData.ContainsKey("spawnflags"))
						{
							string audioFile = strWord;
							audioStream = new MultiAudioStream();
							thingObject.AddChild(audioStream);
							audioStream.Bus = "BKGBus";

							strWord = entity.entityData["spawnflags"];

							int spawnflags = int.Parse(strWord);
							if ((spawnflags & 3) != 0)
							{
								audioStream.Stream = SoundManager.LoadSound(audioFile, true);
								if ((spawnflags & 1) != 0)
									audioStream.Play();
							}
							else
							{
								if ((spawnflags & 8) != 0) //Activator Sound
								{
									if (entity.entityData.TryGetValue("targetname", out string target))
									{
										bool playerSound = false;

										if (audioFile.Contains('*'))
										{
											playerSound = true;
											audioFile = audioFile.Trim('*');
										}
										else
											audioStream.Stream = SoundManager.LoadSound(audioFile);
										TriggerController tc;
										if (!triggerToActivate.TryGetValue(target, out tc))
										{
											tc = new TriggerController();
											thingObject.AddChild(tc);
											triggerToActivate.Add(target, tc);
										}
										tc.Repeatable = true;
										tc.SetController(target, (p) =>
										{
											if (playerSound)
												p.PlayModelSound(audioFile);
											else if (audioStream != null)
												audioStream.Play();
										});
									}
								}
								else
								{
									if ((spawnflags & 4) != 0) //Global 2D Sound
									{
										isAudio3d = false;
										audioStream.QueueFree();
										audioStream2D = new AudioStreamPlayer();
										thingObject.AddChild(audioStream2D);
										audioStream2D.Stream = SoundManager.LoadSound(audioFile);
										audioStream2D.Bus = "BKGBus";
									}
									if (entity.entityData.TryGetValue("targetname", out strWord))
									{
										string target = strWord;

										TriggerController tc;
										if (!triggerToActivate.TryGetValue(target, out tc))
										{
											tc = new TriggerController();
											thingObject.AddChild(tc);
											triggerToActivate.Add(target, tc);
										}
										tc.Repeatable = true;
										tc.SetController(target, (p) =>
										{
											if (isAudio3d)
												audioStream.Play();
											else
												audioStream2D.Play();
										});
									}
								}
							}
						}
						else if (entity.entityData.ContainsKey("random"))
							AddRandomTimeToSound(thingObject, entity.entityData, audioStream2D, audioStream, isAudio3d);
					}
					//Another Jumpad
					else if (entity.name == "target_push")
					{
						if (entity.entityData.Count > 3)
							GameManager.Print("This target_push is a potential relay", GameManager.PrintType.Warning);
/*						string target;
						List<Target> dest;
						if (entity.entityData.TryGetValue("target", out target))
						{
							if (targetsOnMap.TryGetValue(target, out dest))
							{
								thingObject.GlobalPosition = entity.origin;
								JumpPadThing jumpPad = new JumpPadThing();
								thingObject.AddChild(jumpPad);
								strWord = entity.entityData["model"];
								int model = int.Parse(strWord.Trim('*'));
								Vector3 destination = dest[0].destination;
								Vector3 center = MapLoader.GenerateJumpPadCollider(jumpPad, model);
								jumpPad.Init(destination, center);
							}
							break;
						}
*/
					}
					//Remove PowerUps
					else if (entity.name ==  "target_remove_powerups")
					{
						if (entity.entityData.TryGetValue("targetname", out strWord))
						{
							string target = strWord;

							TriggerController tc;
							if (!triggerToActivate.TryGetValue(target, out tc))
							{
								tc = new TriggerController();
								thingObject.AddChild(tc);
								triggerToActivate.Add(target, tc);
							}
							else
							{
								foreach (var Area in tc.Areas)
									Area.CollisionMask |= (1 << GameManager.PhysicCollisionLayer);
							}

							tc.Repeatable = true;
							tc.destroyPhysicsNodes = true;
							tc.SetController(target, (p) =>
							{
								p.DropNothingOnDeath();
							});
						}
					}

				}
				break;
				case ThingController.ThingType.Trigger:
				{
					//Trigger Hurt
					if (entity.name == "trigger_hurt")
					{
						int dmg = 9999;
						strWord = entity.entityData["model"];
						int model = int.Parse(strWord.Trim('*'));
						if (entity.entityData.TryGetValue("dmg", out strWord))
							dmg = int.Parse(strWord);

						TriggerController tc = new TriggerController();
						thingObject.AddChild(tc);
						Area3D objCollider = new Area3D();
						thingObject.AddChild(objCollider);
						MapLoader.GenerateGeometricCollider(thingObject, objCollider, model, ContentFlags.Trigger);
						objCollider.BodyEntered += tc.OnBodyEntered;
						tc.Areas.Add(objCollider);

						tc.Repeatable = true;
						tc.SetController("trigger_hurt", (p) =>
						{
							p.Damage(dmg, DamageType.Trigger);
						});
					}
					//JumpPad
					else if (entity.name == "trigger_push")
					{
						string target;
						List<Target> dest;
						if (!entity.entityData.TryGetValue("target", out target))
							continue;
						if (!targetsOnMap.TryGetValue(target, out dest))
							continue;

						thingObject.GlobalPosition = entity.origin;
						JumpPadThing jumpPad = new JumpPadThing();
						thingObject.AddChild(jumpPad);
						strWord = entity.entityData["model"];
						int model = int.Parse(strWord.Trim('*'));
						Vector3 destination = dest[0].destination;
						Vector3 center = MapLoader.GenerateJumpPadCollider(jumpPad, model);
						jumpPad.Init(destination, center);
					}
				}
				break;
				case ThingController.ThingType.WorldSpawn:
				{
					if (entity.entityData.TryGetValue("message", out strWord))
						GameManager.Print("Map Message: " + strWord);
					if (entity.entityData.TryGetValue("music", out strWord))
					{
						if ((GameManager.Instance.gameConfig.MusicType == GameManager.MusicType.Static) || (GameManager.Instance.gameConfig.MusicType == GameManager.MusicType.Random))
						{
							string[] keyValue = strWord.Split(' ');
							if (keyValue.Length > 0)
							{
								strWord = keyValue[0].Split('.')[0].Replace('\\', '/');
								GameManager.Print("Music : " + strWord);
								GameManager.Instance.StaticMusicPlayer.Stream = SoundManager.LoadSound(strWord, true, true);
							}
						}
					}
					if (entity.entityData.TryGetValue("gravity", out strWord))
					{
						GameManager.Print("Gravity : " + strWord);
						int gravity = int.Parse(strWord);
						GameManager.Instance.gravity = gravity * GameManager.sizeDividor;
					}
					thingObject.QueueFree();
				}
				break;
			}
		}
		//Unique GameType stuff
		//Check if all uniqueThings are on the map
		if (uniqueThingsOnMap.Count != uniqueGamePlayThings.Count)
		{
			switch (GameManager.Instance.gameConfig.GameType)
			{
				default:
				break;
				case GameManager.GameType.QuadHog:
				{
					foreach(string uniqueItem in uniqueGamePlayThings)
					{
						for (int j = 0; j < quadHogReplacement.Length; j++)
						{
							string searchItem = quadHogReplacement[j];
							if (potentialuniqueThingsOnMap.TryGetValue(searchItem, out ThingController thing))
							{
								ThingController uniqueObject = (ThingController)thingsPrefabs[uniqueItem].Instantiate();
								GameManager.Instance.TemporaryObjectsHolder.AddChild(uniqueObject);
								uniqueObject.GlobalPosition = thing.GlobalPosition;
								uniqueObject.initDisabled = false;
								uniqueObject.uniqueItem = true;
								uniqueObject.SpawnCheck(uniqueItem);
								uniqueObject.Name = uniqueItem;
								ItemPickup itemPickup = uniqueObject.itemPickup;
								itemPickup.amount = 60;
								uniqueObject.SetRespawnTime(float.MaxValue);
								thing.SetRespawnTime(float.MaxValue);
								thing.DisableThing();
								uniqueThingsOnMap.Add(uniqueItem, uniqueObject);
								break;
							}
						}
					}
				}
				break;
			}
		}

		for(int i = 0; i < thingsDroppedToFloor.Count; i++)
		{
			ThingController thing = thingsDroppedToFloor[i];
			CollisionObject3D collider = null;
			thing.GlobalPosition = ItemLocationDropToFloor(thing.GlobalPosition, ref collider);

			if (collider != null)
				thing.Reparent(collider);
		}

	}

	public static Vector3 ItemLocationDropToFloor(Vector3 Origin)
	{
		CollisionObject3D collider = null;
		return ItemLocationDropToFloor(Origin, ref collider);
	}

	public static Vector3 ItemLocationDropToFloor(Vector3 Origin, ref CollisionObject3D collider)
	{
		float maxRange = 100f;
		Vector3 collision = Origin;
		Vector3 End = Origin + Vector3.Down * maxRange;

		SphereCast.CollisionMask = ((1 << GameManager.ColliderLayer) | (1 << GameManager.InvisibleBlockerLayer));
		SphereCast.Motion = End - Origin;
		SphereCast.Transform = new Transform3D(Basis.Identity, Origin);
		var SpaceState = GameManager.Instance.TemporaryObjectsHolder.GetWorld3D().DirectSpaceState;
		var result = SpaceState.CastMotion(SphereCast);

		if (result[1] < 1)
		{
			SphereCast.Transform = new Transform3D(Basis.Identity, Origin + (SphereCast.Motion * result[1]));
			var hit = SpaceState.GetRestInfo(SphereCast);
			if (hit.Count > 0)
			{
				collision = (Vector3)hit["point"] + Vector3.Up * .6f;
				collider = (CollisionObject3D)InstanceFromId((ulong)hit["collider_id"]);
			}
		}
		return collision;
	}

	public static void AddPortalsToMap()
	{
		for (int n = 0; n < portalSurfaces.Count; n++)
		{
			PortalSurface portalSurface = portalSurfaces[n];
			Portal portal = null;
			float closestPortal = 0;
			Camera3D camera;
			if (string.IsNullOrEmpty(portalSurface.targetName))
			{
				GameManager.Print("Found Mirror");
				Node3D mirror = new Node3D();
				mirror.Name = "Mirror";
				GameManager.Instance.TemporaryObjectsHolder.AddChild(mirror);
				camera = new Camera3D();
				mirror.AddChild(camera);
				camera.Projection = Camera3D.ProjectionType.Frustum;
				camera.CullMask = GameManager.AllPlayerViewMask;
				for (int i = 0; i < portalsOnMap.Count; i++)
				{
					float distance = (portalsOnMap[i].position - portalSurface.GlobalPosition).LengthSquared();
					if ((portal == null) || (distance < closestPortal))
					{
						portal = portalsOnMap[i];
						closestPortal = distance;
					}
				}
				if (portal != null)
					portalSurface.SetUpPortal(camera, portal, true);
				else
				{
					portalSurface.QueueFree();
					portalSurfaces.Remove(portalSurface);
				}
			}
			else if (portalCameras.TryGetValue(portalSurface.targetName, out camera))
			{
				GameManager.Print("Found Portal Camera " + camera.Name);
				for (int i = 0; i < portalsOnMap.Count; i++)
				{
					float distance = (portalsOnMap[i].position - portalSurface.GlobalPosition).LengthSquared();
					if ((portal == null) || (distance < closestPortal))
					{
						portal = portalsOnMap[i];
						closestPortal = distance;
					}
				}
				if (portal != null)
					portalSurface.SetUpPortal(camera, portal);
				else
				{
					portalSurface.QueueFree();
					portalSurfaces.Remove(portalSurface);
				}
			}
			else
			{
				portalSurface.QueueFree();
				portalSurfaces.Remove(portalSurface);
			}
		}
	}

	public static void NewLocalPlayerAdded()
	{
		for (int n = 0; n < portalSurfaces.Count; n++)
		{
			PortalSurface portalSurface = portalSurfaces[n];
			portalSurface.NewLocalPlayerAdded();
		}
	}
	public static string GetSoundName(string strWord)
	{
		string[] keyValue = strWord.Split('.');
		strWord = keyValue[0];
		if (!strWord.Contains('*'))
		{
			keyValue = strWord.Split('/');
			strWord = "";
			for (int i = 1; i < keyValue.Length; i++)
			{
				if (i > 1)
					strWord += "/";
				strWord += keyValue[i];
			}
		}
		return strWord;
	}

	public static void AddRandomTimeToSound(Node3D node, Dictionary<string, string> entityData, AudioStreamPlayer audioStream2D, MultiAudioStream audioStream, bool isAudio3d)
	{
		float random, wait;
		PlayAfterRandomTime playRandom =new PlayAfterRandomTime();
		node.AddChild(playRandom);
		entityData.TryGetNumValue("random", out random);
		entityData.TryGetNumValue("wait", out wait);
		if (isAudio3d)
			playRandom.AddMultiAudioStream(audioStream);
		else
			playRandom.AddAudioStream(audioStream2D);
		playRandom.Init(wait, random);
	}
}
public static class DictionaryExtensions
{
	public static bool TryGetNumValue(this Dictionary<string, string> entityData, string key, out float num)
	{
		int inum = 0;
		num = 0;
		string strWord;
		if (entityData.TryGetValue(key, out strWord))
		{
			if (int.TryParse(strWord, out inum))
				num = inum;
			else
				num = float.Parse(strWord);
			return true;
		}
		return false;
	}
}
public class Target
{
	public Vector3 destination;
	public int angle;
	public Dictionary<string, string> entityData;
	public Target(Vector3 destination, int angle, Dictionary<string, string> entityData)
	{
		this.destination = destination;
		this.angle = angle;
		this.entityData = entityData;
	}
}
public class Entity
{
	public string name;
	public Vector3 origin;
	public Dictionary<string, string> entityData;
	public Entity(string name, Vector3 origin, Dictionary<string, string> entityData)
	{
		this.name = name;
		this.origin = origin;
		this.entityData = entityData;
	}
}
public class RespawnItem
{
	public Node3D node;
	public string respawnSound;
	public float time;

	public RespawnItem(Node3D node, string respawnSound, float time)
	{
		this.node = node;
		this.respawnSound = respawnSound;
		this.time = time;
	}
}

public class Portal
{
	public string shaderName;
	public Vector3 position;
	public Vector3 normal;
	public ArrayMesh commonMesh;
	public List<Surface> surfaces = new List<Surface>();
	public ShaderMaterial commonMat;

	public class Surface
	{
		public MeshInstance3D mesh;
		public ShaderMaterial baseMat;
		public ShaderMaterial material;

		public Surface(MeshInstance3D mesh, ShaderMaterial material)
		{
			this.mesh = mesh;
			this.baseMat = material;
			this.material = (ShaderMaterial)material.NextPass;
		}

	}
	public Portal(string shaderName, ShaderMaterial baseMat)
	{
		this.shaderName = shaderName;
		this.commonMat = baseMat;
	}
}

public static class BFGTracers
{
	public static float[] hx;
	public static float[] hy;
	public static int pixels;
	public static int samples = 500;
	private static float HaltonSequence(int index, int b)
	{
		float r = 0.0f;
		float f = 1.0f / b;
		int i = index;

		while (i > 0)
		{
			r = r + f * (i % b);
			i = Mathf.FloorToInt(i / b);
			f = f / b;
		}

		return r;
	}

	public static void SetTracers()
	{
		pixels = Mathf.FloorToInt(640 * 360); // 1/4th 720p
		hx = new float[pixels];
		hy = new float[pixels];

		for (int i = 0; i < pixels; i++)
		{
			hx[i] = HaltonSequence(i, 2);
			hy[i] = HaltonSequence(i, 3);
		}
	}
}


```

./Assets/Scripts/Managers/SpawnerManager.cs:
```
using Godot;
using System.Collections.Generic;
public static class SpawnerManager
{
	public static List<Target> deathMatchSpawner = new List<Target>();
	public static List<Target> redTeamSpawner = new List<Target>();
	public static List<Target> blueTeamSpawner = new List<Target>();


	public static string respawnSound = "world/telein";
	public static int lastSpawn = 0;
	public static void AddToList(SpawnPosition spawnPosition)
	{
		switch(spawnPosition.spawnType)
		{
			default:
				deathMatchSpawner.Add(spawnPosition.spawnPosition);
			break;
			case SpawnPosition.SpawnType.Red:
				redTeamSpawner.Add(spawnPosition.spawnPosition);
			break;
			case SpawnPosition.SpawnType.Blue:
				blueTeamSpawner.Add(spawnPosition.spawnPosition);
			break;
		}
	}

	public static void SpawnToLocation(PlayerThing player)
	{
		int spawnIndex;
		do
			spawnIndex = GD.RandRange(0, deathMatchSpawner.Count - 1);
		while (spawnIndex == lastSpawn);
	
		lastSpawn = spawnIndex;
		Target target = deathMatchSpawner[spawnIndex];
		ClusterPVSManager.CheckPVS(player.playerInfo.viewLayer, target.destination);
		TeleporterThing.TelefragEverything(target.destination, player);
		player.Position = target.destination;
		player.playerControls.InvoqueSetTransformReset();

		SoundManager.Create3DSound(target.destination, SoundManager.LoadSound(respawnSound));
		player.playerControls.viewDirection.Y = target.angle;
		player.playerControls.impulseVector = Vector3.Zero;
		player.playerControls.playerVelocity = Vector3.Zero;
		player.playerControls.fallSpeed = 0;
		player.playerControls.jumpPadVel = Vector3.Zero;
		player.Impulse(Quaternion.FromEuler(new Vector3(0, Mathf.DegToRad(target.angle), 0)) * Vector3.Forward, 1500);

	}

	public static void CheckSpawnLocations()
	{
		switch (GameManager.Instance.gameConfig.GameType)
		{
			default:
			break;
			case GameManager.GameType.SinglePlayer:
			case GameManager.GameType.FreeForAll:
			case GameManager.GameType.QuadHog:
			case GameManager.GameType.Tournament:
				deathMatchSpawner.AddRange(redTeamSpawner);
				deathMatchSpawner.AddRange(blueTeamSpawner);
			break;
		}
	}
	public static void ClearLists()
	{
		deathMatchSpawner = new List<Target>();
		redTeamSpawner = new List<Target>();
		blueTeamSpawner = new List<Target>();
	}

}
```

./Assets/Scripts/Managers/AdaptativeMusicManager.cs:
```
using Godot;
using System.Collections.Generic;

public partial class AdaptativeMusicManager : Node
{
	public const int MaxTimesOnTop = 3;
	public const int TopIntensity = 3;
	public const int HighIntensity = 2;
	public const int LowIntensity = 1;
	public const int Ambient = 0;

	public static AdaptativeMusicManager Instance;

	[Export]
	public AdaptativeTrack[] MainTracks;
	[Export]
	public AdaptativeTrack[] BlendTracks;
	public AdaptativeTrack currentTrack;

	public static Dictionary<int, List<AdaptativeTrack>> mainTracks = new Dictionary<int, List<AdaptativeTrack>>();
	public static Dictionary<int, List<AdaptativeTrack>> blendTracks = new Dictionary<int, List<AdaptativeTrack>>();

	public AudioStreamPlayer track01, track02;

	[Export]
	public float baseVol = 4f;
	[Export]
	public int maxIntensity = 3;

	public int currentIntensity = 0;
	public float lastDeathRatio = 0;

	private bool isPlayingTack01 = true;
	private bool crossFade = false;
	private float targetVol;
	private bool StartedPlaying = false;
	private int onTop = 0;

	public override void _Ready()
	{
		int trackNum = 0;
		Instance = this;
		track01 = new AudioStreamPlayer();
		AddChild(track01);
		track01.VolumeDb = 7;
		track01.Name = "Track01";
		track01.Bus = "BKGBus";

		track02 = new AudioStreamPlayer();
		AddChild(track02);
		track02.VolumeDb = 7;
		track02.Name = "Track02";
		track02.Bus = "BKGBus";

		for (int i = 0; i < MainTracks.Length; i++)
		{
			AdaptativeTrack track = MainTracks[i];
			track.uniqueId = trackNum++;
			if (mainTracks.ContainsKey(track.intesityLevel))
				mainTracks[track.intesityLevel].Add(track);
			else
			{
				List<AdaptativeTrack> list = new List<AdaptativeTrack>
				{
					track
				};
				mainTracks.Add(track.intesityLevel, list);
				if (track.intesityLevel > maxIntensity)
					maxIntensity = track.intesityLevel;
			}
		}

		for (int i = 0; i < BlendTracks.Length; i++)
		{
			AdaptativeTrack track = BlendTracks[i];
			track.uniqueId = trackNum++;
			if (blendTracks.ContainsKey(track.intesityLevel))
				blendTracks[track.intesityLevel].Add(track);
			else
			{
				List<AdaptativeTrack> list = new List<AdaptativeTrack>
				{
					track
				};
				blendTracks.Add(track.intesityLevel, list);
			}
		}

		targetVol = GetCurrentVolume();
	}

	public override void _Process(double delta)
	{
		bool useOutro = true;

		if (GameManager.Paused)
			return;

		if (!StartedPlaying)
			return;

		float deltaTime = (float)delta;

		if (crossFade)
		{
			if (isPlayingTack01)
			{
				track01.VolumeDb = Mathf.Lerp(track01.VolumeDb, targetVol, deltaTime);
				track02.VolumeDb = Mathf.Lerp(track02.VolumeDb, 0, deltaTime);
				if (track02.VolumeDb < 0.001f)
				{
					track01.VolumeDb = targetVol;
					track02.VolumeDb = 0;
					crossFade = false;
				}
			}
			else
			{
				track02.VolumeDb = Mathf.Lerp(track02.VolumeDb, targetVol, deltaTime);
				track01.VolumeDb = Mathf.Lerp(track01.VolumeDb, 0, deltaTime);
				if (track01.VolumeDb < 0.001f)
				{
					track02.VolumeDb = targetVol;
					track01.VolumeDb = 0;
					crossFade = false;
				}
			}
		}
		else
		{
			if (isPlayingTack01)
			{
				if (track01.VolumeDb < targetVol)
				{
					track01.VolumeDb = Mathf.Lerp(track01.VolumeDb, targetVol, deltaTime);
					if ((targetVol - track01.VolumeDb) < 0.001f)
					{
						track01.VolumeDb = targetVol;
						track02.VolumeDb = targetVol;
					}
				}
			}
			else
			{
				if (track02.VolumeDb < targetVol)
				{
					track02.VolumeDb = Mathf.Lerp(track02.VolumeDb, targetVol, deltaTime);
					if ((targetVol - track02.VolumeDb) < 0.001f)
					{
						track01.VolumeDb = targetVol;
						track02.VolumeDb = targetVol;
					}
				}
			}
		}

		if ((!track01.Playing) && (!track02.Playing))
		{
			int newIntensity = currentIntensity + GD.RandRange(-1, currentIntensity == maxIntensity ? 0 : 1);

			if (currentIntensity > LowIntensity)
			{
				float deathRatio = GameManager.Instance.GetDeathRatioAndReset();
				float meanRatio = Mathf.Lerp(deathRatio, lastDeathRatio, .5f);
				GameManager.Print("meanRatio " + meanRatio);
				lastDeathRatio = meanRatio;
				switch (currentIntensity)
				{
					default:
					case HighIntensity:
						{
							if (meanRatio > 2.5)
								newIntensity = TopIntensity;
							else if (meanRatio > 2)
							{
								useOutro = false;
								if (newIntensity < HighIntensity)
									newIntensity = HighIntensity;
							}
							else if (meanRatio > 1)
								useOutro = false;
							else
							{
								if (newIntensity > HighIntensity)
									newIntensity = HighIntensity;
							}
						}
						break;
					case TopIntensity:
						{
							if (meanRatio > 2.5)
								newIntensity = TopIntensity;
							else if (meanRatio > 2)
							{
								useOutro = false;
								newIntensity = HighIntensity;
							}
							else
								newIntensity = HighIntensity;
						}
						break;
				}

				if (newIntensity == TopIntensity)
				{
					onTop++;
					if (onTop > MaxTimesOnTop)
					{
						lastDeathRatio *= .5f;
						newIntensity = HighIntensity;
						onTop = 0;
					}
				}
				else
					onTop = 0;
			}

			if (newIntensity < 0)
				newIntensity = 0;
			else if (newIntensity > maxIntensity)
				newIntensity = maxIntensity;

			if ((newIntensity < currentIntensity) || ((newIntensity == currentIntensity) && (currentIntensity < 2)))
			{
				currentIntensity = newIntensity;
				if ((currentTrack.hasOutro))
				{
					if (useOutro)
					{
						ChangeTrack(currentTrack.OutroFile);
						GetTrackOnCurrentIntensity(currentIntensity, true, true);
					}
					else
						GetTrackOnCurrentIntensity(currentIntensity);
				}
				else
				{
					newIntensity = GD.RandRange(0, currentIntensity + 1);
					if (newIntensity <= currentIntensity)
						GetTrackOnCurrentIntensity(currentIntensity);
					else
					{
						newIntensity = GD.RandRange(0, currentIntensity);
						GetTrackOnCurrentIntensity(newIntensity, true);
					}
				}
			}
			else
			{
				currentIntensity = newIntensity;
				GetTrackOnCurrentIntensity(currentIntensity);
			}
		}
	}
	public void StartMusic()
	{
		GetTrackOnCurrentIntensity(0);
		StartedPlaying = true;
	}

	public void StopMusic()
	{
		StartedPlaying = false;
		track01.Stop();
		track02.Stop();
	}

	public void GetTrackOnCurrentIntensity(int intensity, bool crossFade = false, bool secondary = false)
	{
		AdaptativeTrack track;

	searchagain:
		if (secondary)
			track = blendTracks[intensity][GD.RandRange(0, blendTracks[intensity].Count - 1)];
		else
			track = mainTracks[intensity][GD.RandRange(0, mainTracks[intensity].Count - 1)];

		if ((!track.isRepeatable) && (track.uniqueId == currentTrack.uniqueId))
			goto searchagain;

		ChangeTrack(track.TrackFile, crossFade);
		currentTrack = track;
	}
	public float GetCurrentVolume()
	{
		return (baseVol + currentIntensity);
	}

	public void ChangeTrack(AudioStream newClip, bool fade = false)
	{
		if (isPlayingTack01)
		{
			track02.Stream = newClip;
			if (fade)
			{
				crossFade = true;
				track02.VolumeDb = 0;
				track02.Play();
			}
			else
			{
				if (track02.VolumeDb == 0)
					track02.VolumeDb = track01.VolumeDb;
				track02.Play();
				track01.Stop();
			}
		}
		else
		{
			track01.Stream = newClip;
			if (fade)
			{
				crossFade = true;
				track01.VolumeDb = 0;
				track01.Play();
			}
			else
			{
				if (track01.VolumeDb == 0)
					track01.VolumeDb = track02.VolumeDb;
				track01.Play();
				track02.Stop();
			}
		}
		targetVol = GetCurrentVolume();
		isPlayingTack01 = !isPlayingTack01;
	}
}
```

./Assets/Scripts/Projectiles/Rocket.cs:
```
using Godot;
using ExtensionMethods;

public partial class Rocket : Projectile
{
	[Export]
	public ParticlesController fx;
	[Export]
	public string _onFlySound;
	private Rid ExplosionSphere;
	private PhysicsShapeQueryParameters3D ExplosionSphereCast;
	protected override void OnInit()
	{
		if (!string.IsNullOrEmpty(_onFlySound))
		{
			audioStream.Stream = SoundManager.LoadSound(_onFlySound, true);
			audioStream.Play();
		}

		ExplosionSphere = PhysicsServer3D.SphereShapeCreate();
		ExplosionSphereCast = new PhysicsShapeQueryParameters3D();
		ExplosionSphereCast.ShapeRid = ExplosionSphere;
		PhysicsServer3D.ShapeSetData(ExplosionSphere, explosionRadius);
	}
	protected override void OnCollision(Vector3 collision, Vector3 normal, Vector3 direction, CollisionObject3D collider)
	{
		if (collider is Damageable damageable)
		{
			Vector3 impulseDir = direction.Normalized();
			damageable.Impulse(impulseDir, pushForce);
			damageable.Damage(GD.RandRange(damageMin, damageMax), DamageType.Rocket, owner);
		}
	}
	protected override void OnExplosion(Vector3 Collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState)
	{
		ExplosionSphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		ExplosionSphereCast.Motion = Vector3.Zero;
		ExplosionSphereCast.Transform = new Transform3D(GlobalTransform.Basis, Collision);
		var hits = SpaceState.IntersectShape(ExplosionSphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is Damageable damageable)
			{
				Vector3 collision = collider.GlobalPosition;
				bool collide = false;
				if ((collider.CollisionLayer & (1 << GameManager.ColliderLayer)) == 0)
				{
					var RayCast = PhysicsRayQueryParameters3D.Create(GlobalPosition, collision, (1 << GameManager.ColliderLayer));
					var check = SpaceState.IntersectRay(RayCast);
					if (check.Count == 0)
						collide = true;
				}
				else
					collide = true;

				if (collide)
				{
					Vector3 hPosition = collider.Position;
					Vector3 Distance = (hPosition - Collision);
					float lenght;
					Vector3 impulseDir = Distance.GetLenghtAndNormalize(out lenght);
					int damage = blastDamage;
					//in order to enable rocket jump
					if (collider == owner)
						damage = Mathf.CeilToInt(damage / 3);
					damageable.Impulse(impulseDir, Mathf.Lerp(pushForce, 100, lenght / explosionRadius));
					damageable.Damage(Mathf.CeilToInt(Mathf.Lerp(damage, 1, lenght / explosionRadius)), DamageType.Explosion, owner);
				}
			}
		}
	}
	protected override void OnExplosionFX(Vector3 collision, Vector3 direction)
	{
		if (!string.IsNullOrEmpty(OnDeathSpawn))
		{
			Node3D DeathSpawn = (Node3D)ThingsManager.thingsPrefabs[OnDeathSpawn].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(DeathSpawn);
			DeathSpawn.Position = collision + direction;
			DeathSpawn.SetForward(-direction);
			DeathSpawn.Rotate(direction, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
			if (fx != null)
			{
				fx.Reparent(DeathSpawn);
				fx.enableLifeTime = true;
			}
		}
	}
}
```

./Assets/Scripts/Projectiles/Grenade.cs:
```
using Godot;
using System;
using ExtensionMethods;
public partial class Grenade : PhysicProjectile
{
	[Export]
	public ParticlesController fx;
	public bool currentWater = false;
	private Rid ExplosionSphere;
	private PhysicsShapeQueryParameters3D ExplosionSphereCast;
	protected override void OnInit()
	{
		CollisionMask |= (1 << GameManager.InvisibleBlockerLayer);
		ExplosionSphere = PhysicsServer3D.SphereShapeCreate();
		ExplosionSphereCast = new PhysicsShapeQueryParameters3D();
		ExplosionSphereCast.ShapeRid = ExplosionSphere;
		PhysicsServer3D.ShapeSetData(ExplosionSphere, explosionRadius);
	}
	protected override void OnBodyEntered(Node other)
	{
		if (!currentWater)
			if (Sounds.Length > 0)
			{
				audioStream.Stream = Sounds[GD.RandRange(0, Sounds.Length - 1)];
				audioStream.Play();
			}

		if (other is Damageable)
			if (LinearVelocity.LengthSquared() > 10) //force explosion in physics update
				destroyTimer = -1;
	}

	protected override void OnCheckWaterChange()
	{
		if (currentWater != inWater)
		{
			fx.Visible = !inWater;
			audioStream.Stream = waterSound;
			audioStream.Play();
			currentWater = inWater;
		}
	}
	protected override void OnExplosion(Vector3 Collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState)
	{
		ExplosionSphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		ExplosionSphereCast.Motion = Vector3.Zero;
		ExplosionSphereCast.Transform = new Transform3D(GlobalTransform.Basis, Collision);
		var hits = SpaceState.IntersectShape(ExplosionSphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is Damageable damageable)
			{
				Vector3 collision = collider.GlobalPosition;
				bool collide = false;
				if ((collider.CollisionLayer & (1 << GameManager.ColliderLayer)) == 0)
				{
					var RayCast = PhysicsRayQueryParameters3D.Create(GlobalPosition, collision, (1 << GameManager.ColliderLayer));
					var check = SpaceState.IntersectRay(RayCast);
					if (check.Count == 0)
						collide = true;
				}
				else
					collide = true;

				if (collide)
				{
					Vector3 hPosition = collider.Position;
					Vector3 Distance = (hPosition - Collision);
					float lenght;
					Vector3 impulseDir = Distance.GetLenghtAndNormalize(out lenght);
					int damage = blastDamage;
					//in order to enable grenade jump
					if (collider == owner)
						damage = Mathf.CeilToInt(damage / 3);
					damageable.Impulse(impulseDir, Mathf.Lerp(pushForce, 100, lenght / explosionRadius));
					damageable.Damage(Mathf.CeilToInt(Mathf.Lerp(damage, 1, lenght / explosionRadius)), DamageType.Explosion, owner);
				}
			}
		}
	}
}
```

./Assets/Scripts/Projectiles/PlasmaBall.cs:
```
using Godot;
using ExtensionMethods;

public partial class PlasmaBall : Projectile
{
	[Export]
	public string _onFlySound;
	private Rid ExplosionSphere;
	private PhysicsShapeQueryParameters3D ExplosionSphereCast;
	protected override void OnInit()
	{
		if (!string.IsNullOrEmpty(_onFlySound))
		{
			audioStream.Stream = SoundManager.LoadSound(_onFlySound, true);
			audioStream.Play();
		}
		ExplosionSphere = PhysicsServer3D.SphereShapeCreate();
		ExplosionSphereCast = new PhysicsShapeQueryParameters3D();
		ExplosionSphereCast.ShapeRid = ExplosionSphere;
		PhysicsServer3D.ShapeSetData(ExplosionSphere, explosionRadius);
	}
	protected override void OnCollision(Vector3 collision, Vector3 normal, Vector3 direction, CollisionObject3D collider)
	{
		if (collider is Damageable damageable)
		{
			Vector3 impulseDir = direction.Normalized();
			damageable.Impulse(impulseDir, pushForce);
			damageable.Damage(GD.RandRange(damageMin, damageMax), DamageType.Plasma, owner);
		}
	}
	protected override void OnExplosion(Vector3 Collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState)
	{
		ExplosionSphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		ExplosionSphereCast.Motion = Vector3.Zero;
		ExplosionSphereCast.Transform = new Transform3D(GlobalTransform.Basis, Collision);
		var hits = SpaceState.IntersectShape(ExplosionSphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is Damageable damageable)
			{
				//Plasma never does self damage
				if (collider == owner)
					continue;

				Vector3 collision = collider.GlobalPosition;
				bool collide = false;
				if ((collider.CollisionLayer & (1 << GameManager.ColliderLayer)) == 0)
				{
					var RayCast = PhysicsRayQueryParameters3D.Create(GlobalPosition, collision, (1 << GameManager.ColliderLayer));
					var check = SpaceState.IntersectRay(RayCast);
					if (check.Count == 0)
						collide = true;
				}
				else
					collide = true;

				if (collide)
					damageable.Damage(GD.RandRange(damageMin, damageMax), DamageType.Plasma, owner);
			}
		}
	}
	protected override void OnExplosionFX(Vector3 collision, Vector3 direction)
	{
		if (!string.IsNullOrEmpty(OnDeathSpawn))
		{
			Node3D DeathSpawn = (Node3D)ThingsManager.thingsPrefabs[OnDeathSpawn].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(DeathSpawn);
			DeathSpawn.Position = collision + direction;
			DeathSpawn.SetForward(-direction);
			DeathSpawn.Rotate(direction, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
		}
	}
	protected override void OnDestroy(Vector3 collision)
	{
		if (!string.IsNullOrEmpty(_onDeathSound))
			SoundManager.Create3DSound(collision, SoundManager.LoadSound(_onDeathSound));
		QueueFree();
	}
}
```

./Assets/Scripts/Projectiles/RailTrail.cs:
```
using Godot;
using System;

public partial class RailTrail : Node3D
{
	[Export]
	public Color modulate = Colors.White;
	[Export]
	public StandardMaterial3D baseMaterial;
	[Export]
	public MeshInstance3D trailMesh;
	[Export]
	public float destroyTimer = 1.5f;
	private float baseTime = 1;

	private StandardMaterial3D trailMaterial;
	private CylinderMesh rail;
	private Color black = Colors.Black;

	private GameManager.FuncState currentState = GameManager.FuncState.None;
	public void Init(Vector3 origin, Vector3 end, Color color)
	{
		rail = new CylinderMesh();
		rail.TopRadius = 0.1f;
		rail.BottomRadius = 0.1f;
		trailMaterial = (StandardMaterial3D)baseMaterial.Duplicate();
		rail.Material = trailMaterial;
		trailMesh.Mesh = rail;
		modulate = color;
		Vector3 direction = (origin - end);
		rail.Height = direction.Length();
		trailMesh.Layers = GameManager.AllPlayerViewMask;

		baseTime = destroyTimer;
		currentState = GameManager.FuncState.Start;
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		if (currentState == GameManager.FuncState.None)
			return;

		float deltaTime = (float)delta;
		destroyTimer -= deltaTime;

		Color color = black.Lerp(modulate, destroyTimer / baseTime);
		trailMaterial.AlbedoColor = color;
		trailMaterial.Emission = color;
		if (destroyTimer < 0)
			QueueFree();
	}
}
```

./Assets/Scripts/Projectiles/Projectile.cs:
```
using Godot;
using ExtensionMethods;

public partial class Projectile : InterpolatedNode3D
{
	public Node3D owner;
	[Export]
	public float _lifeTime = 1;
	[Export]
	public float speed = 4f;
	[Export]
	public int rotateSpeed = 0;
	[Export]
	public int damageMin = 3;
	[Export]
	public int damageMax = 24;
	[Export]
	public int blastDamage = 0;
	[Export]
	public float projectileRadius = .2f;
	[Export]
	public float explosionRadius = 2f;
	[Export]
	public float pushForce = 0f;
	[Export]
	public string OnDeathSpawn;
	[Export]
	public string decalMark;
	[Export]
	public string secondaryMark;
	[Export]
	public string SecondaryOnDeathSpawn;
	[Export]
	public MultiAudioStream audioStream;
	[Export]
	public string _onDeathSound;

	public uint ignoreSelfLayer = 0;

	float time = 0f;
	private Rid Sphere;
	private PhysicsShapeQueryParameters3D SphereCast;
	private PhysicsPointQueryParameters3D PointIntersect;
	public override void _Ready()
	{
		Sphere = PhysicsServer3D.SphereShapeCreate();
		SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;
		PhysicsServer3D.ShapeSetData(Sphere, projectileRadius);

		PointIntersect = new PhysicsPointQueryParameters3D();
		PointIntersect.CollideWithAreas = true;
		PointIntersect.CollideWithBodies = false;
		PointIntersect.CollisionMask = (1 << GameManager.FogLayer);

		OnInit();
	}
	public void EnableQuad()
	{
		damageMin *= GameManager.Instance.QuadMul;
		damageMax *= GameManager.Instance.QuadMul;
		blastDamage *= GameManager.Instance.QuadMul;
		pushForce *= GameManager.Instance.QuadMul * .5f;
		OnEnableQuad();
	}
	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;

		time += deltaTime;

		if (time >= _lifeTime)
		{
			OnDestroy(GlobalPosition);
			return;
		}

		CollisionObject3D Hit = null;
		Vector3 Collision = Vector3.Zero;
		Vector3 Normal = Vector3.Zero;
		Vector3 d = GlobalTransform.ForwardVector();

		var SpaceState = GetWorld3D().DirectSpaceState;
		//check for collision
		{
			SphereCast.CollisionMask = ~(GameManager.NoHitMask | ignoreSelfLayer);
			SphereCast.Motion = -d * speed * deltaTime;
			SphereCast.Transform = GlobalTransform;
			var result = SpaceState.CastMotion(SphereCast);

			if (result[1] < 1)
			{
				SphereCast.Transform = new Transform3D(GlobalTransform.Basis, GlobalTransform.Origin + (SphereCast.Motion * result[1]));
				var hit = SpaceState.GetRestInfo(SphereCast);
				if (hit.Count > 0)
				{
					CollisionObject3D collider = (CollisionObject3D)InstanceFromId((ulong)hit["collider_id"]);
					if (collider != owner)
					{
						Collision = (Vector3)hit["point"];
						Normal = (Vector3)hit["normal"];
						Hit = collider;
						OnCollision(Collision, Normal, d, collider);
					}
				}
			}
		}

		//explosion
		if (Hit != null)
		{
			OnExplosion(Collision, d, SpaceState);
			OnExplosionFX(Collision, d);

			//Check if collider can be marked
			if (CheckIfCanMark(SpaceState, Hit, Collision))
			{
				SpriteController DecalMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(DecalMark);
				DecalMark.GlobalPosition = Collision + (Normal * .03f);
				DecalMark.SetForward(Normal);
				DecalMark.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				if (Hit is Crusher)
					DecalMark.referenceNode = Hit;
				if (!string.IsNullOrEmpty(secondaryMark))
				{
					SpriteController SecondMark = (SpriteController)ThingsManager.thingsPrefabs[secondaryMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(SecondMark);
					SecondMark.GlobalPosition = Collision + (Normal * .05f);
					SecondMark.SetForward(Normal);
					SecondMark.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (Hit is Crusher)
						SecondMark.referenceNode = Hit;
				}
			}

			OnDestroy(Collision);
			return;
		}
		OnPhysicsUpdate(deltaTime, SpaceState);
		Position -= d * speed * deltaTime;
	}

	protected virtual void OnPhysicsUpdate(float deltaTime, PhysicsDirectSpaceState3D SpaceState) { }
	protected virtual void OnInit() { }
	protected virtual void OnEnableQuad() { }
	protected virtual void OnCollision(Vector3 collision, Vector3 normal, Vector3 direction, CollisionObject3D collider) { }
	protected virtual void OnExplosion(Vector3 collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState) { }
	protected virtual void OnExplosionFX(Vector3 collision, Vector3 direction) { }
	protected virtual void OnDestroy(Vector3 collision)
	{
		if (!string.IsNullOrEmpty(_onDeathSound))
			SoundManager.Create3DSound(collision, SoundManager.LoadSound(_onDeathSound));
		QueueFree();
	}

	public bool CheckIfCanMark(PhysicsDirectSpaceState3D SpaceState, CollisionObject3D collider, Vector3 collision)
	{
		if (collider is Damageable)
			return false;

		//Don't mark moving platforms
		if (collider is Crusher)
			return false;

		//Check if mapcollider are noMarks
		if (MapLoader.noMarks.Contains(collider))
			return false;

		//Check if collision in inside a fog Area
		PointIntersect.Position = collision;

		var hits = SpaceState.IntersectPoint(PointIntersect);
		if (hits.Count == 0)
			return true;

		return false;
	}
}
```

./Assets/Scripts/Projectiles/PhysicProjectile.cs:
```
using Godot;
using System;
using ExtensionMethods;

public partial class PhysicProjectile : RigidBody3D
{
	public Node3D owner;
	[Export]
	public MultiAudioStream audioStream;
	[Export]
	public string[] _sounds = new string[0];
	[Export]
	public int damageMin = 3;
	[Export]
	public int damageMax = 24;
	[Export]
	public int blastDamage = 0;
	[Export]
	public float projectileRadius = .2f;
	[Export]
	public float explosionRadius = 2f;
	[Export]
	public float pushForce = 0f;
	[Export]
	public string OnDeathSpawn;
	[Export]
	public string decalMark;
	[Export]
	public string secondaryMark;
	[Export]
	public string SecondaryOnDeathSpawn;
	[Export]
	public string _onDeathSound;
	[Export]
	public float destroyTimer = 2.5f;

	public AudioStream[] Sounds = new AudioStream[0];
	public bool inWater = false;
	public AudioStream waterSound;

	private Rid Sphere;
	private PhysicsShapeQueryParameters3D SphereCast;
	private PhysicsPointQueryParameters3D PointIntersect;

	public override void _Ready()
	{
		Sphere = PhysicsServer3D.SphereShapeCreate();
		SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;
		PhysicsServer3D.ShapeSetData(Sphere, projectileRadius);

		PointIntersect = new PhysicsPointQueryParameters3D();
		PointIntersect.CollideWithAreas = true;
		PointIntersect.CollideWithBodies = false;
		PointIntersect.CollisionMask = (1 << GameManager.FogLayer);

		Sounds = new AudioStream[_sounds.Length];
		for (int i = 0; i < _sounds.Length; i++)
			Sounds[i] = SoundManager.LoadSound(_sounds[i]);

		BodyEntered += OnBodyEntered;
		OnInit();
	}
	public void Init(uint ignoreSelfLayer)
	{
		CollisionMask = ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | (1 << GameManager.WaterLayer) | GameManager.TakeDamageMask & ~(ignoreSelfLayer));
	}
	public void EnableQuad()
	{
		damageMin *= GameManager.Instance.QuadMul;
		damageMax *= GameManager.Instance.QuadMul;
		blastDamage *= GameManager.Instance.QuadMul;
		pushForce *= GameManager.Instance.QuadMul * .5f;
		OnEnableQuad();
	}
	public void ChangeWater(bool inside, AudioStream sound)
	{
		inWater = inside;
		waterSound = sound;
	}

	public void Explode()
	{
		CollisionObject3D Hit = null;
		Vector3 Collision = GlobalPosition;
		Vector3 Normal = Vector3.Zero;
		Vector3 d = GlobalTransform.ForwardVector();

		var SpaceState = GetWorld3D().DirectSpaceState;
		//check for collision on surfaces
		{
			PhysicsServer3D.ShapeSetData(Sphere, projectileRadius);
			SphereCast.CollisionMask = (1 << GameManager.ColliderLayer);
			SphereCast.Transform = GlobalTransform;
			var hit = SpaceState.GetRestInfo(SphereCast);
			if (hit.Count > 0)
			{
				Hit = (CollisionObject3D)InstanceFromId((ulong)hit["collider_id"]);
				Collision = (Vector3)hit["point"];
				Normal = (Vector3)hit["normal"];
				OnCollision(Collision, Normal, d, Hit);
			}
		}

		//explosion
		OnExplosion(Collision, d, SpaceState);
		OnExplosionFX(Collision, d);

		if (Hit != null)
		{
			if (!string.IsNullOrEmpty(OnDeathSpawn))
			{
				Node3D DeathSpawn = (Node3D)ThingsManager.thingsPrefabs[OnDeathSpawn].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(DeathSpawn);
				DeathSpawn.Position = Collision;
				DeathSpawn.SetForward(-d);
				DeathSpawn.Rotate(d, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
			}

			//Check if collider can be marked
			if (CheckIfCanMark(SpaceState, Hit, Collision))
			{
				SpriteController DecalMark = (SpriteController)ThingsManager.thingsPrefabs[decalMark].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(DecalMark);
				DecalMark.GlobalPosition = Collision + (Normal * .03f);
				DecalMark.SetForward(Normal);
				DecalMark.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
				if (Hit is Crusher)
					DecalMark.referenceNode = Hit;
				if (!string.IsNullOrEmpty(secondaryMark))
				{
					SpriteController SecondMark = (SpriteController)ThingsManager.thingsPrefabs[secondaryMark].Instantiate();
					GameManager.Instance.TemporaryObjectsHolder.AddChild(SecondMark);
					SecondMark.GlobalPosition = Collision + (Normal * .05f);
					SecondMark.SetForward(Normal);
					SecondMark.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
					if (Hit is Crusher)
						SecondMark.referenceNode = Hit;
				}
			}
		}
		else if (!string.IsNullOrEmpty(OnDeathSpawn))
		{
			Node3D DeathSpawn = (Node3D)ThingsManager.thingsPrefabs[OnDeathSpawn].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(DeathSpawn);
			DeathSpawn.Position = GlobalPosition;
		}

		OnDestroy(Collision);
		return;
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		float deltaTime = (float)delta;

		OnCheckWaterChange();
		OnPhysicsUpdate(deltaTime);

		if (destroyTimer > 0)
			destroyTimer -= deltaTime;
		if (destroyTimer < 0)
			Explode();
	}

	protected virtual void OnPhysicsUpdate(float deltaTime) { }
	protected virtual void OnInit() { }
	protected virtual void OnEnableQuad() { }
	protected virtual void OnCollision(Vector3 collision, Vector3 normal, Vector3 direction, CollisionObject3D collider) { }
	protected virtual void OnExplosion(Vector3 collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState) { }
	protected virtual void OnExplosionFX(Vector3 collision, Vector3 direction) { }
	protected virtual void OnBodyEntered(Node other) { }
	protected virtual void OnCheckWaterChange() { }
	protected virtual void OnDestroy(Vector3 collision)
	{
		if (!string.IsNullOrEmpty(_onDeathSound))
			SoundManager.Create3DSound(collision, SoundManager.LoadSound(_onDeathSound));
		QueueFree();
	}

	public bool CheckIfCanMark(PhysicsDirectSpaceState3D SpaceState, CollisionObject3D collider, Vector3 collision)
	{
		if (collider is Damageable)
			return false;

		//Don't mark moving platforms
		if (collider is Crusher)
			return false;

		//Check if mapcollider are noMarks
		if (MapLoader.noMarks.Contains(collider))
			return false;

		//Check if collision in inside a fog Area
		PointIntersect.Position = collision;

		var hits = SpaceState.IntersectPoint(PointIntersect);
		if (hits.Count == 0)
			return true;

		return false;
	}
}
```

./Assets/Scripts/Projectiles/BFGBall.cs:
```
using Godot;
using System.Collections.Generic;
using ExtensionMethods;

public partial class BFGBall : Projectile
{
	[Export]
	public Node3D[] boltOrigin;
	[Export]
	PackedScene Bolt;
	public List<LightningBolt> lightningBolt = new List<LightningBolt>();
	[Export]
	public int electricDamageMin = 6;
	[Export]
	public int electricDamageMax = 9;
	[Export]
	public float lightningRadius = 24f;
	[Export]
	public float electricDamageRate = .05f;
	[Export]
	public string[] _humSounds;
	public AudioStream[] humSounds;

	private float damageTime = 0;
	private Color Green = new Color(0x006158FF);
	private Rid ElectricSphere;
	private PhysicsShapeQueryParameters3D ElectricSphereCast;
	private Rid ExplosionSphere;
	private PhysicsShapeQueryParameters3D ExplosionSphereCast;

	public enum CurrentHum
	{
		None,
		Idle,
		Fire
	}

	private CurrentHum currentHum = CurrentHum.None;

	protected override void OnInit()
	{
		humSounds = new AudioStream[_humSounds.Length];
		for (int i = 0; i < _humSounds.Length; i++)
			humSounds[i] = SoundManager.LoadSound(_humSounds[i], true);

		audioStream.Stream = humSounds[0];
		audioStream.Play();
		currentHum = CurrentHum.Idle;

		LightningBolt lightBolt = (LightningBolt)Bolt.Instantiate();
		lightBolt.SetArcsColors(Green);
		lightBolt.SetArcsLayers(GameManager.AllPlayerViewMask);
		lightningBolt.Add(lightBolt);
		boltOrigin[0].AddChild(lightningBolt[0]);

		ElectricSphere = PhysicsServer3D.SphereShapeCreate();
		ElectricSphereCast = new PhysicsShapeQueryParameters3D();
		ElectricSphereCast.ShapeRid = ElectricSphere;
		PhysicsServer3D.ShapeSetData(ElectricSphere, lightningRadius);

		ExplosionSphere = PhysicsServer3D.SphereShapeCreate();
		ExplosionSphereCast = new PhysicsShapeQueryParameters3D();
		ExplosionSphereCast.ShapeRid = ExplosionSphere;
		PhysicsServer3D.ShapeSetData(ExplosionSphere, explosionRadius);
	}

	protected override void OnEnableQuad()
	{
		electricDamageMin *= GameManager.Instance.QuadMul;
		electricDamageMax *= GameManager.Instance.QuadMul;
	}

	protected override void OnPhysicsUpdate(float deltaTime, PhysicsDirectSpaceState3D SpaceState)
	{
		if (damageTime > 0)
			damageTime -= deltaTime;

		ElectricSphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		ElectricSphereCast.Motion = Vector3.Zero;
		ElectricSphereCast.Transform = GlobalTransform;
		var hits = SpaceState.IntersectShape(ElectricSphereCast);
		var max = hits.Count;

		int damaged = 0;
		for (int i = 0; (i < max) && (damaged < boltOrigin.Length); i++)
		{
			var hit = hits[i];

			CollisionObject3D posibleCollider = (CollisionObject3D)hit["collider"];
			if (posibleCollider == owner)
				continue;

			if (posibleCollider is Damageable)
			{
				Vector3 collision = posibleCollider.GlobalPosition;
				var RayCast = PhysicsRayQueryParameters3D.Create(GlobalPosition, collision, ((1 << GameManager.ColliderLayer) | (1 << GameManager.RagdollLayer) | GameManager.TakeDamageMask));
				var check = SpaceState.IntersectRay(RayCast);
				if (check.Count > 0)
				{
					CollisionObject3D collider = (CollisionObject3D)check["collider"];
					if (collider == owner)
						continue;

					if (collider is PhysicProjectile)
						continue;

					if (collider is Damageable damageable)
					{
						boltOrigin[damaged].Show();
						boltOrigin[damaged].LookAt(collision);
						if (damaged == lightningBolt.Count)
						{
							LightningBolt lightBolt = (LightningBolt)Bolt.Instantiate();
							lightBolt.SetArcsColors(Green);
							lightBolt.SetArcsLayers(GameManager.AllPlayerViewMask);
							lightningBolt.Add(lightBolt);
							boltOrigin[damaged].AddChild(lightningBolt[damaged]);
						}
						lightningBolt[damaged].SetBoltMesh(GlobalPosition, collision);
						if (damageTime <= 0)
							damageable.Damage(GD.RandRange(electricDamageMin, electricDamageMax), DamageType.Lightning, owner);
						damaged++;
					}
				}
			}

		}
		if (damaged > 0)
		{
			if (damageTime <= 0)
				damageTime = electricDamageRate + .05f;
			if (currentHum != CurrentHum.Fire)
			{
				audioStream.Stream = humSounds[1];
				audioStream.Play();
				currentHum = CurrentHum.Fire;
			}
			for (int i = damaged; i < boltOrigin.Length; i++)
				boltOrigin[i].Hide();
		}
		else
		{
			if (currentHum != CurrentHum.Idle)
			{
				audioStream.Stream = humSounds[0];
				audioStream.Play();
				currentHum = CurrentHum.Idle;
			}
			for (int i = 0; i < boltOrigin.Length; i++)
				boltOrigin[i].Hide();
		}
	}
	protected override void OnCollision(Vector3 collision, Vector3 normal, Vector3 direction, CollisionObject3D collider)
	{
		if (collider is Damageable damageable)
		{
			Vector3 impulseDir = direction.Normalized();
			damageable.Impulse(impulseDir, pushForce);
			damageable.Damage(GD.RandRange(damageMin, damageMax) * 100, DamageType.BFGBall, owner);
		}
	}
	protected override void OnExplosion(Vector3 Collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState)
	{
		ExplosionSphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		ExplosionSphereCast.Motion = Vector3.Zero;
		ExplosionSphereCast.Transform = new Transform3D(GlobalTransform.Basis, Collision);
		var hits = SpaceState.IntersectShape(ExplosionSphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is Damageable damageable)
			{
				//BFG never does self damage
				if (collider == owner)
					continue;

				Vector3 collision = collider.GlobalPosition;
				bool collide = false;
				if ((collider.CollisionLayer & (1 << GameManager.ColliderLayer)) == 0)
				{
					var RayCast = PhysicsRayQueryParameters3D.Create(GlobalPosition, collision, (1 << GameManager.ColliderLayer));
					var check = SpaceState.IntersectRay(RayCast);
					if (check.Count == 0)
						collide = true;
				}
				else
					collide = true;

				if (collide)
					damageable.Damage(GD.RandRange(damageMin, damageMax) * 100, DamageType.BFGBall, owner);
			}
		}

		PlayerInfo playerInfo = ((PlayerThing)owner).playerInfo;
		if (playerInfo != null)
		{
			Camera3D rayCaster = playerInfo.playerCamera.ViewCamera;
			Quaternion Camerarotation;
			Vector3 dir = direction;
			dir.Y = 0;
			int numRay = 0;
			Camerarotation = rayCaster.Quaternion;
			rayCaster.LookAt(playerInfo.playerCamera.GlobalPosition - dir);
			for (int index = 0; (index < BFGTracers.samples) && (numRay < 40); index++)
			{
				Vector3 Origin = playerInfo.playerCamera.GlobalPosition;
				dir = rayCaster.ProjectRayNormal(new Vector2(BFGTracers.hx[index] * 1280, BFGTracers.hy[index] * 720));
				Vector3 End = Origin + dir * 300;
				var RayCast = PhysicsRayQueryParameters3D.Create(Origin, End, ((1 << GameManager.ColliderLayer) | GameManager.TakeDamageMask & ~((playerInfo.playerLayer) | (1 << GameManager.InvisibleBlockerLayer) | (1 << GameManager.RagdollLayer))));
				var rayhit = SpaceState.IntersectRay(RayCast);
				if (rayhit.Count > 0)
				{
					CollisionObject3D collider = (CollisionObject3D)rayhit["collider"];

					if (collider is Damageable damageable)
					{
						while ((damageable.Dead == false) && (numRay < 40))
						{
							damageable.Impulse(dir, pushForce);
							damageable.Damage(GD.RandRange(49, 88), DamageType.BFGBlast, owner);
							numRay++;
						}
						if (!string.IsNullOrEmpty(SecondaryOnDeathSpawn))
						{
							Node3D DeathSpawn = (Node3D)ThingsManager.thingsPrefabs[SecondaryOnDeathSpawn].Instantiate();
							GameManager.Instance.TemporaryObjectsHolder.AddChild(DeathSpawn);
							DeathSpawn.Position = collider.GlobalPosition;
							DeathSpawn.SetForward(-direction);
							DeathSpawn.Rotate(direction, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
						}
					}
				}
			}
			rayCaster.Quaternion = Camerarotation;
		}
	}

	protected override void OnExplosionFX(Vector3 collision, Vector3 direction)
	{
		if (!string.IsNullOrEmpty(OnDeathSpawn))
		{
			Node3D DeathSpawn = (Node3D)ThingsManager.thingsPrefabs[OnDeathSpawn].Instantiate();
			GameManager.Instance.TemporaryObjectsHolder.AddChild(DeathSpawn);
			DeathSpawn.Position = collision + direction;
			DeathSpawn.SetForward(-direction);
			DeathSpawn.Rotate(direction, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
		}
	}

}```

./Assets/Scripts/Projectiles/Nail.cs:
```
using Godot;
using ExtensionMethods;

public partial class Nail : Projectile
{
	[Export]
	string AttackProjectileName = "";
	[Export]
	public string[] _hitSounds;
	public AudioStream[] hitSounds;
	public bool hasBounced = false;
	protected override void OnInit()
	{
		hitSounds = new AudioStream[_hitSounds.Length];
		for (int i = 0; i < _hitSounds.Length; i++)
			hitSounds[i] = SoundManager.LoadSound(_hitSounds[i]);
	}
	protected override void OnCollision(Vector3 collision, Vector3 normal, Vector3 direction, CollisionObject3D collider)
	{
		int soundIndex = 0;
		bool hitFx = true;
		if (collider is Damageable damageable)
		{
			Vector3 impulseDir = direction.Normalized();
			damageable.Impulse(impulseDir, pushForce);
			damageable.Damage(GD.RandRange(damageMin, damageMax), DamageType.Generic, owner);

			if (damageable.Bleed)
			{
				hitFx = false;
				soundIndex = 1; 
				Node3D Blood = (Node3D)ThingsManager.thingsPrefabs[ThingsManager.Blood].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(Blood);
				Blood.GlobalPosition = collision + (normal * .05f);
			}
		}
		if (hitFx)
		{
			if (MapLoader.mapSurfaceTypes.TryGetValue(collider, out SurfaceType st))
			{
				if (st.MetalSteps)
					soundIndex = 2;
				else if (st.Flesh)
					soundIndex = 1;
			}
			//65% chance of bounce
			if ((!hasBounced) && (GD.Randf() < 0.65f))
			{
				Vector3 Reflection = normal * 2 * direction.Dot(normal) - direction;
				Nail nail = (Nail)ThingsManager.thingsPrefabs[AttackProjectileName].Instantiate();
				GameManager.Instance.TemporaryObjectsHolder.AddChild(nail);
				nail.owner = owner;
				nail.damageMin = damageMin;
				nail.damageMax = damageMax;
				nail.GlobalPosition = collision + Reflection * .1f;
				nail.ignoreSelfLayer = ignoreSelfLayer;
				nail.hasBounced = true;
				nail.SetForward(Reflection);
				nail.InvoqueSetTransformReset();
			}
		}
		if (hitSounds.Length > soundIndex)
			SoundManager.Create3DSound(collision, hitSounds[soundIndex]);
	}
}
```

./Assets/Scripts/Projectiles/ProxMines.cs:
```
using Godot;
using System;
using ExtensionMethods;
public partial class ProxMines : PhysicProjectile, Damageable
{
	[Export]
	public int armingTime = 3;
	public bool currentWater = false;
	public GameManager.FuncState CurrentState = GameManager.FuncState.None;

	private float delayArm = 0; 
	private int hitpoints = 1;
	private int surfaceSoundIndex = 2;
	public int Hitpoints { get { return hitpoints; } }
	public bool Dead { get { return hitpoints <= 0; } }
	public bool Bleed { get { return false; } }
	public BloodType BloodColor { get { return BloodType.None; } }

	private Rid ContactSphere;
	private PhysicsShapeQueryParameters3D ContactSphereCast;
	private Rid TriggerSphere;
	private PhysicsShapeQueryParameters3D TriggerSphereCast;
	private Rid ExplosionSphere;
	private PhysicsShapeQueryParameters3D ExplosionSphereCast;

	protected override void OnInit()
	{
		ContactSphere = PhysicsServer3D.SphereShapeCreate();
		ContactSphereCast = new PhysicsShapeQueryParameters3D();
		ContactSphereCast.ShapeRid = ContactSphere;
		ContactSphereCast.CollisionMask = (1 << GameManager.ColliderLayer);
		PhysicsServer3D.ShapeSetData(ContactSphere, projectileRadius);

		TriggerSphere = PhysicsServer3D.SphereShapeCreate();
		TriggerSphereCast = new PhysicsShapeQueryParameters3D();
		TriggerSphereCast.ShapeRid = TriggerSphere;
		TriggerSphereCast.CollisionMask = GameManager.TakeDamageMask;
		PhysicsServer3D.ShapeSetData(TriggerSphere, explosionRadius / 3);

		ExplosionSphere = PhysicsServer3D.SphereShapeCreate();
		ExplosionSphereCast = new PhysicsShapeQueryParameters3D();
		ExplosionSphereCast.ShapeRid = ExplosionSphere;
		ExplosionSphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		PhysicsServer3D.ShapeSetData(ExplosionSphere, explosionRadius);
	}
	protected override void OnBodyEntered(Node other)
	{
		if (CurrentState != GameManager.FuncState.None)
			return;

		Freeze = true;
		var SpaceState = GetWorld3D().DirectSpaceState;
		ContactSphereCast.Transform = GlobalTransform;
		var hit = SpaceState.GetRestInfo(ContactSphereCast);
		if (hit.Count > 0)
		{
			CollisionObject3D Hit = (CollisionObject3D)InstanceFromId((ulong)hit["collider_id"]);
			Vector3 Collision = (Vector3)hit["point"];
			Vector3 Normal = (Vector3)hit["normal"];
			GlobalPosition = Collision;
			this.SetForward(-Normal);
			this.Rotate(Normal, (float)GD.RandRange(0, Mathf.Pi * 2.0f));
			if (MapLoader.mapSurfaceTypes.TryGetValue(Hit, out SurfaceType st))
			{
				if (st.MetalSteps)
					surfaceSoundIndex = 3;
				else if (st.Flesh)
					surfaceSoundIndex = 4;
			}
		}
		else if (other is Damageable damageable)
		{
			if (damageable.Bleed)
				surfaceSoundIndex = 3;
		}
		else if (other is CollisionObject3D collider)
		{
			if (MapLoader.mapSurfaceTypes.TryGetValue(collider, out SurfaceType st))
			{
				if (st.MetalSteps)
					surfaceSoundIndex = 3;
				else if (st.Flesh)
					surfaceSoundIndex = 4;
			}
		}

		CollisionLayer = (1 << GameManager.DamageablesLayer) | (1 << GameManager.ColliderLayer);
		CurrentState = GameManager.FuncState.Ready;
	}

	protected override void OnCheckWaterChange()
	{
		if (currentWater != inWater)
		{
			audioStream.Stream = waterSound;
			audioStream.Play();
			currentWater = inWater;
		}
	}

	protected override void OnPhysicsUpdate(float deltaTime)
	{
		switch (CurrentState)
		{
			default:
			case GameManager.FuncState.None:
				return;
			break;
			case GameManager.FuncState.Ready:
				if (delayArm == 0)
				{
					destroyTimer = 0;
					delayArm = armingTime - deltaTime;
					if (Sounds.Length > surfaceSoundIndex)
						SoundManager.Create3DSound(GlobalPosition, Sounds[surfaceSoundIndex]);
				}
				else if (delayArm > 0)
					delayArm -= deltaTime;
				else if (delayArm < 0)
				{
					delayArm = 0;
					if (Sounds.Length > 0)
						SoundManager.Create3DSound(GlobalPosition, Sounds[0]);
					TriggerSphereCast.Motion = Vector3.Zero;
					TriggerSphereCast.Transform = GlobalTransform;
					CurrentState = GameManager.FuncState.Start;
				}
			break;
			case GameManager.FuncState.Start:
				var SpaceState = GetWorld3D().DirectSpaceState;
				var hits = SpaceState.IntersectShape(TriggerSphereCast);
				var max = hits.Count;
				bool explode = false;
				for (int i = 0; i < max; i++)
				{
					var hit = hits[i];
					CollisionObject3D collider = (CollisionObject3D)hit["collider"];
					//Never activate owns mines
					if (collider == owner)
						continue;

					if (collider is PlayerThing player)
					{
						explode = true;
						break;
					}
				}
				if (explode)
				{
					if (Sounds.Length > 1)
						SoundManager.Create3DSound(GlobalPosition, Sounds[1]);
					Explode();
				}
				break;
		}
	}
	protected override void OnExplosion(Vector3 Collision, Vector3 direction, PhysicsDirectSpaceState3D SpaceState)
	{
		ExplosionSphereCast.Motion = Vector3.Zero;
		ExplosionSphereCast.Transform = new Transform3D(GlobalTransform.Basis, Collision);
		var hits = SpaceState.IntersectShape(ExplosionSphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is Damageable damageable)
			{
				Vector3 hPosition = collider.Position;
				Vector3 Distance = (hPosition - Collision);
				float lenght;
				Vector3 impulseDir = Distance.GetLenghtAndNormalize(out lenght);
				int damage = blastDamage;
				//mines won't do 0 damage to owner
				if (collider == owner)
					damage = Mathf.CeilToInt(damage / 3);
				damageable.Impulse(impulseDir, Mathf.Lerp(pushForce, 100, lenght / explosionRadius));
				damageable.Damage(Mathf.CeilToInt(Mathf.Lerp(damage, 1, lenght / explosionRadius)), DamageType.Explosion, owner);
			}
		}
	}

	public virtual void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null)
	{
		if (Dead)
			return;

		if ((damageType == DamageType.Explosion) || (damageType == DamageType.Plasma) || (damageType == DamageType.Lightning) || (damageType == DamageType.Rail) || (damageType == DamageType.BFGBall) || (damageType == DamageType.BFGBlast))
		{
			hitpoints = 0;
			//Delay Explosion in order to de-sync multiple mines
			destroyTimer = (float)GD.RandRange(0.1, 0.5);
		}
	}
	public void Impulse(Vector3 direction, float force)
	{

	}
}```

./Assets/Scripts/Projectiles/LightningBolt.cs:
```
using Godot;
using System;

public partial class LightningBolt : Node3D
{
	[Export]
	public MeshInstance3D[] Arcs;
	[Export]
	public ShaderMaterial boltMaterial;

	private float BoltLenght = 24f;
	private float BoltWidht = 2f;
	private ArrayMesh mesh;
	private MeshDataTool meshDataTool = new MeshDataTool();
	public override void _Ready()
	{
		mesh = Mesher.GenerateQuadMesh(BoltWidht, BoltLenght, 0.5f, 0f);
		mesh.SurfaceSetMaterial(0, boltMaterial);
		meshDataTool.CreateFromSurface(mesh, 0);
		meshDataTool.SetVertex(2, new Vector3(-.5f * BoltWidht, BoltLenght, 0));
		meshDataTool.SetVertex(3, new Vector3(.5f * BoltWidht, BoltLenght, 0));
		meshDataTool.SetVertexUV(2, new Vector2(0, BoltLenght / 2f));
		meshDataTool.SetVertexUV(3, new Vector2(1, BoltLenght / 2f));
		mesh.ClearSurfaces();
		meshDataTool.CommitToSurface(mesh);

		for (int i = 0; i<Arcs.Length; i++)
			Arcs[i].Mesh = mesh;

	}

	public void SetArcsColors(Color color)
	{
		for (int i = 0; i < Arcs.Length; i++)
			Arcs[i].SetInstanceShaderParameter("lightning_color", color);
	}

	public void SetArcsLayers(uint layer)
	{
		for (int i = 0; i < Arcs.Length; i++)
			Arcs[i].Layers = layer;
	}

	public void SetBoltLenght(float lenght)
	{
		BoltLenght = lenght;
		meshDataTool.SetVertex(2, new Vector3(-.5f * BoltWidht, BoltLenght, 0));
		meshDataTool.SetVertex(3, new Vector3(.5f * BoltWidht, BoltLenght, 0));
		meshDataTool.SetVertexUV(2, new Vector2(0, BoltLenght / 2f));
		meshDataTool.SetVertexUV(3, new Vector2(1, BoltLenght / 2f));
		mesh.ClearSurfaces();
		meshDataTool.CommitToSurface(mesh);
	}

	public void SetBoltMesh(Vector3 origin, Vector3 end)
	{
		Vector3 direction = (origin - end);
		BoltLenght = direction.Length();
		meshDataTool.SetVertex(2, new Vector3(-.5f * BoltWidht, BoltLenght, 0));
		meshDataTool.SetVertex(3, new Vector3(.5f * BoltWidht, BoltLenght, 0));
		meshDataTool.SetVertexUV(2, new Vector2(0, BoltLenght / 2f));
		meshDataTool.SetVertexUV(3, new Vector2(1, BoltLenght / 2f));
		mesh.ClearSurfaces();
		meshDataTool.CommitToSurface(mesh);
	}
}
```

./Assets/Scripts/ContentType.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;

public class ContentType
{
	public uint value;
	public bool Solid = false;
	public bool Lava = false;
	public bool Slime = false;
	public bool Water = false;
	public bool Fog = false;
	public bool AreaPortal = false;
	public bool PlayerClip = false;
	public bool MonsterClip = false;
	public bool Teleporter = false;
	public bool JumpPad = false;
	public bool ClusterPortal = false;
	public bool BotsNotEnter = false;
	public bool Origin = false;
	public bool Body = false;
	public bool Corpse = false;
	public bool Details = false;
	public bool Structural = false;
	public bool Translucent = false;
	public bool Trigger = false;
	public bool NoDrop = false;
	public void Init(uint contentType)
	{
		value = contentType;
		if ((contentType & ContentFlags.Solid) != 0)
			Solid = true;
		if ((contentType & ContentFlags.Lava) != 0)
			Lava = true;
		if ((contentType & ContentFlags.Slime) != 0)
			Slime = true;
		if ((contentType & ContentFlags.Water) != 0)
			Water = true;
		if ((contentType & ContentFlags.Fog) != 0)
			Fog = true;
		if ((contentType & ContentFlags.AreaPortal) != 0)
			AreaPortal = true;
		if ((contentType & ContentFlags.PlayerClip) != 0)
			PlayerClip = true;
		if ((contentType & ContentFlags.MonsterClip) != 0)
			MonsterClip = true;
		if ((contentType & ContentFlags.Teleporter) != 0)
			Teleporter = true;
		if ((contentType & ContentFlags.JumpPad) != 0)
			JumpPad = true;
		if ((contentType & ContentFlags.ClusterPortal) != 0)
			ClusterPortal = true;
		if ((contentType & ContentFlags.BotsNotEnter) != 0)
			BotsNotEnter = true;
		if ((contentType & ContentFlags.Origin) != 0)
			Origin = true;
		if ((contentType & ContentFlags.Body) != 0)
			Body = true;
		if ((contentType & ContentFlags.Corpse) != 0)
			Corpse = true;
		if ((contentType & ContentFlags.Details) != 0)
			Details = true;
		if ((contentType & ContentFlags.Structural) != 0)
			Structural = true;
		if ((contentType & ContentFlags.Translucent) != 0)
			Translucent = true;
		if ((contentType & ContentFlags.Trigger) != 0)
			Trigger = true;
		if ((contentType & ContentFlags.NoDrop) != 0)
			NoDrop = true;
	}

}
```

./Assets/Scripts/TextureLoader.cs:
```
using Godot;
using System.Collections.Generic;
using static Godot.Image;
using ExtensionMethods;

public static class TextureLoader
{
	public static ImageTexture illegal;
	public static readonly string FlareTexture = "GFX/MISC/FLARE";
	private static float defaultPixelSize = .01f;
	public enum ImageFormat
	{
		JPG,
		TGA,
		PNG
	}

	public static Dictionary<string, ImageTexture> Textures = new Dictionary<string, ImageTexture>();
	public static Dictionary<string, Cubemap> CubeMaps = new Dictionary<string, Cubemap>();
	public static Dictionary<string, ImageTexture> TransparentTextures = new Dictionary<string, ImageTexture>();
	public static Dictionary<string, ImageTexture> ColorizeTextures = new Dictionary<string, ImageTexture>();

	public static void CreateWhiteImage()
	{
		Image whiteImage = new Image();
		byte[] colors = new byte[8 * 8 * 3];
		for (int i = 0; i < colors.Length; i++)
			colors[i] = 0xFF;
		whiteImage.SetData(8, 8, false, Format.Rgb8, colors);
		ImageTexture whiteTex = ImageTexture.CreateFromImage(whiteImage);
		whiteTex.SetMeta("luminance", .35f);
		Textures.Add("$WHITEIMAGE", whiteTex);
	}

	public static void AddNewTexture(string textureName, bool forceSkinAlpha, bool compress = true)
	{
		List<QShader> list = new List<QShader>
		{
			new QShader(textureName, 0, 0, forceSkinAlpha)
		};
		LoadTextures(list, false, ImageFormat.PNG, compress);
		LoadTextures(list, false, ImageFormat.JPG, compress);
		LoadTextures(list, false , ImageFormat.TGA, compress);
	}
	public static bool HasTextureOrAddTexture(string textureName, bool forceAlpha)
	{
		if (forceAlpha)
		{
			if (TransparentTextures.ContainsKey(textureName))
				return true;
		}
		else if (Textures.ContainsKey(textureName))
			return true;

		GameManager.Print("GetTextureOrAddTexture: No texture \"" + textureName + "\"");
		AddNewTexture(textureName, forceAlpha);
		if (Textures.ContainsKey(textureName))
			return true;
		return false;
	}
	public static Cubemap GetCubeMap(string textureName)
	{
		if (CubeMaps.ContainsKey(textureName))
			return CubeMaps[textureName];

		GameManager.Print("GetCubeMap: No cubemap \"" + textureName + "\"");
		Cubemap cubemap = new Cubemap();
		Godot.Collections.Array<Image> cubeImages = new Godot.Collections.Array<Image>();
		List<string> cubeTextures = new List<string>()
		{
			textureName + "_FT",
			textureName + "_BK",
			textureName + "_UP",
			textureName + "_DN",
			textureName + "_RT",
			textureName + "_LF"
		};
		Vector2I size = Vector2I.Zero;
		foreach (string text in cubeTextures)
		{
			string FileName;
			for (int imageFormat = 0; imageFormat < 3; imageFormat++)
			{
				string path = text;
				switch (imageFormat)
				{
					default:
					case 0:
						path += ".PNG";
					break;
					case 1:
						path += ".JPG";
					break;
					case 2:
						path += ".TGA";
					break;
				}
					
				if (PakManager.ZipFiles.TryGetValue(path, out FileName))
				{
					byte[] imageBytes = PakManager.GetPK3FileData(path, FileName);

					Image baseTex = new Image();
					switch (imageFormat)
					{
						default:
						case 0:
							baseTex.LoadPngFromBuffer(imageBytes);
							break;
						case 1:
							baseTex.LoadJpgFromBuffer(imageBytes);
							break;
						case 2:
							baseTex.LoadTgaFromBuffer(imageBytes);
							break;
					}
					int width = baseTex.GetWidth();
					int height = baseTex.GetHeight();
					if (size.LengthSquared() == 0)
						size = new Vector2I(width, height);
					else if ((size.X != width) || (size.Y != height))
						baseTex.Resize(size.X, size.Y, Interpolation.Lanczos);
					baseTex.GenerateMipmaps();
					baseTex.CompressFromChannels(CompressMode.Bptc, UsedChannels.Rgb);
					cubeImages.Add(baseTex);
					break;
				}
			}
		}
		cubemap.CreateFromImages(cubeImages);
		CubeMaps.Add(textureName, cubemap);
		GameManager.Print("Adding cubemap with name " + textureName);
		return cubemap;
	}
	public static ImageTexture GetTextureOrAddTexture(string textureName, bool forceAlpha, bool compress = true)
	{
		ImageTexture texture;
		if (forceAlpha)
		{
			if (TransparentTextures.TryGetValue(textureName, out texture))
				return texture;
		}
		else if (Textures.TryGetValue(textureName, out texture))
			return texture;

		GameManager.Print("GetTextureOrAddTexture: No texture \"" + textureName + "\"");
		AddNewTexture(textureName, forceAlpha, compress);
		return GetTexture(textureName, forceAlpha);
	}
	public static bool HasTexture(string textureName)
	{
		string upperName = textureName.ToUpper();

		if (QShaderManager.HasShader(upperName))
			return true;
		if (Textures.ContainsKey(upperName))
			return true;
		return false;
	}
	public static ImageTexture GetTexture(string textureName, bool forceAlpha = false)
	{
		ImageTexture texture;
		if (forceAlpha)
		{
			if (TransparentTextures.TryGetValue(textureName, out texture))
				return texture;
		}
		else if (Textures.TryGetValue(textureName, out texture))
			return texture;

		GameManager.Print("GetTexture: Texture not found \"" + textureName + "\"", GameManager.PrintType.Warning);
		return illegal;
	}

	public static void LoadTexturesFromResource(Resource res)
	{
		Image baseTex = (Image)res;
		string TextName = "RES" + res.ResourcePath.StripExtension().ToUpper().Substring(5);
		int width = baseTex.GetWidth();
		int height = baseTex.GetHeight();
		float luminance = 0;

		if (baseTex.DetectAlpha() == AlphaMode.None)
		{
			baseTex.Convert(Format.Rgba8);
			Color black = Colors.Black;
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					Color pulledColors = baseTex.GetPixel(i, j);
					luminance += .21f * pulledColors.R + .72f * pulledColors.G + .07f * pulledColors.G;
					float alpha = computeAlphaFromColorFilter(pulledColors, black);
					pulledColors.A = alpha;
					baseTex.SetPixel(i, j, pulledColors);
				}
			}
		}
		else
		{
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					Color pulledColors = baseTex.GetPixel(i, j);
					luminance += .21f * pulledColors.R + .72f * pulledColors.G + .07f * pulledColors.G;
				}
			}
		}
		luminance /= (width * height);
		luminance = Mathf.Clamp(luminance, 0f, .35f);
		bool hasAlpha = (baseTex.DetectAlpha() != AlphaMode.None);
		baseTex.ResizeToPo2(false, Interpolation.Lanczos);
		baseTex.GenerateMipmaps();
		baseTex.CompressFromChannels(CompressMode.S3Tc, UsedChannels.Rgba);
		ImageTexture readyTex = ImageTexture.CreateFromImage(baseTex);
		readyTex.SetMeta("luminance", luminance);

		if (Textures.ContainsKey(TextName))
		{
			if (hasAlpha)
			{
				GameManager.Print("Adding transparent texture with name " + TextName);
				TransparentTextures.Add(TextName, readyTex);
			}
			else
			{
				GameManager.Print("Updating texture with name " + TextName);
				Textures[TextName] = readyTex;
			}
		}
		else
		{
			if (hasAlpha)
			{
				GameManager.Print("Adding transparent texture with name " + TextName);
				TransparentTextures.Add(TextName, readyTex);
			}
			else
				GameManager.Print("Adding texture with name " + TextName);
			Textures.Add(TextName, readyTex);
		}
	}

	public static void LoadTextures(List<QShader> mapTextures, bool ignoreShaders, ImageFormat imageFormat, bool compress = true)
	{
		foreach (QShader tex in mapTextures)
		{
			string path = tex.name;
			string FileName;

			if (ignoreShaders)
				if (QShaderManager.QShaders.ContainsKey(tex.name))
					continue;

			if (imageFormat == ImageFormat.TGA)
				path += ".TGA";
			else if (imageFormat == ImageFormat.JPG)
				path += ".JPG";
			else
				path += ".PNG";

			if (Textures.ContainsKey(tex.name))
			{
				if (tex.addAlpha)
				{
					if (TransparentTextures.ContainsKey(tex.name))
						continue;
				}
				else
					continue;
			}

			if (PakManager.ZipFiles.TryGetValue(path, out FileName))
			{
				byte[] imageBytes = PakManager.GetPK3FileData(path, FileName);

				Image baseTex = new Image();
				if (imageFormat == ImageFormat.TGA)
					baseTex.LoadTgaFromBuffer(imageBytes);
				else if (imageFormat == ImageFormat.JPG)
					baseTex.LoadJpgFromBuffer(imageBytes);
				else
					baseTex.LoadPngFromBuffer(imageBytes);

				int width = baseTex.GetWidth();
				int height = baseTex.GetHeight();
				float luminance = 0;

				if ((tex.addAlpha) && (baseTex.DetectAlpha() == AlphaMode.None))
				{
					baseTex.Convert(Format.Rgba8);
					Color black = Colors.Black;
					for (int i = 0; i < width; i++)
					{
						for (int j = 0; j < height; j++)
						{
							Color pulledColors = baseTex.GetPixel(i, j);
							luminance += .21f * pulledColors.R + .72f * pulledColors.G + .07f * pulledColors.G;
							float alpha = computeAlphaFromColorFilter(pulledColors, black);
							pulledColors.A = alpha;
							baseTex.SetPixel(i, j, pulledColors);
						}
					}
				}
				else
				{
					for (int i = 0; i < width; i++)
					{
						for (int j = 0; j < height; j++)
						{
							Color pulledColors = baseTex.GetPixel(i, j);
							luminance += .21f * pulledColors.R + .72f * pulledColors.G + .07f * pulledColors.G;
						}
					}
				}
				luminance /= (width * height);
				luminance = Mathf.Clamp(luminance, 0f, .35f);
				bool hasAlpha = (baseTex.DetectAlpha() != AlphaMode.None);
				if (compress)
				{
					baseTex.ResizeToPo2(false, Interpolation.Lanczos);
					baseTex.GenerateMipmaps();
					baseTex.CompressFromChannels(CompressMode.S3Tc, UsedChannels.Rgba);
				}
				ImageTexture readyTex = ImageTexture.CreateFromImage(baseTex);
				readyTex.SetMeta("luminance", luminance);

				if (Textures.ContainsKey(tex.name))
				{
					if ((tex.addAlpha) || (hasAlpha))
					{
						GameManager.Print("Adding transparent texture with name " + tex.name + "." + imageFormat);
						TransparentTextures.Add(tex.name, readyTex);
					}
					else
					{
						GameManager.Print("Updating texture with name " + tex.name + "." + imageFormat);
						Textures[tex.name] = readyTex;
					}
				}
				else
				{
					if ((tex.addAlpha) || (hasAlpha))
					{
						GameManager.Print("Adding transparent texture with name " + tex.name + "."+ imageFormat);
						TransparentTextures.Add(tex.name, readyTex);
					}
					else
						GameManager.Print("Adding texture with name " + tex.name + "." + imageFormat);
					Textures.Add(tex.name, readyTex);
				}
			}
			else
				GameManager.Print("Image not found " + tex.name + "." + imageFormat);
		}
	}
	public static void AdjustIconSize(Sprite3D sprite, int size)
	{
		Vector2 Size = sprite.Texture.GetSize();
		int maxSize = (int)Mathf.Max(Size.X, Size.Y);
		if (maxSize != size)
		{
			float ratio = maxSize / size;
			sprite.PixelSize = defaultPixelSize / ratio;
		}
	}
	public static float computeAlphaFromColorFilter(Color color, Color filter)
	{ 
		return Mathf.Max(Mathf.Max(Mathf.Abs(color.R - filter.R), Mathf.Abs(color.G - filter.G)), Mathf.Abs(color.B - filter.B));
	}
	public static ImageTexture CreateLightmapTexture(byte[] rgb)
	{
		Color colors;
		int pixelSize = (int)MapLoader.currentLightMapSize;
		Image baseTex = CreateEmpty(pixelSize, pixelSize, false, Format.Rgb8);
		int k = 0;
		for (int j = 0; j < pixelSize; j++)
		{
			for (int i = 0; i < pixelSize; i++)
			{
				colors = ChangeColorLighting(rgb[k++], rgb[k++], rgb[k++]);
				baseTex.SetPixel(i, j, colors);
			}
		}
		baseTex.GenerateMipmaps();
		baseTex.CompressFromChannels(CompressMode.Bptc, UsedChannels.Rgb);
		ImageTexture tex = ImageTexture.CreateFromImage(baseTex);
		return tex;
	}

	public static (ImageTexture3D, ImageTexture3D) CreateLightVolTextures(byte[] data, Vector3 mapMinCoord, Vector3 mapMaxCoord, ref Vector3 Normalize, ref Vector3 OffSet)
	{
		int num = data.Length / 8;
		if (num == 0)
		{
			Normalize = Vector3.Zero;
			OffSet = Vector3.Zero;
			return (null, null);
		}
		
		Color ambient, directional;
		Vector3I Size = new Vector3I((int)(Mathf.Floor(mapMaxCoord.X / 64) - Mathf.Ceil(mapMinCoord.X / 64) + 1),(int)(Mathf.Floor(mapMaxCoord.Y / 64) - Mathf.Ceil(mapMinCoord.Y / 64) + 1),(int)(Mathf.Floor(mapMaxCoord.Z / 128) - Mathf.Ceil(mapMinCoord.Z / 128) + 1));
		int clusterSize = Size.X * Size.Y * Size.Z * 8;
		if (clusterSize != data.Length)
		{
			Normalize = Vector3.Zero;
			OffSet = Vector3.Zero;
			return (null, null);
		}

		OffSet = QuakeToGodot.Vect3(mapMinCoord);
		Godot.Collections.Array<Image> AmbientImage = new Godot.Collections.Array<Image>();
		Godot.Collections.Array<Image> DirectionalImage = new Godot.Collections.Array<Image>();

		int k = 0;
		int index;
		byte[] dataAmbient = new byte[Size.X * Size.Y * 4];
		byte[] dataDirectional = new byte[Size.X * Size.Y * 4];
		for (int z = 0; z < Size.Z; z++)
		{
			Image Ambient = new Image();
			Image Directional = new Image();
			index = 0;
			for (int y = 0; y < Size.Y; y++)
			{
				for (int x = 0; x < Size.X; x++)
				{
					ambient = ChangeColorLighting(data[k++], data[k++], data[k++]);
					directional = ChangeColorLighting(data[k++], data[k++], data[k++]);

					dataAmbient[index] = (byte)ambient.R8;
					dataDirectional[index++] = (byte)directional.R8;

					dataAmbient[index] = (byte)ambient.G8;
					dataDirectional[index++] = (byte)directional.G8;

					dataAmbient[index] = (byte)ambient.B8;
					dataDirectional[index++] = (byte)directional.B8;

					dataAmbient[index] = data[k++]; //phi
					dataDirectional[index++] = data[k++]; // theta
				}
			}
			Ambient.SetData(Size.X, Size.Y, false, Format.Rgba8, dataAmbient);
			Directional.SetData(Size.X, Size.Y, false, Format.Rgba8, dataDirectional);
			Ambient.CompressFromChannels(CompressMode.Bptc, UsedChannels.Rgba);
			Directional.CompressFromChannels(CompressMode.Bptc, UsedChannels.Rgba);
			AmbientImage.Add(Ambient);
			DirectionalImage.Add(Directional);
		}
		ImageTexture3D AmbientTex = new ImageTexture3D();
		ImageTexture3D DirectionalTex = new ImageTexture3D();
		AmbientTex.Create(Format.BptcRgba, Size.X, Size.Y, Size.Z, false, AmbientImage);
		DirectionalTex.Create(Format.BptcRgba, Size.X, Size.Y, Size.Z, false, DirectionalImage);
		GameManager.Print("3D Grid N: X=" + Size.X + " Y=" + Size.Y + " Z=" + Size.Z);
		Normalize = new Vector3(Size.X * 2, Size.Y * 2, Size.Z * 4);
		return (AmbientTex, DirectionalTex);
	}

	public static Color ChangeColorLighting(byte r, byte g, byte b)
	{
		float scale = 1.0f, temp;
		float R, G, B;

		R = r * GameManager.Instance.colorLightning / 255.0f;
		G = g * GameManager.Instance.colorLightning / 255.0f;
		B = b * GameManager.Instance.colorLightning / 255.0f;

		if (R > 1.0f && (temp = (1.0f / R)) < scale)
			scale = temp;
		if (G > 1.0f && (temp = (1.0f / G)) < scale)
			scale = temp;
		if (B > 1.0f && (temp = (1.0f / B)) < scale)
			scale = temp;

		R *= scale;
		G *= scale;
		B *= scale;
		return new Color(R, G, B, 1f);
	}
	public static Color ChangeColorLighting(Color icolor)
	{
		float scale = 1.0f, temp;
		float R, G, B;

		R = icolor.R * GameManager.Instance.colorLightning;
		G = icolor.G * GameManager.Instance.colorLightning;
		B = icolor.B * GameManager.Instance.colorLightning;

		if (R > 1.0f && (temp = (1.0f / R)) < scale)
			scale = temp;
		if (G > 1.0f && (temp = (1.0f / G)) < scale)
			scale = temp;
		if (B > 1.0f && (temp = (1.0f / B)) < scale)
			scale = temp;

		R *= scale;
		G *= scale;
		B *= scale;

		return new Color(R, G, B, 1f);
	}
}
```

./Assets/Scripts/ThingControllers/DoorController.cs:
```
using Godot;
using System.Collections.Generic;

public partial class DoorController : AnimatableBody3D, Damageable, Crusher
{
	public bool doorOn = false;
	public bool playSoundClose = true;
	public string startSound = "movers/doors/dr1_strt";
	public string endSound = "movers/doors/dr1_end";
	public TriggerController tc;
	public int damage = 4;
	public bool crusher = false;
	private int hitpoints = 0;
	private float lip;
	private Aabb door;
	private float speed;

	private float wait = 2;
	private float openWaitTime = 0;
	private Vector3 openPosition, closedPosition;
	private Vector3 dirVector = Vector3.Right;

	public virtual float waitTime { get { return wait; } set { wait = value; } }
	public virtual bool Activated { get { return doorOn; } set { doorOn = value; } }
	public int Hitpoints { get { return hitpoints; } }
	public bool Dead { get { return hitpoints <= 0; } }
	public bool Bleed { get { return false; } }
	public BloodType BloodColor { get { return BloodType.None; } }

	public MultiAudioStream audioStream;
	private float openSqrMagnitude;
	private List<PlayerThing> playersToCrush = new List<PlayerThing>();
	public enum State
	{
		None,
		Closed,
		Closing,
		Open,
		Opening
	}

	public State currentState = State.Closed;

	public State CurrentState
	{
		get { return currentState; }
		set
		{
			if (value == State.Open)
			{
				if (!string.IsNullOrEmpty(endSound))
				{
					audioStream.Stream = SoundManager.LoadSound(endSound);
					audioStream.Play();
				}
				openWaitTime = waitTime;
			}
			else if (value == State.Opening)
			{
				if (!string.IsNullOrEmpty(startSound))
				{
					audioStream.Stream = SoundManager.LoadSound(startSound);
					audioStream.Play();
				}
				Activated = true;
				SetPhysicsProcess(true);
			}
			else if (value == State.Closing)
			{
				if (playSoundClose)
					if (!string.IsNullOrEmpty(startSound))
					{
						audioStream.Stream = SoundManager.LoadSound(startSound);
						audioStream.Play();
					}

				SetPhysicsProcess(true);
			}
			else if (value == State.Closed)
			{
				if (playSoundClose)
					if (!string.IsNullOrEmpty(endSound))
					{
						audioStream.Stream = SoundManager.LoadSound(endSound);
						audioStream.Play();
					}
				Activated = false;
				SetPhysicsProcess(false);
			}
			currentState = value;
		}
	}
	public void Init(int angle, int hp, int sp, float wait, int openlip, Aabb box, int dmg = 0)
	{
		SetAngle(angle);

		hitpoints = hp;
		if (!Dead)
			CollisionLayer |= (1 << GameManager.DamageablesLayer);

		speed = sp * GameManager.sizeDividor;
		waitTime = wait;
		lip = openlip * GameManager.sizeDividor;
		damage = dmg;
		if (dmg > 100)
			crusher = true;
		SetBounds(box);

		audioStream = new MultiAudioStream();
		AddChild(audioStream);
		audioStream.Bus = "BKGBus";
		audioStream.Position = door.GetCenter();
	}
	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (playersToCrush.Count > 0)
		{
			for (int i = 0; i < playersToCrush.Count; i++)
			{
				playersToCrush[i].Damage(damage, DamageType.Crusher);
				if (!crusher)
					CurrentState = State.Opening;

			}
			playersToCrush.Clear();
		}

		float deltaTime = (float)delta;
		switch (CurrentState)
		{
			default:
				break;

			case State.Open:
				if (openWaitTime > 0)
				{
					openWaitTime -= deltaTime;
					if (openWaitTime <= 0)
						CurrentState = State.Closing;
				}
				break;

			case State.Closing:
				{
					float newDistance = deltaTime * speed;
					Vector3 newPosition = Position - dirVector * newDistance;
					float sqrMagnitude = (openPosition - newPosition).LengthSquared();
					if (sqrMagnitude > openSqrMagnitude)
					{
						newPosition = closedPosition;
						CurrentState = State.Closed;
					}
					Position = newPosition;
				}
				break;
			case State.Closed:
				break;

			case State.Opening:
				{
					float newDistance = deltaTime * speed;
					Vector3 newPosition = Position + dirVector * newDistance;
					float sqrMagnitude = (newPosition - closedPosition).LengthSquared();
					if (sqrMagnitude > openSqrMagnitude)
					{
						newPosition = openPosition;
						CurrentState = State.Open;
					}
					Position = newPosition;
				}
				break;
		}
	}
	public void SetAngle(int angle)
	{
		if (angle < 0)
		{
			if (angle == -1)
				dirVector = Vector3.Up;
			else
				dirVector = Vector3.Down;
			return;
		}
		//Remember angles are rotated 90
		Quaternion rotation = new Quaternion(Vector3.Up, Mathf.DegToRad(angle + 90));
		dirVector = rotation * Vector3.Forward;
	}

	public void SetBounds(Aabb box)
	{
		door = box;
		closedPosition = Position;
		Vector3 extension = new Vector3(dirVector.X * (door.Size.X - lip), dirVector.Y * (door.Size.Y - lip), dirVector.Z * (door.Size.Z - lip));
		openPosition = closedPosition + extension;
		openSqrMagnitude = (openPosition - closedPosition).LengthSquared();
	}
	public virtual void Damage(int amount, DamageType damageType = DamageType.Generic, Node3D attacker = null)
	{
		if (Dead)
			return;

		if (!Activated)
			CurrentState = State.Opening;
	}
	public void Impulse(Vector3 direction, float force)
	{

	}

	public void Crush(PlayerThing player)
	{
		//Crush on main thread
		if (!playersToCrush.Contains(player))
			playersToCrush.Add(player);
	}
}
```

./Assets/Scripts/ThingControllers/JumpPadThing.cs:
```
using Godot;
using System;
public partial class JumpPadThing : Area3D
{
	public string BoingSound = "world/jumppad";

	private Vector3 destination;
	private Vector3 position;
	private MultiAudioStream audioStream;
	public override void _Ready()
	{
		BodyEntered += OnBodyEntered;
	}
	public void Init(Vector3 dest, Vector3 center)
	{
		destination = dest;
		position = GlobalPosition;
		if (string.IsNullOrEmpty(BoingSound))
			return;

		audioStream = new MultiAudioStream();
		AddChild(audioStream);
		audioStream.GlobalPosition = center;
		audioStream.Bus = "BKGBus";
		audioStream.Stream = SoundManager.LoadSound(BoingSound);
	}

	void OnBodyEntered(Node3D other)
	{
		if (GameManager.Paused)
			return;

		if (other is PlayerThing playerThing)
		{
			if (!playerThing.ready)
				return;

			if (!string.IsNullOrEmpty(BoingSound))
				audioStream.Play();

			playerThing.JumpPadDest(destination);
		}
	}
}```

./Assets/Scripts/ThingControllers/ItemPickup.cs:
```
using Godot;
using System;
public partial class ItemPickup : Area3D
{
	public enum ItemType
	{
		Health,
		Armor,
		Weapon,
		Bullets,
		Shells,
		Grenades,
		Rockets,
		Lightning,
		Slugs,
		Cells,
		Bfgammo,
		Quad,
		Haste,
		Regen,
		Invis,
		Enviro,
		Flight,
		Teleporter,
		AmmoPack,
		ChainBullets,
		Nails,
		Mines
	}
	[Export]
	public ThingController thingController;
	[Export]
	public ItemType itemType;
	[Export]
	public int amount;
	[Export]
	public bool bonus;
	[Export]
	public int givesWeapon = -1;
	[Export]
	public string PickupSound;
	[Export]
	public string SecondaryPickupSound;
	[Export]
	public string PickupIcon;
	[Export]
	public string PickupText;

	public override void _Ready()
	{
		PickupIcon = PickupIcon.ToUpper();
		BodyEntered += OnBodyEntered;
	}

	public bool PickUp(PlayerThing player, bool disableCollider = true)
	{
		bool disable = false;
		switch (itemType)
		{
			default:
				break;

			case ItemType.AmmoPack:
				if (player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.bulletsAmmo])
				{
					player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.bulletsAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.bulletsAmmo])
						player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.bulletsAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.bulletsAmmo], PlayerInfo.bulletsAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.Shotgun]) && (player.playerInfo.Ammo[PlayerInfo.shellsAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.shellsAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.shellsAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.shellsAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.shellsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.shellsAmmo])
						player.playerInfo.Ammo[PlayerInfo.shellsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.shellsAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.shellsAmmo], PlayerInfo.shellsAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.GrenadeLauncher]) && (player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.grenadesAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.grenadesAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.grenadesAmmo])
						player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.grenadesAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.grenadesAmmo], PlayerInfo.grenadesAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.RocketLauncher]) && (player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.rocketsAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.rocketsAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.rocketsAmmo])
						player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.rocketsAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.rocketsAmmo], PlayerInfo.rocketsAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.LightningGun]) && (player.playerInfo.Ammo[PlayerInfo.lightningAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.lightningAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.lightningAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.lightningAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.lightningAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.lightningAmmo])
						player.playerInfo.Ammo[PlayerInfo.lightningAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.lightningAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.lightningAmmo], PlayerInfo.lightningAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.Railgun]) && (player.playerInfo.Ammo[PlayerInfo.slugAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.slugAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.slugAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.slugAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.slugAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.slugAmmo])
						player.playerInfo.Ammo[PlayerInfo.slugAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.slugAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.slugAmmo], PlayerInfo.slugAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.PlasmaGun]) && (player.playerInfo.Ammo[PlayerInfo.cellsAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.cellsAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.cellsAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.cellsAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.cellsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.cellsAmmo])
						player.playerInfo.Ammo[PlayerInfo.cellsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.cellsAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.cellsAmmo], PlayerInfo.cellsAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.BFG10K]) && (player.playerInfo.Ammo[PlayerInfo.bfgAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.bfgAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.bfgAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.bfgAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.bfgAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.bfgAmmo])
						player.playerInfo.Ammo[PlayerInfo.bfgAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.bfgAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.bfgAmmo], PlayerInfo.bfgAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.NailGun]) && (player.playerInfo.Ammo[PlayerInfo.nailAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.nailAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.nailAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.nailAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.nailAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.nailAmmo])
						player.playerInfo.Ammo[PlayerInfo.nailAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.nailAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.nailAmmo], PlayerInfo.nailAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.ChainGun]) && (player.playerInfo.Ammo[PlayerInfo.chainAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.chainAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.chainAmmo] += (player.playerInfo.DefaultAmmo[PlayerInfo.chainAmmo] * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.chainAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.chainAmmo])
						player.playerInfo.Ammo[PlayerInfo.chainAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.chainAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.chainAmmo], PlayerInfo.chainAmmo);
					disable = true;
				}
				if ((player.playerInfo.Weapon[PlayerInfo.ProxLauncher]) && (player.playerInfo.Ammo[PlayerInfo.minesAmmo] < player.playerInfo.MaxAmmo[PlayerInfo.minesAmmo]))
				{
					player.playerInfo.Ammo[PlayerInfo.minesAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
					if (player.playerInfo.Ammo[PlayerInfo.minesAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.minesAmmo])
						player.playerInfo.Ammo[PlayerInfo.minesAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.minesAmmo];
					player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.minesAmmo], PlayerInfo.minesAmmo);
					disable = true;
				}
				break;

			case ItemType.Bullets:
				if (player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.bulletsAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.bulletsAmmo])
					player.playerInfo.Ammo[PlayerInfo.bulletsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.bulletsAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.bulletsAmmo], PlayerInfo.bulletsAmmo);
				disable = true;
				break;

			case ItemType.Shells:
				if (player.playerInfo.Ammo[PlayerInfo.shellsAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.shellsAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.shellsAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.shellsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.shellsAmmo])
					player.playerInfo.Ammo[PlayerInfo.shellsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.shellsAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.shellsAmmo], PlayerInfo.shellsAmmo);
				disable = true;
				break;

			case ItemType.Grenades:
				if (player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.grenadesAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.grenadesAmmo])
					player.playerInfo.Ammo[PlayerInfo.grenadesAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.grenadesAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.grenadesAmmo], PlayerInfo.grenadesAmmo);
				disable = true;
				break;

			case ItemType.Rockets:
				if (player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.rocketsAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.rocketsAmmo])
					player.playerInfo.Ammo[PlayerInfo.rocketsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.rocketsAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.rocketsAmmo], PlayerInfo.rocketsAmmo);
				disable = true;
				break;

			case ItemType.Lightning:
				if (player.playerInfo.Ammo[PlayerInfo.lightningAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.lightningAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.lightningAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.lightningAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.lightningAmmo])
					player.playerInfo.Ammo[PlayerInfo.lightningAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.lightningAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.lightningAmmo], PlayerInfo.lightningAmmo);
				disable = true;
				break;

			case ItemType.Slugs:
				if (player.playerInfo.Ammo[PlayerInfo.slugAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.slugAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.slugAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.slugAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.slugAmmo])
					player.playerInfo.Ammo[PlayerInfo.slugAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.slugAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.slugAmmo], PlayerInfo.slugAmmo);
				disable = true;
				break;

			case ItemType.Cells:
				if (player.playerInfo.Ammo[PlayerInfo.cellsAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.cellsAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.cellsAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.cellsAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.cellsAmmo])
					player.playerInfo.Ammo[PlayerInfo.cellsAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.cellsAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.cellsAmmo], PlayerInfo.cellsAmmo);
				disable = true;
				break;

			case ItemType.Bfgammo:
				if (player.playerInfo.Ammo[PlayerInfo.bfgAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.bfgAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.bfgAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.bfgAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.bfgAmmo])
					player.playerInfo.Ammo[PlayerInfo.bfgAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.bfgAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.bfgAmmo], PlayerInfo.bfgAmmo);
				disable = true;
				break;

			case ItemType.ChainBullets:
				if (player.playerInfo.Ammo[PlayerInfo.chainAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.chainAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.chainAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.chainAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.chainAmmo])
					player.playerInfo.Ammo[PlayerInfo.chainAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.chainAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.chainAmmo], PlayerInfo.chainAmmo);
				disable = true;
				break;

			case ItemType.Nails:
				if (player.playerInfo.Ammo[PlayerInfo.nailAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.nailAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.nailAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.nailAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.nailAmmo])
					player.playerInfo.Ammo[PlayerInfo.nailAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.nailAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.nailAmmo], PlayerInfo.nailAmmo);
				disable = true;
				break;

			case ItemType.Mines:
				if (player.playerInfo.Ammo[PlayerInfo.minesAmmo] == player.playerInfo.MaxAmmo[PlayerInfo.minesAmmo])
					break;

				player.playerInfo.Ammo[PlayerInfo.minesAmmo] += (amount * GameManager.Instance.PlayerAmmoReceive);
				if (player.playerInfo.Ammo[PlayerInfo.minesAmmo] > player.playerInfo.MaxAmmo[PlayerInfo.minesAmmo])
					player.playerInfo.Ammo[PlayerInfo.minesAmmo] = player.playerInfo.MaxAmmo[PlayerInfo.minesAmmo];
				player.playerInfo.playerPostProcessing.playerHUD.UpdateAmmo(player.playerInfo.Ammo[PlayerInfo.minesAmmo], PlayerInfo.minesAmmo);
				disable = true;
				break;

			case ItemType.Health:
				if (bonus)
				{
					if (player.hitpoints == player.playerInfo.MaxBonusHealth)
						break;

					player.hitpoints += amount;
					if (player.hitpoints > player.playerInfo.MaxBonusHealth)
						player.hitpoints = player.playerInfo.MaxBonusHealth;
				}
				else
				{
					if (player.hitpoints >= player.playerInfo.MaxHealth)
						break;

					player.hitpoints += amount;
					if (player.hitpoints > player.playerInfo.MaxHealth)
						player.hitpoints = player.playerInfo.MaxHealth;
				}
				player.playerInfo.playerPostProcessing.playerHUD.UpdateHealth(player.hitpoints);
				disable = true;
				break;

			case ItemType.Armor:
				if (bonus)
				{
					if (player.armor == player.playerInfo.MaxBonusArmor)
						break;

					player.armor += amount;
					if (player.armor > player.playerInfo.MaxBonusArmor)
						player.armor = player.playerInfo.MaxBonusArmor;
				}
				else
				{
					if (player.armor >= player.playerInfo.MaxArmor)
						break;

					player.armor += amount;
					if (player.armor > player.playerInfo.MaxArmor)
						player.armor = player.playerInfo.MaxArmor;
				}
				player.playerInfo.playerPostProcessing.playerHUD.UpdateArmor(player.armor);
				disable = true;
				break;

			case ItemType.Quad:
				player.playerInfo.quadDamage = true;
				player.quadTime += amount;
				player.playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Quad, Mathf.CeilToInt(player.quadTime));
				disable = true;
				break;

			case ItemType.Haste:
				player.playerInfo.haste = true;
				player.hasteTime += amount;
				player.playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Haste, Mathf.CeilToInt(player.hasteTime));
				disable = true;
				break;

			case ItemType.Regen:
				player.regenTime += amount;
				player.playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Regen, Mathf.CeilToInt(player.regenTime));
				disable = true;
				break;

			case ItemType.Invis:
				player.playerInfo.invis = true;
				player.invisTime += amount;
				player.playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Invis, Mathf.CeilToInt(player.invisTime));
				disable = true;
				break;

			case ItemType.Enviro:
				player.playerInfo.battleSuit = true;
				player.enviroSuitTime += amount;
				player.playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.EnviroSuit, Mathf.CeilToInt(player.enviroSuitTime));
				disable = true;
				break;

			case ItemType.Flight:
				player.playerInfo.flight = true;
				player.flightTime += amount;
				player.playerInfo.playerPostProcessing.playerHUD.UpdatePowerUpTime(PlayerHUD.PowerUpType.Flight, Mathf.CeilToInt(player.flightTime));
				disable = true;
				break;

			case ItemType.Teleporter:
				if (player.holdableItem != PlayerThing.HoldableItem.None)
					break;
				player.holdableItem = PlayerThing.HoldableItem.Teleporter;
				player.playerInfo.playerPostProcessing.playerHUD.AddHoldableItem(PlayerThing.HoldableItem.Teleporter);
				disable = true;
				break;
		}

		bool showItemPickUp = true;
		if (givesWeapon != -1)
		{
			if (givesWeapon >= 0 && givesWeapon < player.playerInfo.Weapon.Length)
			{
				if (!player.playerInfo.Weapon[givesWeapon])
				{
					player.playerInfo.Weapon[givesWeapon] = true;

					if (player.playerInfo.configData.AutoSwap)
					{
						player.playerInfo.playerPostProcessing.playerHUD.AddWeapon(givesWeapon);
						player.playerControls.TrySwapWeapon(givesWeapon);
					}
					else
						player.playerInfo.playerPostProcessing.playerHUD.AddWeapon(givesWeapon, player.playerControls.CurrentWeapon);

					showItemPickUp = false;
					disable = true;
				}
			}
		}

		if (disable)
		{
			player.playerInfo.playerPostProcessing.playerHUD.pickupFlashTime(.3f);
			if (disableCollider)
				thingController.DisableThing();
			if (!string.IsNullOrEmpty(PickupSound))
			{
				AudioStream sound = SoundManager.LoadSound(PickupSound);
				if ((sound == null) && (!string.IsNullOrEmpty(SecondaryPickupSound)))
					sound = SoundManager.LoadSound(GameManager.Instance.announcer + SecondaryPickupSound);
				if (sound != null)
					SoundManager.Create3DSound(GlobalPosition, sound);
			}
			if (!string.IsNullOrEmpty(PickupText))
				if (showItemPickUp)
					player.playerInfo.playerPostProcessing.playerHUD.ItemPickUp(PickupIcon, PickupText);
		}

		return disable;
	}

	void OnBodyEntered(Node3D other)
	{
		if (thingController.disabled)
			return;

		if (other is PlayerThing player)
		{
			if (!player.ready)
				return;

			PickUp(player);
		}
	}
}
```

./Assets/Scripts/ThingControllers/SpawnPosition.cs:
```
using Godot;
using System.Collections.Generic;
public partial class SpawnPosition : ThingController
{
	public Target spawnPosition;
	public SpawnType spawnType;
	public enum SpawnType
	{
		DeathMatch,
		Red,
		Blue
	}
	public void Init(int angle, Dictionary<string, string> entityData, SpawnType type = SpawnType.DeathMatch)
	{
		angle = angle + 90;
		if (angle < -180)
			angle += 360;
		if (angle > 180)
			angle -= 360;
		spawnPosition = new Target(GlobalPosition, angle, entityData);
		spawnType = type;
		SpawnerManager.AddToList(this);
	}
}
```

./Assets/Scripts/ThingControllers/PlatformController.cs:
```
using Godot;
using System.Collections.Generic;

public partial class PlatformController : AnimatableBody3D, Crusher
{
	private float lenght;
	private float speed;

	private Vector3 startPosition;
	private Vector3 dirVector;

	public MultiAudioStream audioStream;
	private float deltaTime;
	private bool isCrusher = false;
	private List<PlayerThing> playersToCrush = new List<PlayerThing>();
	public void Init(Vector3 dir, float sp, float phase, int height, bool crush, Vector3 origin, string noise)
	{
		dirVector = dir;

		lenght = height * GameManager.sizeDividor;
		speed = sp;

		deltaTime = 1000 * sp * phase;

		startPosition = Position;
		
		audioStream = new MultiAudioStream();
		AddChild(audioStream);
		audioStream.Bus = "BKGBus";
		audioStream.Position = origin;
		if (!string.IsNullOrEmpty(noise))
		{
			audioStream.Stream = SoundManager.LoadSound(noise, true);
			audioStream.Play();
		}
		isCrusher = crush;
	}
	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (isCrusher && playersToCrush.Count > 0)
		{
			for (int i = 0; i < playersToCrush.Count; i++)
				playersToCrush[i].Damage(1000, DamageType.Crusher);
			playersToCrush.Clear();
		}

		deltaTime += (float)delta;
		float newDistance = Mathf.Sin(2 * Mathf.Pi * deltaTime / speed) * lenght;
		Vector3 newPosition = startPosition + dirVector * newDistance;
		Position = newPosition;
	}
	public void Crush(PlayerThing player)
	{
		if (!isCrusher)
			return;

		//Crush on main thread
		if (!playersToCrush.Contains(player))
			playersToCrush.Add(player);
	}
}
```

./Assets/Scripts/ThingControllers/TeleporterThing.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;

public partial class TeleporterThing : Area3D
{
	public string TeleportInSound = "world/telein";
	public string TeleportOutSound = "world/teleout";

	public List<Target> destinations = new List<Target>();
	private List<PlayerThing> toTeleport = new List<PlayerThing>();
	private static PhysicsShapeQueryParameters3D SphereCast;
	public override void _Ready()
	{
		BodyEntered += OnBodyEntered;
		Rid Sphere = PhysicsServer3D.SphereShapeCreate();
		SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;
		PhysicsServer3D.ShapeSetData(Sphere, 2f);
	}
	public void Init(List<Target> dest, Dictionary<string, string> entityData)
	{
		foreach(var target in dest) 
		{
			Vector3 destination = target.destination;
			int angle = target.angle + 90;
			if (angle < -180)
				angle += 360;
			if (angle > 180)
				angle -= 360;

			destinations.Add(new Target(destination, angle, entityData));
		}
	}
	public static void TelefragEverything(Vector3 position, Node3D node)
	{
		SphereCast.CollisionMask = GameManager.TakeDamageMask | (1 << GameManager.RagdollLayer);
		SphereCast.Motion = Vector3.Zero;
		SphereCast.Transform = new Transform3D(Basis.Identity, position);
		var SpaceState = node.GetWorld3D().DirectSpaceState;
		var hits = SpaceState.IntersectShape(SphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is Damageable damageable)
			{
				if (collider != node)
					damageable.Damage(10000, DamageType.Telefrag, node);
			}
		}
		return;
	}
	void OnBodyEntered(Node3D other)
	{
		if (GameManager.Paused)
			return;

		if (other is PlayerThing playerThing)
		{
			if (!playerThing.ready)
				return;

			if (!toTeleport.Contains(playerThing))
				toTeleport.Add(playerThing);
		}
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (toTeleport.Count == 0)
			return;

		for (int i = 0; i < toTeleport.Count; i++)
		{
			PlayerThing playerThing = toTeleport[i];

			if (!string.IsNullOrEmpty(TeleportOutSound))
				SoundManager.Create3DSound(playerThing.Position, SoundManager.LoadSound(TeleportOutSound));

			Target target = destinations[GD.RandRange(0, destinations.Count - 1)];
			ClusterPVSManager.CheckPVS(playerThing.playerInfo.viewLayer, target.destination);
			TelefragEverything(target.destination, playerThing);
			playerThing.Position = target.destination;
			playerThing.playerControls.InvoqueSetTransformReset();

			if (!string.IsNullOrEmpty(TeleportInSound))
				SoundManager.Create3DSound(target.destination, SoundManager.LoadSound(TeleportInSound));
			playerThing.playerControls.viewDirection.Y = target.angle;
			playerThing.playerControls.impulseVector = Vector3.Zero;
			playerThing.playerControls.playerVelocity = Vector3.Zero;
			playerThing.playerControls.jumpPadVel = Vector3.Zero;
			playerThing.playerControls.fallSpeed = 0;
			Quaternion dir = Quaternion.FromEuler(new Vector3(0, Mathf.DegToRad(target.angle), 0));
			playerThing.Impulse(dir * Vector3.Forward, 1000);
			playerThing.avatar.ForceChangeView(dir);
		}
		toTeleport = new List<PlayerThing>();
	}
}
```

./Assets/Scripts/ThingControllers/ThingController.cs:
```
using Godot;
using System.Collections.Generic;

public partial class ThingController : Node3D
{
	public Node3D parent = null;

	[Export]
	public string respawnSound = "items/respawn1";
	[Export]
	public float respawnTime;
	[Export]
	public float randomTime = 0;
	[Export]
	public bool initDisabled = false;

	private float remainingTime = 0;
	private bool _disabled = false;
	public bool disabled { get { return _disabled; } }
	public enum ThingType
	{
		Decor, //non-blocking, non-interactive
		Blocking, //blocking or interactive
		Item,
		Teleport,
		WorldSpawn,
		Target,
		Trigger,
		Door,
		Spawn
	}
	[Export]
	public ThingType thingType = ThingType.Decor;

	[Export]
	public ItemPickup itemPickup = null;

	public string itemName;
	//Only 1 per Map according to GameType
	public bool uniqueItem = false;

	private List<ThingController> collidedItems = new List<ThingController>();
	public void SpawnCheck(string name)
	{
		itemName = name;
		if (initDisabled)
		{
			DisableThing();
			//Set first spawn time to 30s
			remainingTime = 30;
		}
	}

	public override void _Ready()
	{
		//Only Keep Items Active
		if (thingType != ThingType.Item)
			SetProcess(false);
	}

	public void CheckItemsNearBy()
	{
		SetPhysicsProcess(false);
		if (itemPickup == null)
			return;

		//Unique Items don't do checks
		if (uniqueItem)
			return;

		List<CollisionShape3D> Childrens = GameManager.GetAllChildrensByType<CollisionShape3D>(this);
		if (Childrens.Count == 0)
			return;
		
		var Sphere = Childrens[0].Shape.GetRid();
		var SphereCast = new PhysicsShapeQueryParameters3D();
		SphereCast.ShapeRid = Sphere;
		SphereCast.CollideWithAreas = true;
		SphereCast.CollideWithBodies = false;
		SphereCast.CollisionMask = (1 << GameManager.ThingsLayer);
		SphereCast.Motion = Vector3.Zero;
		SphereCast.Transform = GlobalTransform;
		var SpaceState = GetWorld3D().DirectSpaceState;
		var hits = SpaceState.IntersectShape(SphereCast);
		var max = hits.Count;

		for (int i = 0; i < max; i++)
		{
			var hit = hits[i];

			CollisionObject3D collider = (CollisionObject3D)hit["collider"];
			if (collider is ItemPickup item)
			{
				//Don't Add Self
				if (item == itemPickup)
					continue;

				collidedItems.Add(item.thingController);
			}
		}
	}

	public override void _Process(double delta)
	{
		if (GameManager.Paused)
			return;

		if (disabled)
		{
			float deltaTime = (float)delta;
			remainingTime -= deltaTime;
			if (remainingTime < 0)
			{
				if (collidedItems.Count > 0)
				{
					bool blocked = false;
					for (int i = 0; i < collidedItems.Count; i++)
					{
						if (!collidedItems[i].disabled)
							blocked = true;
					}
					if (blocked)
					{
						remainingTime += 5;
						return;
					}
				}
				remainingTime = 0;
				_disabled = false;
				Visible = true;
				if (!string.IsNullOrEmpty(respawnSound))
					SoundManager.Create3DSound(GlobalPosition, SoundManager.LoadSound(respawnSound));
			}
		}
	}

	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		CheckItemsNearBy();
	}

	public void SetRandomTime(float waitTime)
	{
		randomTime = waitTime;
	}
	public void SetRespawnTime(float waitTime)
	{
		respawnTime = waitTime;
	}
	public void RespawnNow()
	{
		remainingTime = 0;
	}

	public void DisableThing()
	{
		//No longer respawn
		if (respawnTime < 0)
		{
			if (parent != null)
				parent.QueueFree();
			else
				QueueFree();
		}

		remainingTime = (float)GD.RandRange(respawnTime - randomTime, respawnTime + randomTime);
		Visible = false;
		_disabled = true;
	}

	public override void _Notification(int what)
	{
		if (what == NotificationPredelete)
			CheckDestroy();
	}
	public void CheckDestroy()
	{
		if (disabled)
			return;

		//GameType
		if (uniqueItem)
		{
			if (ThingsManager.uniqueThingsOnMap.TryGetValue(itemName, out ThingController masterThing))
				masterThing.RespawnNow();
		}
	}
}
```

./Assets/Scripts/ThingControllers/ElevatorController.cs:
```
using Godot;
using System;
using System.Collections.Generic;

public partial class ElevatorController : AnimatableBody3D, Crusher
{
	public bool playSoundDown = true;
	public string startSound = "movers/plats/pt1_strt";
	public string endSound = "movers/plats/pt1_end";
	public TriggerController tc;
	public int damage = 4;
	public bool crusher = false;
	private float lip;
	private Aabb elevator;
	private float speed;

	private float UpWaitTime = 0;
	private Vector3 UpPosition, DownPosition;
	private Vector3 dirVector = Vector3.Up;

	private float waitTime = 2;

	public MultiAudioStream audioStream;
	private float UpSqrMagnitude;
	private List<PlayerThing> playersToCrush = new List<PlayerThing>();
	public enum State
	{
		None,
		Down,
		Lowering,
		Up,
		Rising
	}

	public State currentState = State.Down;

	public State CurrentState
	{
		get { return currentState; }
		set
		{
			if (value == State.Up)
			{
				if ((currentState != State.Up) && (!string.IsNullOrEmpty(endSound)))
				{
					audioStream.Stream = SoundManager.LoadSound(endSound);
					audioStream.Play();
				}
				UpWaitTime = waitTime;
			}
			else if (value == State.Rising)
			{
				if (!string.IsNullOrEmpty(startSound))
				{
					audioStream.Stream = SoundManager.LoadSound(startSound);
					audioStream.Play();
				}
				SetPhysicsProcess(true);
			}
			else if (value == State.Lowering)
			{
				if (playSoundDown)
					if (!string.IsNullOrEmpty(startSound))
					{
						audioStream.Stream = SoundManager.LoadSound(startSound);
						audioStream.Play();
					}
				SetPhysicsProcess(true);
			}
			else if (value == State.Down)
			{
				if (playSoundDown)
					if (!string.IsNullOrEmpty(endSound))
					{
						audioStream.Stream = SoundManager.LoadSound(endSound);
						audioStream.Play();
					}
				SetPhysicsProcess(false);
			}
			currentState = value;
		}
	}
	public void Init(int sp, int Height, int Uplip, Aabb box, int model, int dmg = 4)
	{		
		speed = sp * GameManager.sizeDividor;
		lip = Uplip * GameManager.sizeDividor;
		damage = dmg;
		if (dmg > 100)
			crusher = true;

		if (model >= 0)
		{
			elevator = box;
			if (Height == 0)
				SetBounds();
			else
				SetBounds(Height);
		}
		else
			SetBounds(Height);

		audioStream = new MultiAudioStream();
		AddChild(audioStream);
		audioStream.Bus = "BKGBus";
		audioStream.Position = elevator.GetCenter();
		CurrentState = State.Up;
	}
	public override void _PhysicsProcess(double delta)
	{
		if (GameManager.Paused)
			return;

		if (playersToCrush.Count > 0)
		{
			for (int i = 0; i < playersToCrush.Count; i++)
			{
				playersToCrush[i].Damage(damage, DamageType.Crusher);
				if (!crusher)
					CurrentState = State.Rising;

			}
			playersToCrush.Clear();
		}

		float deltaTime = (float)delta;
		switch (CurrentState)
		{
			default:
			break;
			case State.Up:
			if (UpWaitTime > 0)
			{
				UpWaitTime -= deltaTime;
				if (UpWaitTime <= 0)
					CurrentState = State.Lowering;
			}
			break;
			case State.Lowering:
			{
				float newDistance = deltaTime * speed;
				Vector3 newPosition = Position - dirVector * newDistance;
				float sqrMagnitude = (UpPosition - newPosition).LengthSquared();
				if (sqrMagnitude > UpSqrMagnitude)
				{
					newPosition = DownPosition;
					CurrentState = State.Down;
				}
				Position = newPosition;
			}
			break;
			case State.Down:
			break;
			case State.Rising:
			{
				float newDistance = deltaTime * speed;
				Vector3 newPosition = Position + dirVector * newDistance;
				float sqrMagnitude = (newPosition - DownPosition).LengthSquared();
				if (sqrMagnitude > UpSqrMagnitude)
				{
					newPosition = UpPosition;
					CurrentState = State.Up;
				}
				Position = newPosition;
			}
			break;
		}
	}

	public void SetBounds()
	{
		UpPosition = Position;
		Vector3 extension = dirVector * (elevator.Size.Y - lip);
		DownPosition = UpPosition - extension;
		UpSqrMagnitude = (UpPosition - DownPosition).LengthSquared();
	}

	public void SetBounds(float height)
	{
		height *= GameManager.sizeDividor;
		UpPosition = Position;
		DownPosition = UpPosition - dirVector * height;
		UpSqrMagnitude = (UpPosition - DownPosition).LengthSquared();
	}

	public void Crush(PlayerThing player)
	{
		//Crush on main thread
		if (!playersToCrush.Contains(player))
			playersToCrush.Add(player);
	}
}
```

./Assets/ThirdParty/MultiAudioListener/MultiAudioStream.cs:
```
using Godot;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public partial class MultiAudioStream : Node3D
{
	//Properties from the normal AudioStreamPlayer3D

	private AudioStream _stream = null;
	[Export]
	public AudioStream Stream
	{
		get { return _stream; }
		set
		{
			_stream = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.Stream = value;
			}
		}
	}

	private uint _areaMask = 1;
	[Export]
	public uint AreaMask
	{
		get { return _areaMask; }
		set
		{
			_areaMask = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.AreaMask = value;
			}
		}
	}

	private float _attenuationFilterCutoffHz = 5000.0f;
	[Export]
	public float AttenuationFilterCutoffHz
	{
		get { return _attenuationFilterCutoffHz; }
		set
		{
			_attenuationFilterCutoffHz = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.AttenuationFilterCutoffHz = value;
			}
		}
	}

	private float _attenuationFilterDb = -24.0f;
	[Export]
	public float AttenuationFilterDb
	{
		get { return _attenuationFilterDb; }
		set
		{
			_attenuationFilterDb = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.AttenuationFilterDb = value;
			}
		}
	}

	private AudioStreamPlayer3D.AttenuationModelEnum _attenuationModel = AudioStreamPlayer3D.AttenuationModelEnum.InverseDistance;
	[Export]
	public AudioStreamPlayer3D.AttenuationModelEnum AttenuationModel
	{
		get { return _attenuationModel; }
		set
		{
			_attenuationModel = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.AttenuationModel = value;
			}
		}
	}

	private string _bus = "Master";
	[Export]
	public string Bus
	{
		get { return _bus; }
		set
		{
			_bus = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.Bus = value;
			}
		}
	}

	private float _emissionAngleDegrees = 45.0f;
	[Export]
	public float EmissionAngleDegrees
	{
		get { return _emissionAngleDegrees; }
		set
		{
			_emissionAngleDegrees = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.EmissionAngleDegrees = value;
			}
		}
	}

	private bool _emissionAngleEnabled = false;
	[Export]
	public bool EmissionAngleEnabled
	{
		get { return _emissionAngleEnabled; }
		set
		{
			_emissionAngleEnabled = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.EmissionAngleEnabled = value;
			}
		}
	}

	private float _emissionAngleFilterAttenuationDb = -12.0f;
	[Export]
	public float EmissionAngleFilterAttenuationDb
	{
		get { return _emissionAngleFilterAttenuationDb; }
		set
		{
			_emissionAngleFilterAttenuationDb = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.EmissionAngleFilterAttenuationDb = value;
			}
		}
	}

	private float _maxDb = 3.0f;
	[Export]
	public float MaxDb
	{
		get { return _maxDb; }
		set
		{
			_maxDb = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.MaxDb = value;
			}
		}
	}
	
	private float _maxDistance = 0.0f;
	[Export]
	public float MaxDistance
	{
		get { return _maxDistance; }
		set
		{
			_maxDistance = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.MaxDistance = value;
			}
		}
	}
	
	private int _maxPolyphony = 1;
	[Export]
	public int MaxPolyphony
	{
		get { return _maxPolyphony; }
		set
		{
			_maxPolyphony = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.MaxPolyphony = value;
			}
		}
	}
	
	private float _panningStrength = 1.0f;
	[Export]
	public float PanningStrength
	{
		get { return _panningStrength; }
		set
		{
			_panningStrength = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.PanningStrength = value;
			}
		}
	}
	
	private float _pitchScale = 1.0f;
	[Export]
	public float PitchScale
	{
		get { return _pitchScale; }
		set
		{
			_pitchScale = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.PitchScale = value;
			}
		}
	}
	
	private float _unitSize = 10.0f;
	[Export]
	public float UnitSize
	{
		get { return _unitSize; }
		set
		{
			_unitSize = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.UnitSize = value;
			}
		}
	}

	private float _volumeDb = 0.0f;
	[Export]
	public float VolumeDb
	{
		get { return _volumeDb; }
		set
		{
			_volumeDb = value;
			foreach (var subAudioStream in _subAudioStreams)
			{
				subAudioStream.Value.VolumeDb = value;
			}
		}
	}

	private bool _destroyAfterSoundPlayed = false;
	public bool DestroyAfterSoundPlayed
	{
		get { return _destroyAfterSoundPlayed; }
		set
		{
			_destroyAfterSoundPlayed = value;
		}
	}

	private bool _is2DAudio = false;
	public bool Is2DAudio
	{
		get { return _is2DAudio; }
		set
		{
			_is2DAudio = value;
		}
	}
	//Internal components

	private Dictionary<VirtualAudioListener, AudioStreamPlayer3D> _subAudioStreams = new Dictionary<VirtualAudioListener, AudioStreamPlayer3D>();

	private bool _Playing = false;
	public bool Playing
	{
		get { return _Playing; }

	}
	public override void _ExitTree()
	{
		if (_Playing)
		{
			Stop();
		}
	}

	public void Play(float FromPosition = 0.0f)
	{
		if (!_Playing)
		{
			_Playing = true;

			//We subscribe to these events so sub audio sources can be added or removed if needed
			MultiAudioListener.OnVirtualAudioListenerAdded += VirtualAudioListenerAdded;
			MultiAudioListener.OnVirtualAudioListenerRemoved += VirtualAudioListenerRemoved;

			bool hardwareChannelsLeft = true;

			//Create all sub audio stream
			var virtualAudioListeners = MultiAudioListener.ROVirtualAudioListeners;
			for (int i = 0; i < virtualAudioListeners.Count; i++)
			{
				CreateSubAudioStream(virtualAudioListeners[i], ref hardwareChannelsLeft);
			}
		}
		else
		{
			foreach (var audioStream in _subAudioStreams)
			{
				audioStream.Value.Play(FromPosition);
			}
		}
	}

	public void Stop()
	{
		if (!_Playing)
			return;

		_Playing = false;

		MultiAudioListener.OnVirtualAudioListenerAdded -= VirtualAudioListenerAdded;
		MultiAudioListener.OnVirtualAudioListenerRemoved -= VirtualAudioListenerRemoved;

		//Remove all old subAudio
		foreach (var subAudioStream in _subAudioStreams)
		{
			if (subAudioStream.Value != null)
			{
				MultiAudioListener.EnquequeAudioStreamInPool(subAudioStream.Value);
			}
		}
		_subAudioStreams.Clear();
		if (DestroyAfterSoundPlayed)
			QueueFree();
	}

	private void VirtualAudioListenerAdded(VirtualAudioListener virtualAudioListener)
	{
		bool hardwareChannelsLeft = true;
		if ((Is2DAudio) && (_subAudioStreams.Count > 0))
			return;

		CreateSubAudioStream(virtualAudioListener, ref hardwareChannelsLeft);
	}

	private void VirtualAudioListenerRemoved(VirtualAudioListener virtualAudioListener)
	{
		AudioStreamPlayer3D audioStream;

		if (!_subAudioStreams.TryGetValue(virtualAudioListener, out audioStream))
			return;

		_subAudioStreams.Remove(virtualAudioListener);
		if (audioStream != null)
			MultiAudioListener.EnquequeAudioStreamInPool(audioStream);
	}

	private void CreateSubAudioStream(VirtualAudioListener virtualAudioListener, ref bool hardWareChannelsLeft)
	{
		AudioStreamPlayer3D audioStream = CreateAudioStream("Sub Audio Stream " + virtualAudioListener.Num, ref hardWareChannelsLeft);
		_subAudioStreams.Add(virtualAudioListener, audioStream);
		audioStream.VolumeDb = VolumeDb * virtualAudioListener.Volume;

		//Do transform
		MoveSubAudioStreamToNeededLocation(virtualAudioListener, audioStream);
	}

	private void MoveSubAudioStreamToNeededLocation(VirtualAudioListener virtualListener, AudioStreamPlayer3D subAudioStream)
	{
		//There is no main listener so translation is not needed
		if (MultiAudioListener.Main == null) 
			return;

		if (Is2DAudio)
		{
			GlobalPosition = MultiAudioListener.Main.GlobalPosition;
			return;
		}

		// Get the position of the object relative to the virtual listener
		Vector3 localPos = GlobalPosition - virtualListener.GlobalPosition;
		subAudioStream.Position = virtualListener.Quaternion * localPos;
	}

	private AudioStreamPlayer3D CreateAudioStream(string nameSubAudioStream, ref bool hardwareChannelsLeft)
	{
		AudioStreamPlayer3D audioStream = MultiAudioListener.GetAudioStreamFromPool();
		//If no audiosource was given by pool, make a new one
		if (audioStream == null)
		{
			audioStream = new AudioStreamPlayer3D();
			audioStream.Name = nameSubAudioStream;
			MultiAudioListener.Main.AddChild(audioStream);
		}
		else
		{
			audioStream.Name = nameSubAudioStream;
		}

		SetAllValuesAudioStream(audioStream);

		if (_Playing && hardwareChannelsLeft)
		{
			float position = 0f;

			//Play from position of first audioStream
			if (_subAudioStreams.Count > 0)
				position = _subAudioStreams.First().Value.GetPlaybackPosition();

			audioStream.Play(position);
			//If this sound gets culled all following will be too
			if (!audioStream.Playing)
			{
				hardwareChannelsLeft = false;
			}
		}
		//All audio doppler effect should be  zero
		audioStream.DopplerTracking = AudioStreamPlayer3D.DopplerTrackingEnum.Disabled;
		return audioStream;
	}
	public void RefreshAllPropertiesAudioStreams()
	{
		foreach (var subAudioStream in _subAudioStreams)
		{
			SetAllValuesAudioStream(subAudioStream.Value);
		}
	}

	private void SetAllValuesAudioStream(AudioStreamPlayer3D audioStream)
	{
		audioStream.Stream = Stream;
		audioStream.AreaMask = AreaMask;
		audioStream.AttenuationFilterCutoffHz = AttenuationFilterCutoffHz;
		audioStream.AttenuationFilterDb = AttenuationFilterDb;
		audioStream.AttenuationModel = AttenuationModel;
		audioStream.Autoplay = false;
		audioStream.Bus = Bus;
		audioStream.EmissionAngleDegrees = EmissionAngleDegrees;
		audioStream.EmissionAngleEnabled = EmissionAngleEnabled;
		audioStream.EmissionAngleFilterAttenuationDb = EmissionAngleFilterAttenuationDb;
		audioStream.MaxDb = MaxDb;
		audioStream.MaxDistance = MaxDistance;
		audioStream.MaxPolyphony = MaxPolyphony;
		audioStream.PanningStrength = PanningStrength;
		audioStream.PitchScale = PitchScale;
		audioStream.UnitSize = UnitSize;

	}

	public override void _Ready()
	{
		ProcessPhysicsPriority = 10;
	}

	public override void _PhysicsProcess(double delta)
	{
		if (_Playing)
		{
			//Closest audioCulling
			AudioStreamPlayer3D closestAudio = null;
			float distanceClosestAudio = 0;
			bool isCurrentlyPlaying = false;

			foreach (var subAudioStream in _subAudioStreams)
			{
				//We set the the correct volume before we cull
				subAudioStream.Value.VolumeDb = VolumeDb;

				var distance = (subAudioStream.Key.GlobalPosition - GlobalPosition).LengthSquared();

				if ((closestAudio == null) || (distance < distanceClosestAudio))
				{
					if (closestAudio != null)
						closestAudio.VolumeDb = -100.0f;

					closestAudio = subAudioStream.Value;
					closestAudio.VolumeDb = VolumeDb * subAudioStream.Key.Volume;
					distanceClosestAudio = distance;
				}
				else
					subAudioStream.Value.VolumeDb = -100.0f;

				MoveSubAudioStreamToNeededLocation(subAudioStream.Key, subAudioStream.Value);
				isCurrentlyPlaying |= subAudioStream.Value.Playing;
			}

			//is there anyone listening?
			if (MultiAudioListener.ROVirtualAudioListeners.Count > 0)
			{
				if (!isCurrentlyPlaying)
					Stop();
			}
		}
	}
}
```

./Assets/ThirdParty/MultiAudioListener/VirtualAudioListener.cs:
```
using Godot;
using System;

public partial class VirtualAudioListener : Node3D
{
	public float Volume = 1.0f;
	public int Num = 0;
	public override void _EnterTree()
	{
		MultiAudioListener.AddVirtualAudioListener(this);
	}

	public override void _ExitTree()
	{
		MultiAudioListener.RemoveVirtualAudioListener(this);
	}
}
```

./Assets/ThirdParty/MultiAudioListener/MultiAudioListener.cs:
```
using Godot;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

public partial class MultiAudioListener : Node3D
{
	private static List<VirtualAudioListener> _virtualAudioListeners = new List<VirtualAudioListener>();
	public static event Action<VirtualAudioListener> OnVirtualAudioListenerAdded;
	public static event Action<VirtualAudioListener> OnVirtualAudioListenerRemoved;

	public static MultiAudioListener Main;

	//AudioStraem pool
	//We limit the amount of items in the audio source pool. This number can be changed
	private const int MaximumItemsAudioStreamPool = 512;
	//We limit the amount of audio listener to 8 SplitScreen
	private const int MaximumVirtualAudioListener = 8;
	private static Queue<AudioStreamPlayer3D> _audioStreamPool = new Queue<AudioStreamPlayer3D>();

	//We add the AudioStream in the pool, so that it can be reused.
	public static void EnquequeAudioStreamInPool(AudioStreamPlayer3D audioStream)
	{
		if (audioStream == null)
			return;
		if (_audioStreamPool.Count >= MaximumItemsAudioStreamPool)
		{
			audioStream.QueueFree();
			return;
		}
		audioStream.Stop();
		audioStream.VolumeDb = -100.0f;
		_audioStreamPool.Enqueue(audioStream);
	}

	//Will be null if no valid AudioStream is in pool
	public static AudioStreamPlayer3D GetAudioStreamFromPool()
	{
		while (_audioStreamPool.Count > 0)
		{
			var audioStream = _audioStreamPool.Dequeue();
			if (audioStream != null)
			{
				audioStream.VolumeDb = 0;
				return audioStream;
			}
		}
		//No valid audio stream in queque anymore
		return null;
	}

	public static void DeleteContentsAudioStreamPool()
	{
		while (_audioStreamPool.Count > 0)
		{
			var audioStream = _audioStreamPool.Dequeue();
			if (audioStream != null)
			{
				audioStream.QueueFree();
			}
		}
	}

	public static ReadOnlyCollection<VirtualAudioListener> ROVirtualAudioListeners
	{
		get { return _virtualAudioListeners.AsReadOnly(); }
	}

	public static void AddVirtualAudioListener(VirtualAudioListener virtualAudioListener)
	{
		if (_virtualAudioListeners.Count >= MaximumVirtualAudioListener)
			return;
		if (_virtualAudioListeners.Contains(virtualAudioListener))
			return;
		_virtualAudioListeners.Add(virtualAudioListener);
		virtualAudioListener.Num = _virtualAudioListeners.Count;
		if (OnVirtualAudioListenerAdded != null)
			OnVirtualAudioListenerAdded(virtualAudioListener);
	}
	public static void RemoveVirtualAudioListener(VirtualAudioListener virtualAudioListener)
	{
		if (_virtualAudioListeners.Contains(virtualAudioListener))
		{
			_virtualAudioListeners.Remove(virtualAudioListener);
			if (OnVirtualAudioListenerRemoved != null)
				OnVirtualAudioListenerRemoved(virtualAudioListener);
		}
	}
	public override void _Ready()
	{
		Main = this;
	}
}
```

